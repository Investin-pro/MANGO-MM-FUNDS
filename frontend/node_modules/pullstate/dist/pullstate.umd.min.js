!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("immer")):"function"==typeof define&&define.amd?define(["exports","react","immer"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).pullstate={},e.React,e.immer)}(this,(function(e,t,s){"use strict";function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=r(t),o=r(s),a=function e(t,s){if(t===s)return!0;if(t&&s&&"object"==typeof t&&"object"==typeof s){if(t.constructor!==s.constructor)return!1;var r,n,o;if(Array.isArray(t)){if((r=t.length)!=s.length)return!1;for(n=r;0!=n--;)if(!e(t[n],s[n]))return!1;return!0}if(t instanceof Map&&s instanceof Map){if(t.size!==s.size)return!1;for(n of t.entries())if(!s.has(n[0]))return!1;for(n of t.entries())if(!e(n[1],s.get(n[0])))return!1;return!0}if(t instanceof Set&&s instanceof Set){if(t.size!==s.size)return!1;for(n of t.entries())if(!s.has(n[0]))return!1;return!0}if(ArrayBuffer.isView(t)&&ArrayBuffer.isView(s)){if((r=t.length)!=s.length)return!1;for(n=r;0!=n--;)if(t[n]!==s[n])return!1;return!0}if(t.constructor===RegExp)return t.source===s.source&&t.flags===s.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===s.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===s.toString();if((r=(o=Object.keys(t)).length)!==Object.keys(s).length)return!1;for(n=r;0!=n--;)if(!Object.prototype.hasOwnProperty.call(s,o[n]))return!1;for(n=r;0!=n--;){var a=o[n];if(!e(t[a],s[a]))return!1}return!0}return t!=t&&s!=s};function c(e,s,r){const n=t.useRef({state:void 0,initialized:!1});n.current.initialized||(n.current.state=s?s(e.getRawState()):e.getRawState(),n.current.initialized=!0);const[,o]=t.useState(0);if(t.useEffect((()=>{const t={shouldUpdate:!0};function r(){if(t.shouldUpdate){const r=s?s(e.getRawState()):e.getRawState();a(n.current.state,r)||t.shouldUpdate&&(n.current.state=r,o((e=>e+1)))}}return e._addUpdateListener(r),r(),()=>{t.shouldUpdate=!1,e._removeUpdateListener(r)}}),null!=r?r:[]),void 0!==r){const o=t.useRef(r);a(r,o)||(n.current.state=s(e.getRawState()))}return n.current.state}let i=0;function u(e,t){return t.reduce(((t=e,s)=>t[s]),void 0)}function l(e,t){const s=e.getRawState(),r=[];for(const e of t)r.push(u(s,e));return r}function h(e,s){const[r,n]=t.useState((()=>l(e,s))),o=t.useRef({shouldUpdate:!0,onStoreUpdate:null,currentSubState:null,ordKey:"_"+i++});return o.current.currentSubState=r,null===o.current.onStoreUpdate&&(o.current.onStoreUpdate=function(){o.current.shouldUpdate&&n(l(e,s))},e._addUpdateListenerOpt(o.current.onStoreUpdate,o.current.ordKey,s)),t.useEffect((()=>()=>{o.current.shouldUpdate=!1,e._removeUpdateListenerOpt(o.current.ordKey)}),[]),r}function d(e,s){const r=t.useRef();if(null==r.current&&(r.current=new y(e)),void 0!==s){const n=t.useRef(s);a(s,n)||(r.current=new y(e))}return r.current}const f={storeOrdinal:0,batching:!1,flushStores:{}};s.enablePatches();const p="~._.~";class y{constructor(e){if(this.updateListeners=[],this.ssr=!1,this.reactions=[],this.clientSubscriptions=[],this.reactionCreators=[],this.optimizedUpdateListeners={},this.optimizedUpdateListenerPaths={},this.optimizedListenerPropertyMap={},this._optListenerCount=0,this._patchListeners=[],e instanceof Function){const t=e();this.currentState=t,this.initialState=t,this.createInitialState=e}else this.currentState=e,this.initialState=e,this.createInitialState=()=>e;this.internalOrdId=f.storeOrdinal++}_setInternalOptions({ssr:e,reactionCreators:t=[]}){this.ssr=e,this.reactionCreators=t,this.reactions=t.map((e=>e(this)))}_getReactionCreators(){return this.reactionCreators}_instantiateReactions(){this.reactions=this.reactionCreators.map((e=>e(this)))}_getInitialState(){return this.createInitialState()}_updateStateWithoutReaction(e){this.currentState=e}_updateState(e,t=[]){this.currentState=e,this.batchState=void 0;for(const e of this.reactions)t.push(...e());if(!this.ssr){for(const e of this.clientSubscriptions)e();if(t.length>0){const e=new Set;for(const s of t)if(this.optimizedListenerPropertyMap[s])for(const t of this.optimizedListenerPropertyMap[s])e.add(t);for(const t of e.values())this.optimizedUpdateListeners[t]&&this.optimizedUpdateListeners[t]()}this.updateListeners.forEach((e=>e()))}}_addUpdateListener(e){this.updateListeners.push(e)}_addUpdateListenerOpt(e,t,s){this.optimizedUpdateListeners[t]=e;const r=s.map((e=>e.join(p)));this.optimizedUpdateListenerPaths[t]=r;for(const e of r)null==this.optimizedListenerPropertyMap[e]?this.optimizedListenerPropertyMap[e]=[t]:this.optimizedListenerPropertyMap[e].push(t);this._optListenerCount++}_removeUpdateListener(e){this.updateListeners=this.updateListeners.filter((t=>t!==e))}_removeUpdateListenerOpt(e){const t=this.optimizedUpdateListenerPaths[e];for(const s of t)this.optimizedListenerPropertyMap[s]=this.optimizedListenerPropertyMap[s].filter((t=>t!==e));delete this.optimizedUpdateListenerPaths[e],delete this.optimizedUpdateListeners[e],this._optListenerCount--}listenToPatches(e){return this._patchListeners.push(e),()=>{this._patchListeners=this._patchListeners.filter((t=>t!==e))}}subscribe(e,t){if(!this.ssr){const s=function(e,t,s){let r=t(e.getRawState());return()=>{const n=e.getRawState(),o=t(n);a(o,r)||(s(o,n,r),r=o)}}(this,e,t);return this.clientSubscriptions.push(s),()=>{this.clientSubscriptions=this.clientSubscriptions.filter((e=>e!==s))}}return()=>{console.warn("Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.")}}createReaction(e,t,{runNow:r=!1,runNowWithSideEffects:n=!1}={}){const o=function(e,t){return r=>{let n=e(r.getRawState());return(o=!1)=>{const c=r.getRawState(),i=e(c);if(o||!a(i,n))if(r._optListenerCount>0){const[e,o,a]=s.produceWithPatches(c,(e=>t(i,e,c,n)));if(r._updateStateWithoutReaction(e),n=i,o.length>0)return r._patchListeners.forEach((e=>e(o,a))),Object.keys(C(o))}else{if(r._patchListeners.length>0){const[e,o,a]=s.produceWithPatches(c,(e=>t(i,e,c,n)));o.length>0&&r._patchListeners.forEach((e=>e(o,a))),r._updateStateWithoutReaction(e)}else r._updateStateWithoutReaction(s.produce(c,(e=>t(i,e,c,n))));n=i}return[]}}}(e,t);this.reactionCreators.push(o);const c=o(this);return this.reactions.push(c),(r||n)&&(c(!0),n&&!this.ssr&&this._updateState(this.currentState)),()=>{this.reactions=this.reactions.filter((e=>e!==c))}}getRawState(){return void 0!==this.batchState?this.batchState:this.currentState}useState(e,t){return c(this,e,t)}useLocalCopyInitial(e){return d(this.createInitialState,e)}useLocalCopySnapshot(e){return d(this.currentState,e)}flushBatch(e=!1){void 0!==this.batchState?this.batchState!==this.currentState&&this._updateState(this.batchState):e||console.error("Pullstate: Trying to flush batch state which was never created or updated on"),this.batchState=void 0}update(e,t){if(f.batching){void 0===this.batchState&&(this.batchState=this.currentState,f.flushStores[this.internalOrdId]=this);const s="function"==typeof e,[r,n,o]=g(this.batchState,e,s);n.length>0&&(this._patchListeners.length>0||t)&&(t&&t(n,o),this._patchListeners.forEach((e=>e(n,o)))),this.batchState=r}else this.batchState=void 0,E(this,e,t)}replace(e){this._updateState(e)}applyPatches(e){!function(e,t){const r=e.getRawState(),n=s.applyPatches(r,t);n!==r&&e._updateState(n,Object.keys(C(t)))}(this,e)}}function C(e,t={}){for(const s of e){let e;for(const r of s.path)e=e?`${e}~._.~${r}`:r,t[e]=1}return t}function g(e,t,r){return r?s.produceWithPatches(e,(s=>t(s,e))):t.reduce((([e,t,r],n)=>{const o=s.produceWithPatches(e,(t=>n(t,e)));return t.push(...o[1]),r.push(...o[2]),[o[0],t,r]}),[e,[],[]])}function E(e,t,r){const n=e.getRawState(),o="function"==typeof t;if(e._optListenerCount>0){const[s,a,c]=g(n,t,o);a.length>0&&(r&&r(a,c),e._patchListeners.forEach((e=>e(a,c))),e._updateState(s,Object.keys(C(a))))}else{let a;if(e._patchListeners.length>0||r){const[s,c,i]=g(n,t,o);c.length>0&&(r&&r(c,i),e._patchListeners.forEach((e=>e(c,i)))),a=s}else a=s.produce(n,(e=>o?t(e,n):t.reduce(((e,t)=>s.produce(e,(s=>t(s,e)))),n)));a!==n&&e._updateState(a)}}var S,_;(S=e.EAsyncEndTags||(e.EAsyncEndTags={})).THREW_ERROR="THREW_ERROR",S.RETURNED_ERROR="RETURNED_ERROR",S.UNFINISHED="UNFINISHED",S.DORMANT="DORMANT",(_=e.EPostActionContext||(e.EPostActionContext={})).WATCH_HIT_CACHE="WATCH_HIT_CACHE",_.BECKON_HIT_CACHE="BECKON_HIT_CACHE",_.RUN_HIT_CACHE="RUN_HIT_CACHE",_.READ_HIT_CACHE="READ_HIT_CACHE",_.READ_RUN="READ_RUN",_.SHORT_CIRCUIT="SHORT_CIRCUIT",_.DIRECT_RUN="DIRECT_RUN",_.BECKON_RUN="BECKON_RUN",_.CACHE_UPDATE="CACHE_UPDATE";const k={listeners:{},results:{},actions:{},actionOrd:{}};let A,b=0;function R(e){if(null===e)return"(n)";const t=typeof e;if("object"!==t){if("undefined"===t)return"(u)";if("string"===t)return":"+e+";";if("boolean"===t||"number"===t)return"("+e+")"}let s="{";for(const t of Object.keys(e).sort())s+=t+R(e[t]);return s+"}"}function m(e){if(k.listeners.hasOwnProperty(e))for(const t of Object.keys(k.listeners[e]))k.listeners[e][t]()}function O(e,t=!0,s=!0){t&&k.actionOrd.hasOwnProperty(e)&&(k.actionOrd[e]+=1),delete k.results[e],s&&m(e)}function P(e,t){return e.actionOrd.hasOwnProperty(t)?e.actionOrd[t]+=1:e.actionOrd[t]=0,e.actionOrd[t]}function v(e=null,t=[],s=""){return{payload:e,tags:t,message:s,error:!1,errorPayload:null}}class w extends Error{constructor(e,t){super(e),this.tags=t}}try{A=new Proxy({},{get:function(e,t){throw new Error(`Pullstate: Trying to access store (${String(t)}) inside async actions without the correct usage or setup.\nIf this error occurred on the server:\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\n\nIf this error occurred on the client:\n* Make sure you have created your "pullstateCore" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`)}})}catch{A={}}const I=[!0,!1,{message:"",tags:[e.EAsyncEndTags.UNFINISHED],error:!0,payload:null,errorPayload:null},!1,-1];function T(e,t={}){return U((async(t,s,r)=>v(await e(t,s,r))),t)}function B(e){if(null!=e)return"boolean"==typeof e?()=>e:"number"==typeof e?({timeCached:t,result:s})=>!!s.error||Date.now()-t>e:e}function U(s,{forceContext:r=!1,shortCircuitHook:c,cacheBreakHook:i,postActionHook:u,subsetKey:l,actionId:h}={}){const d=null!=h?"_"+h:b++,f="undefined"==typeof window;function p(e,t){return null!=t?`${d}-c-${t}`:void 0!==l?`${d}-${R(l(e))}`:`${d}-${R(e)}`}const y="def_wait_"+p({});let C={},g=0;const E={};function S(e,t,s,r){void 0!==u&&u({args:t,result:e,stores:s,context:r})}function _({args:e,cache:t,cacheBreakEnabled:s,context:r,fromListener:n,key:o,postActionEnabled:a,stores:c,customCacheBreak:u}){const l=null!=u?u:i;if(t.results.hasOwnProperty(o)){const i=C.hasOwnProperty(o)&&C[o]>2;if(!f&&!n&&s&&null!=l&&t.results[o][1]&&l({args:e,result:t.results[o][2],stores:c,timeCached:t.results[o][4]})&&!i){C.hasOwnProperty(o)?C[o]++:C[o]=1;const e=t.results[o];return delete t.results[o],{cacheBroke:!0,response:void 0,previous:e}}return i?console.error(`[${o}] Pullstate detected an infinite loop caused by cacheBreakHook()\nreturning true too often (breaking cache as soon as your action is resolving - hence\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\nfurther looping. Fix in your cacheBreakHook() is needed.`):C[o]=0,a&&t.results[o][1]&&!n&&S(t.results[o][2],e,c,r),{response:t.results[o],cacheBroke:!1,previous:void 0}}return{cacheBroke:!1,response:void 0,previous:void 0}}function T(t,r,n,o,a,c,i,u){return()=>s(n,o,u).then((e=>(a===r.actionOrd[t]&&(c&&S(e,n,o,i),r.results[t]=[!0,!0,e,!1,Date.now()]),e))).catch((s=>{console.error(s);const u={payload:null,errorPayload:null,error:!0,tags:[e.EAsyncEndTags.THREW_ERROR],message:s.message};return a===r.actionOrd[t]&&(c&&S(u,n,o,i),r.results[t]=[!0,!0,u,!1,Date.now()]),u})).then((e=>(a===r.actionOrd[t]&&(delete r.actions[t],f||m(t)),e)))}function U({key:t,cache:s,initiate:r,ssr:n,args:o,stores:a,fromListener:i=!1,postActionEnabled:u=!0,cacheBreakEnabled:l=!0,holdingResult:h,customContext:d,customCacheBreak:p,holdPrevious:y}){const C=_({key:t,cache:s,args:o,stores:a,context:r?e.EPostActionContext.BECKON_HIT_CACHE:e.EPostActionContext.WATCH_HIT_CACHE,postActionEnabled:u,cacheBreakEnabled:l,fromListener:i,customCacheBreak:p});if(C.response)return C.response;if(!s.actions.hasOwnProperty(t)){const i=P(s,t);if(!r){const r=[!1,!1,{message:"",tags:[e.EAsyncEndTags.UNFINISHED],error:!0,payload:null,errorPayload:null},!1,-1];if(f||(s.results[t]=r),y){if(h){const e=[...h];return e[3]=!0,e}if(null!=C.previous){const e=[...C.previous];return e[3]=!0,e}}return r}if(void 0!==c){const r=c({args:o,stores:a});if(!1!==r)return S(r,o,a,e.EPostActionContext.SHORT_CIRCUIT),s.results[t]=[!0,!0,r,!1,Date.now()],s.results[t]}if(!n&&f||(s.actions[t]=T(t,s,o,a,i,u,e.EPostActionContext.BECKON_RUN,d)),f)return I;s.actions[t](),s.results[t]=I}if(y){if(h){const e=[...h];return e[3]=!0,e}if(null!=C.previous){const e=[...C.previous];return e[3]=!0,e}}return I}const x=(s={},{initiate:n=!1,ssr:o=!0,postActionEnabled:c=!1,cacheBreakEnabled:i=!1,holdPrevious:u=!1,dormant:l=!1,key:h,cacheBreak:d}={})=>{const y=t.useRef(),C=t.useRef("."),S=l?".":p(s,h);let _=t.useRef(-1);-1===_.current&&(_.current=g++),l||(E.hasOwnProperty(S)?E[S][_.current]=!0:E[S]={[_.current]:!0});const b=f?t.useContext(L)._asyncCache:k;let R,m;if(f||r){const e=t.useContext(L);R=e.stores,m=e.customContext}else R=H.loaded?H.stores:A;if(!f){const e=()=>{if(E[S][_.current]&&!a(y.current,b.results[S])){const e=U({key:S,cache:b,initiate:n,ssr:o,args:s,stores:R,fromListener:!0,postActionEnabled:c,cacheBreakEnabled:i,holdingResult:void 0,customContext:m,holdPrevious:u});u&&!e[1]&&null!=y.current&&y.current[1]?(y.current=[...y.current],y.current[3]=!0):y.current=e,P((e=>e+1))}};l||(b.listeners.hasOwnProperty(S)||(b.listeners[S]={}),b.listeners[S][_.current]=e,E[S][_.current]=!0),t.useEffect((()=>(l||(b.listeners[S][_.current]=e,E[S][_.current]=!0),()=>{l||(delete b.listeners[S][_.current],E[S][_.current]=!1)})),[S])}const[O,P]=t.useState(0);return l?(y.current=u&&y.current&&y.current[1]?y.current:[!1,!1,{message:"",tags:[e.EAsyncEndTags.DORMANT],error:!0,payload:null},!1,-1],C.current="."):C.current!==S&&(null!==C.current&&E.hasOwnProperty(C.current)&&(delete b.listeners[C.current][_.current],E[C.current][_.current]=!1),C.current=S,y.current=U({key:S,cache:b,initiate:n,ssr:o,args:s,stores:R,fromListener:!1,postActionEnabled:c,cacheBreakEnabled:i,holdingResult:u&&y.current&&y.current[1]?y.current:void 0,customContext:m,customCacheBreak:B(d),holdPrevious:u})),y.current},N=async(t={},s={})=>{const{treatAsUpdate:r=!1,ignoreShortCircuit:n=!1,respectCache:o=!1,key:a,_asyncCache:i=k,_stores:u=(H.loaded?H.stores:A),_customContext:l,cacheBreak:h}=s,d=p(t,a);if(o){const s=_({key:d,cache:i,args:t,stores:u,context:e.EPostActionContext.RUN_HIT_CACHE,postActionEnabled:!0,cacheBreakEnabled:!0,fromListener:!1,customCacheBreak:B(h)});if(s.response&&s.response[0]){if(!s.response[1]){const e=g++;return i.listeners.hasOwnProperty(d)||(i.listeners[d]={}),new Promise((t=>{i.listeners[d][e]=()=>{const[,s,r]=i.results[d];s&&(delete i.listeners[d][e],t(r))}}))}return s.response[2]}}if(!n&&void 0!==c){const s=c({args:t,stores:u});if(!1!==s)return i.results[d]=[!0,!0,s,!1,Date.now()],S(s,t,u,e.EPostActionContext.SHORT_CIRCUIT),m(d),s}const[,f,y,C,E]=i.results[d]||[!1,!1,{error:!0,message:"",payload:null,tags:[e.EAsyncEndTags.UNFINISHED]},!1,-1];i.results[d]=f&&r?[!0,!0,y,!0,E]:[!0,!1,{error:!0,message:"",payload:null,tags:[e.EAsyncEndTags.UNFINISHED]},!1,-1];let b=P(i,d);return i.actions[d]=T(d,i,t,u,b,!0,e.EPostActionContext.DIRECT_RUN,l),m(d),i.actions[d]()},D=(e={},{key:t,notify:s=!0}={})=>{O(p(e,t),!0,s)},j=(e,s,r)=>{const{notify:n=!0,key:o}=r||{},a=p(e,o);(f?t.useContext(L)._asyncCache:k).results[a]=[!0,!0,s,!1,Date.now()],n&&m(a)},z=(e,t,s)=>j(e,v(t),s),W=(s,r,n)=>{const{notify:a=!0,resetTimeCached:c=!0,runPostActionHook:i=!1,key:u}=n||{},l=p(s,u),h=f?t.useContext(L)._asyncCache:k;if(h.results.hasOwnProperty(l)&&!h.results[l][2].error){const t=h.results[l][2].payload,n={payload:o.default(t,(e=>r(e,t))),error:!1,message:h.results[l][2].message,tags:h.results[l][2].tags};i&&S(n,s,H.loaded?H.stores:A,e.EPostActionContext.CACHE_UPDATE),h.results[l]=[!0,!0,n,h.results[l][3],c?Date.now():h.results[l][4]],a&&m(l)}},F=(s={},r)=>{var n;const{checkCacheBreak:o=!1,key:a,cacheBreak:c}=r||{},u=p(s,a);let l=!1;const h=k;if(h.results.hasOwnProperty(u)){const e=null!==(n=B(c))&&void 0!==n?n:i;if(o&&void 0!==e){const r=f?t.useContext(L).stores:H.loaded?H.stores:A;e({args:s,result:h.results[u][2],stores:r,timeCached:h.results[u][4]})&&(l=!0)}const[r,a,d,p,y]=h.results[u];return{started:r,finished:a,result:d,existed:!0,cacheBreakable:l,updating:p,timeCached:y}}return{started:!1,finished:!1,result:{message:"",tags:[e.EAsyncEndTags.UNFINISHED],error:!0,payload:null,errorPayload:null},updating:!1,existed:!1,cacheBreakable:l,timeCached:-1}};let M;const $=(e={},{initiate:s=!0,ssr:r=!0,postActionEnabled:o,cacheBreakEnabled:a,holdPrevious:c=!1,dormant:i=!1,key:u,onSuccess:l,cacheBreak:h}={})=>{null==o&&(o=s),null==a&&(a=s);const d=x(e,{initiate:s,ssr:r,postActionEnabled:o,cacheBreakEnabled:a,holdPrevious:c,dormant:i,key:u,cacheBreak:h}),[f,p,y,C]=d,g=p&&!y.error,E=p&&y.error;l&&t.useEffect((()=>{g&&!i&&l(y.payload,e)}),[g]);return{isStarted:f,isFinished:p,isUpdating:C,isSuccess:g,isFailure:E,isLoading:f&&(!p||C),endTags:y.tags,error:y.error,payload:y.payload,errorPayload:y.errorPayload,renderPayload:e=>y.error?n.default.Fragment:e(y.payload),message:y.message,raw:d,execute:t=>N(e,t),clearCached:()=>D(e),setCached:(t,s)=>{j(e,t,s)},setCachedPayload:(t,s)=>{z(e,t,s)},updateCached:(t,s)=>{W(e,t,s)}}};return{use:$,useDefer:(e={})=>{const[s,r]=t.useState((()=>({key:e.key?e.key:y,args:{}}))),n=$({},{...e,key:s.key,initiate:!1}),o=(t={},s={})=>{var r,n;const o=null!==(r=e.key)&&void 0!==r?r:p(t),{checkCacheBreak:a=!0,successOnly:c=!1}=s,i=F(t,{key:o,cacheBreak:null!==(n=s.cacheBreak)&&void 0!==n?n:e.cacheBreak,checkCacheBreak:a});return!(!i.existed||a&&i.cacheBreakable)&&(!c||!i.result.error)},c=()=>{r({key:y,args:{}})},i=(t={},n)=>{var o;const a=null!==(o=e.key)&&void 0!==o?o:p(t);return a!==s.key&&r({key:a,args:t}),N(t,{...n,key:a,cacheBreak:e.cacheBreak}).then((t=>(e.clearOnSuccess&&D({},{key:a}),t)))};return{...n,clearCached:()=>{D({},{key:s.key})},unwatchExecuted:c,setCached:(e,t={})=>{t.key=s.key,j({},e,t)},setCachedPayload:(e,t={})=>{t.key=s.key,z({},e,t)},updateCached:(e,t={})=>{t.key=s.key,W({},e,t)},useDebouncedExecution:(e,s,r={})=>{if(!f){const n=t.useRef({update:!1}),u=t.useRef(void 0),l=t.useRef(-1),h=t.useRef(void 0);t.useEffect((()=>(n.current.update=!0,()=>{n.current.update=!1})),[]);null!=r.equality?"function"==typeof r.equality?(void 0===u.current||r.equality(u.current,e))&&(u.current=e,l.current+=1):u.current!==r.equality&&(u.current=r.equality,l.current+=1):a(u.current,e)||(u.current=e,l.current+=1),t.useEffect((()=>{var t,a,u;clearTimeout(h.current);const l=()=>{var t;n.current.update&&i(e,null!==(t=r.executeOptions)&&void 0!==t?t:{respectCache:!0})};null===(a=null===(t=r.validInput)||void 0===t?void 0:t.call(r,e))||void 0===a||a?o(e)?l():h.current=setTimeout(l,s):null!==(u=r.watchLastValid)&&void 0!==u&&u||c()}),[l.current])}},hasCached:o,execute:i,args:s.args,key:s.key}},read:(s={},{cacheBreakEnabled:n=!0,postActionEnabled:o=!0,key:a}={})=>{const i=p(s,a),u=f?t.useContext(L)._asyncCache:k;let l,h;if(f||r){const e=t.useContext(L);l=e.stores,h=e.customContext}else l=H.loaded?H.stores:A;const d=_({key:i,cache:u,args:s,stores:l,context:e.EPostActionContext.READ_HIT_CACHE,postActionEnabled:o,cacheBreakEnabled:n,fromListener:!1});if(d.response){if(d.response[2].error)throw new w(d.response[2].message,d.response[2].tags);return d.response[2].payload}if(!u.actions.hasOwnProperty(i)){if(void 0!==c){const t=c({args:s,stores:l});if(!1!==t){if(S(t,s,l,e.EPostActionContext.SHORT_CIRCUIT),u.results[i]=[!0,!0,t,!1,Date.now()],t.error)throw new w(t.message,t.tags);return t.payload}}const t=P(u,i);if(u.actions[i]=T(i,u,s,l,t,o,e.EPostActionContext.READ_RUN,h),f)throw new Error("Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )");throw u.actions[i]()}if(f)throw new Error("Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )");const y=g++;throw new Promise((e=>{u.listeners[i][y]=()=>{delete u.listeners[i][y],e()}}))},useBeckon:(e={},{ssr:t=!0,postActionEnabled:s=!0,cacheBreakEnabled:r=!0,holdPrevious:n=!1,dormant:o=!1,key:a}={})=>{const c=x(e,{initiate:!0,ssr:t,postActionEnabled:s,cacheBreakEnabled:r,holdPrevious:n,dormant:o,key:a});return[c[1],c[2],c[3]]},useWatch:x,run:N,delayedRun:(e={},{clearOldRun:t=!0,delay:s,immediateIfCached:r=!0,...n})=>{if(t&&clearTimeout(M),r){const{finished:t,cacheBreakable:s}=F(e,{checkCacheBreak:!0});if(t&&!s)return N(e,n),()=>{}}let o={cancelled:!1};return M=setTimeout((()=>{o.cancelled||N(e,n)}),s),()=>{o.cancelled=!0}},clearCache:D,clearAllCache:({notify:e=!0}={})=>{for(const t of Object.keys(k.actionOrd))t.startsWith(d+"-")&&O(t,!0,e)},clearAllUnwatchedCache:({notify:e=!0}={})=>{for(const t of Object.keys(E))Object.values(E[t]).some((e=>e))||(delete E[t],O(t,!1,e))},getCached:F,setCached:j,setCachedPayload:z,updateCached:W}}const L=n.default.createContext(null);let x=null;const H={internalClientStores:!0,loaded:!1,stores:{}};class N{constructor(e,t={}){this.options={},null!==x&&console.error("Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object."),x=this,H.stores=e,H.loaded=!0,this.options=t}instantiate({hydrateSnapshot:e,ssr:t=!1,customContext:s}={}){if(!t){const t=new D(H.stores,!1,s);return null!=e&&t.hydrateFromSnapshot(e),t.instantiateReactions(),t}const r={};for(const s of Object.keys(H.stores))null==e?r[s]=new y(H.stores[s]._getInitialState()):e.hasOwnProperty(s)?r[s]=new y(e.allState[s]):(r[s]=new y(H.stores[s]._getInitialState()),console.warn(`Pullstate (instantiate): store [${s}] didn't hydrate any state (data was non-existent on hydration object)`)),r[s]._setInternalOptions({ssr:t,reactionCreators:H.stores[s]._getReactionCreators()});return new D(r,!0,s)}useStores(){return j()}useInstance(){return z()}createAsyncActionDirect(e,t={}){return T(e,t)}createAsyncAction(e,t={}){var s;return(null===(s=this.options.asyncActions)||void 0===s?void 0:s.defaultCachingSeconds)&&!t.cacheBreakHook&&(t.cacheBreakHook=e=>e.timeCached<Date.now()-1e3*this.options.asyncActions.defaultCachingSeconds),U(e,t)}}class D{constructor(e,t,s){this._ssr=!1,this._stores={},this._asyncCache={listeners:{},results:{},actions:{},actionOrd:{}},this._stores=e,this._ssr=t,this._customContext=s}getAllUnresolvedAsyncActions(){return Object.keys(this._asyncCache.actions).map((e=>this._asyncCache.actions[e]()))}instantiateReactions(){for(const e of Object.keys(this._stores))this._stores[e]._instantiateReactions()}getPullstateSnapshot(){const e={};for(const t of Object.keys(this._stores))e[t]=this._stores[t].getRawState();return{allState:e,asyncResults:this._asyncCache.results,asyncActionOrd:this._asyncCache.actionOrd}}async resolveAsyncState(){const e=this.getAllUnresolvedAsyncActions();await Promise.all(e)}hasAsyncStateToResolve(){return Object.keys(this._asyncCache.actions).length>0}get stores(){return this._stores}get customContext(){return this._customContext}async runAsyncAction(e,t={},s={}){return this._ssr&&(s._asyncCache=this._asyncCache,s._stores=this._stores,s._customContext=this._customContext),await e.run(t,s)}hydrateFromSnapshot(e){for(const t of Object.keys(this._stores))e.allState.hasOwnProperty(t)?this._stores[t]._updateStateWithoutReaction(e.allState[t]):console.warn(t+" didn't hydrate any state (data was non-existent on hydration object)");k.results=e.asyncResults||{},k.actionOrd=e.asyncActionOrd||{}}}function j(){return t.useContext(L).stores}function z(){return t.useContext(L)}var W;(W=e.EAsyncActionInjectType||(e.EAsyncActionInjectType={})).WATCH="watch",W.BECKON="beckon";const F={};e.InjectAsyncAction=function(t){if(t.type===e.EAsyncActionInjectType.BECKON){const e=t.action.useBeckon(t.args,t.options);return t.children(e)}const s=t.action.useWatch(t.args,t.options);return t.children(s)},e.InjectStoreState=function({store:e,on:t=(e=>e),children:s}){return s(c(e,t))},e.InjectStoreStateOpt=function({store:e,paths:t,children:s}){return s(h(e,t))},e.PullstateContext=L,e.PullstateProvider=({instance:e,children:t})=>n.default.createElement(L.Provider,{value:e},t),e.Store=y,e.batch=function(e){if(f.batching)throw new Error("Pullstate: Can't enact two batch() update functions at the same time-\nmake sure you are not running a batch() inside of a batch() by mistake.");f.batching=!0;try{e()}finally{F.uiBatchFunction?F.uiBatchFunction((()=>{Object.values(f.flushStores).forEach((e=>e.flushBatch(!0)))})):Object.values(f.flushStores).forEach((e=>e.flushBatch(!0))),f.flushStores={},f.batching=!1}},e.createAsyncAction=U,e.createAsyncActionDirect=T,e.createPullstateCore=function(e={},t={}){return new N(e,t)},e.errorResult=function(t=[],s="",r){return{payload:null,tags:[e.EAsyncEndTags.RETURNED_ERROR,...t],message:s,error:!0,errorPayload:r}},e.registerInDevtools=function(e,{namespace:t=""}={}){var s;const r="undefined"!=typeof window?null===(s=window)||void 0===s?void 0:s.__REDUX_DEVTOOLS_EXTENSION__:void 0;if(r)for(const s of Object.keys(e)){const n=e[s],o=r.connect({name:`${t}${s}`});o.init(n.getRawState());let a=!1;n.subscribe((e=>e),(e=>{a?a=!1:o.send("Change",e)})),o.subscribe((e=>{if("DISPATCH"===e.type&&e.state){a=!0;const t=JSON.parse(e.state);n.replace(t)}}))}},e.setupBatch=function({uiBatchFunction:e}){F.uiBatchFunction=e},e.successResult=v,e.update=E,e.useInstance=z,e.useLocalStore=d,e.useStoreState=c,e.useStoreStateOpt=h,e.useStores=j,Object.defineProperty(e,"__esModule",{value:!0})}));
