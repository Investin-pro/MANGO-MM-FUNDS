{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarketProxyBuilder = exports.MarketProxyInstruction = exports.MarketProxy = void 0;\n\nconst anchor_1 = require(\"@project-serum/anchor\");\n\nconst market_1 = require(\"../market\");\n\nconst instructions_1 = require(\"../instructions\"); // MarketProxy provides an API for constructing transactions to an on-chain\n// DEX proxy, which relays all instructions to the orderbook. Minimally, this\n// requires two modifications for DEX instructions.\n//\n// 1. Transasctions are sent to the proxy program--not the DEX.\n// 2. The DEX program ID must be inserted as the first account in instructions\n//    using the proxy relay, so that the proxy can use the account for CPI.\n//    The program is responsible for removing this account before relaying to\n//    the dex.\n//\n// Additionally, a middleware abstraction is provided so that one can configure\n// both the client and the smart contract with the ability to send and processs\n// arbitrary accounts and instruction data *in addition* to what the Serum DEX\n// expects.\n//\n// Similar to the layers of an onion, each middleware wraps a transaction\n// request with additional accounts and instruction data before sending it to\n// the program. Upon receiving the request, the program--with its own set of\n// middleware-- unwraps and processes each layer. The process ends with all\n// layers being unwrapped and the proxy relaying the transaction to the DEX.\n//\n// As a result, the order of the middleware matters and the client should\n// process middleware in the *reverse* order of the proxy smart contract.\n\n\nclass MarketProxy {\n  // Ctor.\n  constructor(market, instruction) {\n    this._market = market;\n    this._instruction = instruction;\n  } // DEX market being proxied.\n\n\n  get market() {\n    return this._market;\n  } // Instruction namespace.\n\n\n  get instruction() {\n    return this._instruction;\n  } // Serum DEX program ID.\n\n\n  get dexProgramId() {\n    return this._market.programId;\n  } // Proxy program ID.\n\n\n  get proxyProgramId() {\n    return this._instruction.proxyProgramId;\n  }\n\n}\n\nexports.MarketProxy = MarketProxy; // Instruction builder for the market proxy.\n\nclass MarketProxyInstruction {\n  constructor(proxyProgramId, dexProgramId, market, middlewares) {\n    this._proxyProgramId = proxyProgramId;\n    this._dexProgramId = dexProgramId;\n    this._market = market;\n    this._middlewares = middlewares;\n  } // Program ID of the permissioning proxy program.\n\n\n  get proxyProgramId() {\n    return this._proxyProgramId;\n  }\n\n  newOrderV3(params) {\n    const tradeIx = this._market.makeNewOrderV3Instruction({ ...params,\n      programId: this._proxyProgramId\n    });\n\n    this._middlewares.forEach(mw => mw.newOrderV3(tradeIx));\n\n    return this.proxy(tradeIx);\n  }\n\n  initOpenOrders(owner, market, openOrders, marketAuthority) {\n    const ix = instructions_1.DexInstructions.initOpenOrders({\n      market,\n      openOrders,\n      owner,\n      programId: this._proxyProgramId,\n      marketAuthority\n    });\n\n    this._middlewares.forEach(mw => mw.initOpenOrders(ix));\n\n    return this.proxy(ix);\n  }\n\n  cancelOrder(owner, order) {\n    const ix = instructions_1.DexInstructions.cancelOrderV2({\n      market: this._market.address,\n      owner,\n      openOrders: order.openOrdersAddress,\n      bids: this._market.decoded.bids,\n      asks: this._market.decoded.asks,\n      eventQueue: this._market.decoded.eventQueue,\n      side: order.side,\n      orderId: order.orderId,\n      openOrdersSlot: order.openOrdersSlot,\n      programId: this._proxyProgramId\n    });\n\n    this._middlewares.forEach(mw => mw.cancelOrderV2(ix));\n\n    return this.proxy(ix);\n  }\n\n  cancelOrderByClientId(owner, openOrders, clientId) {\n    const ix = instructions_1.DexInstructions.cancelOrderByClientIdV2({\n      market: this._market.address,\n      openOrders,\n      owner,\n      bids: this._market.decoded.bids,\n      asks: this._market.decoded.asks,\n      eventQueue: this._market.decoded.eventQueue,\n      clientId,\n      programId: this._proxyProgramId\n    });\n\n    this._middlewares.forEach(mw => mw.cancelOrderByClientIdV2(ix));\n\n    return this.proxy(ix);\n  }\n\n  settleFunds(openOrders, owner, baseWallet, quoteWallet, referrerQuoteWallet) {\n    const ix = instructions_1.DexInstructions.settleFunds({\n      market: this._market.address,\n      openOrders,\n      owner,\n      baseVault: this._market.decoded.baseVault,\n      quoteVault: this._market.decoded.quoteVault,\n      baseWallet,\n      quoteWallet,\n      vaultSigner: anchor_1.utils.publicKey.createProgramAddressSync([this._market.address.toBuffer(), this._market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], this._dexProgramId),\n      programId: this._proxyProgramId,\n      referrerQuoteWallet\n    });\n\n    this._middlewares.forEach(mw => mw.settleFunds(ix));\n\n    return this.proxy(ix);\n  }\n\n  closeOpenOrders(openOrders, owner, solWallet) {\n    const ix = instructions_1.DexInstructions.closeOpenOrders({\n      market: this._market.address,\n      openOrders,\n      owner,\n      solWallet,\n      programId: this._proxyProgramId\n    });\n\n    this._middlewares.forEach(mw => mw.closeOpenOrders(ix));\n\n    return this.proxy(ix);\n  }\n\n  prune(openOrders, openOrdersOwner, limit) {\n    if (!limit) {\n      limit = 65535;\n    }\n\n    const ix = instructions_1.DexInstructions.prune({\n      market: this._market.address,\n      bids: this._market.decoded.bids,\n      asks: this._market.decoded.asks,\n      eventQueue: this._market.decoded.eventQueue,\n      pruneAuthority: this._market.decoded.pruneAuthority,\n      openOrders,\n      openOrdersOwner,\n      programId: this._proxyProgramId,\n      limit\n    });\n\n    this._middlewares.forEach(mw => mw.prune(ix));\n\n    return this.proxy(ix);\n  }\n\n  consumeEvents(openOrdersAccounts, limit) {\n    const ix = instructions_1.DexInstructions.consumeEvents({\n      market: this._market.address,\n      eventQueue: this._market.decoded.eventQueue,\n      coinFee: this._market.decoded.eventQueue,\n      pcFee: this._market.decoded.eventQueue,\n      openOrdersAccounts,\n      limit,\n      programId: this._proxyProgramId\n    });\n\n    this._middlewares.forEach(mw => mw.consumeEvents(ix));\n\n    return this.proxy(ix);\n  }\n\n  consumeEventsPermissioned(openOrdersAccounts, limit) {\n    const ix = instructions_1.DexInstructions.consumeEventsPermissioned({\n      market: this._market.address,\n      eventQueue: this._market.decoded.eventQueue,\n      crankAuthority: this._market.decoded.consumeEventsAuthority,\n      openOrdersAccounts,\n      limit,\n      programId: this._proxyProgramId\n    });\n\n    this._middlewares.forEach(mw => mw.consumeEventsPermissioned(ix));\n\n    return this.proxy(ix);\n  } // Adds the serum dex account to the instruction so that proxies can\n  // relay (CPI requires the executable account).\n\n\n  proxy(ix) {\n    ix.keys = [{\n      pubkey: this._dexProgramId,\n      isWritable: false,\n      isSigner: false\n    }, ...ix.keys];\n    return ix;\n  }\n\n}\n\nexports.MarketProxyInstruction = MarketProxyInstruction;\n\nclass MarketProxyBuilder {\n  constructor() {\n    this._middlewares = [];\n  }\n\n  middleware(mw) {\n    this._middlewares.push(mw);\n\n    return this;\n  }\n\n  async load(_ref) {\n    let {\n      connection,\n      market,\n      options = {},\n      dexProgramId,\n      proxyProgramId\n    } = _ref;\n    const marketClient = await market_1.Market.load(connection, market, options, dexProgramId, market_1.MARKET_STATE_LAYOUT_V3);\n    const instruction = new MarketProxyInstruction(proxyProgramId, dexProgramId, marketClient, this._middlewares);\n    return new MarketProxy(marketClient, instruction);\n  }\n\n}\n\nexports.MarketProxyBuilder = MarketProxyBuilder;","map":{"version":3,"sources":["../../src/market-proxy/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarketProxyBuilder = exports.MarketProxyInstruction = exports.MarketProxy = void 0;\nconst anchor_1 = require(\"@project-serum/anchor\");\nconst market_1 = require(\"../market\");\nconst instructions_1 = require(\"../instructions\");\n// MarketProxy provides an API for constructing transactions to an on-chain\n// DEX proxy, which relays all instructions to the orderbook. Minimally, this\n// requires two modifications for DEX instructions.\n//\n// 1. Transasctions are sent to the proxy program--not the DEX.\n// 2. The DEX program ID must be inserted as the first account in instructions\n//    using the proxy relay, so that the proxy can use the account for CPI.\n//    The program is responsible for removing this account before relaying to\n//    the dex.\n//\n// Additionally, a middleware abstraction is provided so that one can configure\n// both the client and the smart contract with the ability to send and processs\n// arbitrary accounts and instruction data *in addition* to what the Serum DEX\n// expects.\n//\n// Similar to the layers of an onion, each middleware wraps a transaction\n// request with additional accounts and instruction data before sending it to\n// the program. Upon receiving the request, the program--with its own set of\n// middleware-- unwraps and processes each layer. The process ends with all\n// layers being unwrapped and the proxy relaying the transaction to the DEX.\n//\n// As a result, the order of the middleware matters and the client should\n// process middleware in the *reverse* order of the proxy smart contract.\nclass MarketProxy {\n    // Ctor.\n    constructor(market, instruction) {\n        this._market = market;\n        this._instruction = instruction;\n    }\n    // DEX market being proxied.\n    get market() {\n        return this._market;\n    }\n    // Instruction namespace.\n    get instruction() {\n        return this._instruction;\n    }\n    // Serum DEX program ID.\n    get dexProgramId() {\n        return this._market.programId;\n    }\n    // Proxy program ID.\n    get proxyProgramId() {\n        return this._instruction.proxyProgramId;\n    }\n}\nexports.MarketProxy = MarketProxy;\n// Instruction builder for the market proxy.\nclass MarketProxyInstruction {\n    constructor(proxyProgramId, dexProgramId, market, middlewares) {\n        this._proxyProgramId = proxyProgramId;\n        this._dexProgramId = dexProgramId;\n        this._market = market;\n        this._middlewares = middlewares;\n    }\n    // Program ID of the permissioning proxy program.\n    get proxyProgramId() {\n        return this._proxyProgramId;\n    }\n    newOrderV3(params) {\n        const tradeIx = this._market.makeNewOrderV3Instruction({\n            ...params,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.newOrderV3(tradeIx));\n        return this.proxy(tradeIx);\n    }\n    initOpenOrders(owner, market, openOrders, marketAuthority) {\n        const ix = instructions_1.DexInstructions.initOpenOrders({\n            market,\n            openOrders,\n            owner,\n            programId: this._proxyProgramId,\n            marketAuthority,\n        });\n        this._middlewares.forEach((mw) => mw.initOpenOrders(ix));\n        return this.proxy(ix);\n    }\n    cancelOrder(owner, order) {\n        const ix = instructions_1.DexInstructions.cancelOrderV2({\n            market: this._market.address,\n            owner,\n            openOrders: order.openOrdersAddress,\n            bids: this._market.decoded.bids,\n            asks: this._market.decoded.asks,\n            eventQueue: this._market.decoded.eventQueue,\n            side: order.side,\n            orderId: order.orderId,\n            openOrdersSlot: order.openOrdersSlot,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.cancelOrderV2(ix));\n        return this.proxy(ix);\n    }\n    cancelOrderByClientId(owner, openOrders, clientId) {\n        const ix = instructions_1.DexInstructions.cancelOrderByClientIdV2({\n            market: this._market.address,\n            openOrders,\n            owner,\n            bids: this._market.decoded.bids,\n            asks: this._market.decoded.asks,\n            eventQueue: this._market.decoded.eventQueue,\n            clientId,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.cancelOrderByClientIdV2(ix));\n        return this.proxy(ix);\n    }\n    settleFunds(openOrders, owner, baseWallet, quoteWallet, referrerQuoteWallet) {\n        const ix = instructions_1.DexInstructions.settleFunds({\n            market: this._market.address,\n            openOrders,\n            owner,\n            baseVault: this._market.decoded.baseVault,\n            quoteVault: this._market.decoded.quoteVault,\n            baseWallet,\n            quoteWallet,\n            vaultSigner: anchor_1.utils.publicKey.createProgramAddressSync([\n                this._market.address.toBuffer(),\n                this._market.decoded.vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], this._dexProgramId),\n            programId: this._proxyProgramId,\n            referrerQuoteWallet,\n        });\n        this._middlewares.forEach((mw) => mw.settleFunds(ix));\n        return this.proxy(ix);\n    }\n    closeOpenOrders(openOrders, owner, solWallet) {\n        const ix = instructions_1.DexInstructions.closeOpenOrders({\n            market: this._market.address,\n            openOrders,\n            owner,\n            solWallet,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.closeOpenOrders(ix));\n        return this.proxy(ix);\n    }\n    prune(openOrders, openOrdersOwner, limit) {\n        if (!limit) {\n            limit = 65535;\n        }\n        const ix = instructions_1.DexInstructions.prune({\n            market: this._market.address,\n            bids: this._market.decoded.bids,\n            asks: this._market.decoded.asks,\n            eventQueue: this._market.decoded.eventQueue,\n            pruneAuthority: this._market.decoded.pruneAuthority,\n            openOrders,\n            openOrdersOwner,\n            programId: this._proxyProgramId,\n            limit,\n        });\n        this._middlewares.forEach((mw) => mw.prune(ix));\n        return this.proxy(ix);\n    }\n    consumeEvents(openOrdersAccounts, limit) {\n        const ix = instructions_1.DexInstructions.consumeEvents({\n            market: this._market.address,\n            eventQueue: this._market.decoded.eventQueue,\n            coinFee: this._market.decoded.eventQueue,\n            pcFee: this._market.decoded.eventQueue,\n            openOrdersAccounts,\n            limit,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.consumeEvents(ix));\n        return this.proxy(ix);\n    }\n    consumeEventsPermissioned(openOrdersAccounts, limit) {\n        const ix = instructions_1.DexInstructions.consumeEventsPermissioned({\n            market: this._market.address,\n            eventQueue: this._market.decoded.eventQueue,\n            crankAuthority: this._market.decoded.consumeEventsAuthority,\n            openOrdersAccounts,\n            limit,\n            programId: this._proxyProgramId,\n        });\n        this._middlewares.forEach((mw) => mw.consumeEventsPermissioned(ix));\n        return this.proxy(ix);\n    }\n    // Adds the serum dex account to the instruction so that proxies can\n    // relay (CPI requires the executable account).\n    proxy(ix) {\n        ix.keys = [\n            { pubkey: this._dexProgramId, isWritable: false, isSigner: false },\n            ...ix.keys,\n        ];\n        return ix;\n    }\n}\nexports.MarketProxyInstruction = MarketProxyInstruction;\nclass MarketProxyBuilder {\n    constructor() {\n        this._middlewares = [];\n    }\n    middleware(mw) {\n        this._middlewares.push(mw);\n        return this;\n    }\n    async load({ connection, market, options = {}, dexProgramId, proxyProgramId, }) {\n        const marketClient = await market_1.Market.load(connection, market, options, dexProgramId, market_1.MARKET_STATE_LAYOUT_V3);\n        const instruction = new MarketProxyInstruction(proxyProgramId, dexProgramId, marketClient, this._middlewares);\n        return new MarketProxy(marketClient, instruction);\n    }\n}\nexports.MarketProxyBuilder = MarketProxyBuilder;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}