{"ast":null,"code":"import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountDiscriminator, accountSize } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nexport default class AccountFactory {\n  static build(idl, coder, programId, provider) {\n    const accountFns = {};\n    idl.accounts.forEach(idlAccount => {\n      const name = camelCase(idlAccount.name);\n      accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n    });\n    return accountFns;\n  }\n\n}\nexport class AccountClient {\n  constructor(idl, idlAccount, programId, provider, coder) {\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._size = ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n  }\n  /**\n   * Returns the number of bytes in this account.\n   */\n\n\n  get size() {\n    return this._size;\n  }\n  /**\n   * Returns the program ID owning all accounts.\n   */\n\n\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the client's wallet and network provider.\n   */\n\n\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Returns the coder.\n   */\n\n\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Returns a deserialized account.\n   *\n   * @param address The address of the account to fetch.\n   */\n\n\n  async fetch(address) {\n    const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n\n    if (accountInfo === null) {\n      throw new Error(`Account does not exist ${address.toString()}`);\n    } // Assert the account discriminator is correct.\n\n\n    const discriminator = await accountDiscriminator(this._idlAccount.name);\n\n    if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n\n    return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n  }\n  /**\n   * Returns all instances of this account type for the program.\n   */\n\n\n  async all(filter) {\n    let bytes = await accountDiscriminator(this._idlAccount.name);\n\n    if (filter !== undefined) {\n      bytes = Buffer.concat([bytes, filter]);\n    }\n\n    let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n      commitment: this._provider.connection.commitment,\n      filters: [{\n        memcmp: {\n          offset: 0,\n          bytes: bs58.encode(bytes)\n        }\n      }]\n    });\n    return resp.map(_ref => {\n      let {\n        pubkey,\n        account\n      } = _ref;\n      return {\n        publicKey: pubkey,\n        account: this._coder.accounts.decode(this._idlAccount.name, account.data)\n      };\n    });\n  }\n  /**\n   * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n   * changes.\n   */\n\n\n  subscribe(address, commitment) {\n    if (subscriptions.get(address.toString())) {\n      return subscriptions.get(address.toString()).ee;\n    }\n\n    const ee = new EventEmitter();\n    address = translateAddress(address);\n\n    const listener = this._provider.connection.onAccountChange(address, acc => {\n      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n\n      ee.emit(\"change\", account);\n    }, commitment);\n\n    subscriptions.set(address.toString(), {\n      ee,\n      listener\n    });\n    return ee;\n  }\n  /**\n   * Unsubscribes from the account at the given address.\n   */\n\n\n  unsubscribe(address) {\n    let sub = subscriptions.get(address.toString());\n\n    if (!sub) {\n      console.warn(\"Address is not subscribed\");\n      return;\n    }\n\n    if (subscriptions) {\n      this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {\n        subscriptions.delete(address.toString());\n      }).catch(console.error);\n    }\n  }\n  /**\n   * Returns an instruction for creating this account.\n   */\n\n\n  async createInstruction(signer, sizeOverride) {\n    const size = this.size;\n    return SystemProgram.createAccount({\n      fromPubkey: this._provider.wallet.publicKey,\n      newAccountPubkey: signer.publicKey,\n      space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n      programId: this._programId\n    });\n  }\n  /**\n   * Function returning the associated account. Args are keys to associate.\n   * Order matters.\n   */\n\n\n  async associated() {\n    const addr = await this.associatedAddress(...arguments);\n    return await this.fetch(addr);\n  }\n  /**\n   * Function returning the associated address. Args are keys to associate.\n   * Order matters.\n   */\n\n\n  async associatedAddress() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return await pubkeyUtil.associated(this._programId, ...args);\n  }\n\n} // Tracks all subscriptions.\n\nconst subscriptions = new Map();","map":{"version":3,"sources":["../../../../src/program/namespace/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram, } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountDiscriminator, accountSize, } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nexport default class AccountFactory {\n    static build(idl, coder, programId, provider) {\n        const accountFns = {};\n        idl.accounts.forEach((idlAccount) => {\n            const name = camelCase(idlAccount.name);\n            accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n        });\n        return accountFns;\n    }\n}\nexport class AccountClient {\n    constructor(idl, idlAccount, programId, provider, coder) {\n        this._idlAccount = idlAccount;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n        this._size = ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n    }\n    /**\n     * Returns the number of bytes in this account.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetch(address) {\n        const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n        if (accountInfo === null) {\n            throw new Error(`Account does not exist ${address.toString()}`);\n        }\n        // Assert the account discriminator is correct.\n        const discriminator = await accountDiscriminator(this._idlAccount.name);\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n    }\n    /**\n     * Returns all instances of this account type for the program.\n     */\n    async all(filter) {\n        let bytes = await accountDiscriminator(this._idlAccount.name);\n        if (filter !== undefined) {\n            bytes = Buffer.concat([bytes, filter]);\n        }\n        let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n            commitment: this._provider.connection.commitment,\n            filters: [\n                {\n                    memcmp: {\n                        offset: 0,\n                        bytes: bs58.encode(bytes),\n                    },\n                },\n            ],\n        });\n        return resp.map(({ pubkey, account }) => {\n            return {\n                publicKey: pubkey,\n                account: this._coder.accounts.decode(this._idlAccount.name, account.data),\n            };\n        });\n    }\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n    subscribe(address, commitment) {\n        if (subscriptions.get(address.toString())) {\n            return subscriptions.get(address.toString()).ee;\n        }\n        const ee = new EventEmitter();\n        address = translateAddress(address);\n        const listener = this._provider.connection.onAccountChange(address, (acc) => {\n            const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n            ee,\n            listener,\n        });\n        return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n    unsubscribe(address) {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n            console.warn(\"Address is not subscribed\");\n            return;\n        }\n        if (subscriptions) {\n            this._provider.connection\n                .removeAccountChangeListener(sub.listener)\n                .then(() => {\n                subscriptions.delete(address.toString());\n            })\n                .catch(console.error);\n        }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */\n    async createInstruction(signer, sizeOverride) {\n        const size = this.size;\n        return SystemProgram.createAccount({\n            fromPubkey: this._provider.wallet.publicKey,\n            newAccountPubkey: signer.publicKey,\n            space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n            programId: this._programId,\n        });\n    }\n    /**\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n    async associated(...args) {\n        const addr = await this.associatedAddress(...args);\n        return await this.fetch(addr);\n    }\n    /**\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n    async associatedAddress(...args) {\n        return await pubkeyUtil.associated(this._programId, ...args);\n    }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map();\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"module"}