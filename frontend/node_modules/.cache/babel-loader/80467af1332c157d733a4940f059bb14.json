{"ast":null,"code":"import BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\"; // Sync version of web3.PublicKey.createWithSeed.\n\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n  const buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);\n  const hash = sha256Sync.digest(buffer);\n  return new PublicKey(Buffer.from(hash));\n} // Sync version of web3.PublicKey.createProgramAddress.\n\nexport function createProgramAddressSync(seeds, programId) {\n  const MAX_SEED_LENGTH = 32;\n  let buffer = Buffer.alloc(0);\n  seeds.forEach(function (seed) {\n    if (seed.length > MAX_SEED_LENGTH) {\n      throw new TypeError(`Max seed length exceeded`);\n    }\n\n    buffer = Buffer.concat([buffer, toBuffer(seed)]);\n  });\n  buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from(\"ProgramDerivedAddress\")]);\n  let hash = sha256Sync(new Uint8Array(buffer));\n  let publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n\n  if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n    throw new Error(`Invalid seeds, address must fall off the curve`);\n  }\n\n  return new PublicKey(publicKeyBytes);\n} // Sync version of web3.PublicKey.findProgramAddress.\n\nexport function findProgramAddressSync(seeds, programId) {\n  let nonce = 255;\n  let address;\n\n  while (nonce != 0) {\n    try {\n      const seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n      address = createProgramAddressSync(seedsWithNonce, programId);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw err;\n      }\n\n      nonce--;\n      continue;\n    }\n\n    return [address, nonce];\n  }\n\n  throw new Error(`Unable to find a viable program address nonce`);\n}\n\nconst toBuffer = arr => {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n\nexport async function associated(programId) {\n  let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(arg => {\n    seeds.push( // @ts-ignore\n    arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n  });\n  const [assoc] = await PublicKey.findProgramAddress(seeds, translateAddress(programId));\n  return assoc;\n}","map":{"version":3,"sources":["../../../src/utils/pubkey.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\n// Sync version of web3.PublicKey.createWithSeed.\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n    const buffer = Buffer.concat([\n        fromPublicKey.toBuffer(),\n        Buffer.from(seed),\n        programId.toBuffer(),\n    ]);\n    const hash = sha256Sync.digest(buffer);\n    return new PublicKey(Buffer.from(hash));\n}\n// Sync version of web3.PublicKey.createProgramAddress.\nexport function createProgramAddressSync(seeds, programId) {\n    const MAX_SEED_LENGTH = 32;\n    let buffer = Buffer.alloc(0);\n    seeds.forEach(function (seed) {\n        if (seed.length > MAX_SEED_LENGTH) {\n            throw new TypeError(`Max seed length exceeded`);\n        }\n        buffer = Buffer.concat([buffer, toBuffer(seed)]);\n    });\n    buffer = Buffer.concat([\n        buffer,\n        programId.toBuffer(),\n        Buffer.from(\"ProgramDerivedAddress\"),\n    ]);\n    let hash = sha256Sync(new Uint8Array(buffer));\n    let publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n    if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n        throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n}\n// Sync version of web3.PublicKey.findProgramAddress.\nexport function findProgramAddressSync(seeds, programId) {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n        try {\n            const seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n            address = createProgramAddressSync(seedsWithNonce, programId);\n        }\n        catch (err) {\n            if (err instanceof TypeError) {\n                throw err;\n            }\n            nonce--;\n            continue;\n        }\n        return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n}\nconst toBuffer = (arr) => {\n    if (arr instanceof Buffer) {\n        return arr;\n    }\n    else if (arr instanceof Uint8Array) {\n        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    }\n    else {\n        return Buffer.from(arr);\n    }\n};\nexport async function associated(programId, ...args) {\n    let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n    args.forEach((arg) => {\n        seeds.push(\n        // @ts-ignore\n        arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n    });\n    const [assoc] = await PublicKey.findProgramAddress(seeds, translateAddress(programId));\n    return assoc;\n}\n//# sourceMappingURL=pubkey.js.map"]},"metadata":{},"sourceType":"module"}