{"ast":null,"code":"import { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventParser } from \"./event\";\nimport { translateAddress } from \"./common\";\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\n\nexport class Program {\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  constructor(idl, programId, provider) {\n    programId = translateAddress(programId); // Fields.\n\n    this._idl = idl;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = new Coder(idl); // Dynamic namespaces.\n\n    const [rpc, instruction, transaction, account, simulate, state] = NamespaceFactory.build(idl, this._coder, programId, this._provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.state = state;\n  }\n  /**\n   * Address of the program.\n   */\n\n\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * IDL defining the program's interface.\n   */\n\n\n  get idl() {\n    return this._idl;\n  }\n  /**\n   * Coder for serializing requests.\n   */\n\n\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Wallet and network provider.\n   */\n\n\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n\n\n  static async at(address, provider) {\n    const programId = translateAddress(address);\n    const idl = await Program.fetchIdl(programId, provider);\n    return new Program(idl, programId, provider);\n  }\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n\n\n  static async fetchIdl(address, provider) {\n    provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    const programId = translateAddress(address);\n    const idlAddr = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(idlAddr); // Chop off account discriminator.\n\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(utf8.decode(inflatedIdl));\n  }\n  /**\n   * Invokes the given callback every time the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n\n\n  addEventListener(eventName, callback) {\n    const eventParser = new EventParser(this._coder, this._programId);\n    return this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n\n      eventParser.parseLogs(logs.logs, event => {\n        if (event.name === eventName) {\n          callback(event.data, ctx.slot);\n        }\n      });\n    });\n  }\n  /**\n   * Unsubscribes from the given event listener.\n   */\n\n\n  async removeEventListener(listener) {\n    return this._provider.connection.removeOnLogsListener(listener);\n  }\n\n}","map":{"version":3,"sources":["../../../src/program/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventParser } from \"./event\";\nimport { translateAddress } from \"./common\";\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\nexport class Program {\n    /**\n     * @param idl       The interface definition.\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context to use. If not provided\n     *                  then uses [[getProvider]].\n     */\n    constructor(idl, programId, provider) {\n        programId = translateAddress(programId);\n        // Fields.\n        this._idl = idl;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = new Coder(idl);\n        // Dynamic namespaces.\n        const [rpc, instruction, transaction, account, simulate, state] = NamespaceFactory.build(idl, this._coder, programId, this._provider);\n        this.rpc = rpc;\n        this.instruction = instruction;\n        this.transaction = transaction;\n        this.account = account;\n        this.simulate = simulate;\n        this.state = state;\n    }\n    /**\n     * Address of the program.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * IDL defining the program's interface.\n     */\n    get idl() {\n        return this._idl;\n    }\n    /**\n     * Coder for serializing requests.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Generates a Program client by fetching the IDL from the network.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n    static async at(address, provider) {\n        const programId = translateAddress(address);\n        const idl = await Program.fetchIdl(programId, provider);\n        return new Program(idl, programId, provider);\n    }\n    /**\n     * Fetches an idl from the blockchain.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n    static async fetchIdl(address, provider) {\n        provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        const programId = translateAddress(address);\n        const idlAddr = await idlAddress(programId);\n        const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n        // Chop off account discriminator.\n        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n        const inflatedIdl = inflate(idlAccount.data);\n        return JSON.parse(utf8.decode(inflatedIdl));\n    }\n    /**\n     * Invokes the given callback every time the given event is emitted.\n     *\n     * @param eventName The PascalCase name of the event, provided by the IDL.\n     * @param callback  The function to invoke whenever the event is emitted from\n     *                  program logs.\n     */\n    addEventListener(eventName, callback) {\n        const eventParser = new EventParser(this._coder, this._programId);\n        return this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n            if (logs.err) {\n                console.error(logs);\n                return;\n            }\n            eventParser.parseLogs(logs.logs, (event) => {\n                if (event.name === eventName) {\n                    callback(event.data, ctx.slot);\n                }\n            });\n        });\n    }\n    /**\n     * Unsubscribes from the given event listener.\n     */\n    async removeEventListener(listener) {\n        return this._provider.connection.removeOnLogsListener(listener);\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}