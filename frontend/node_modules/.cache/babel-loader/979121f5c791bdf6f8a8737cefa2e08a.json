{"ast":null,"code":"import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(variant => {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n\n      return variant.fields // @ts-ignore\n      .map(f => {\n        // @ts-ignore\n        if (f.name === undefined) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        } // @ts-ignore\n\n\n        return typeSize(idl, f.type);\n      }).reduce((a, b) => a + b);\n    });\n    return Math.max(...variantSizes) + 1;\n  }\n\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n\n  return idlAccount.type.fields.map(f => typeSize(idl, f.type)).reduce((a, b) => a + b);\n} // Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\n\nfunction typeSize(idl, ty) {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n\n    case \"u8\":\n      return 1;\n\n    case \"i8\":\n      return 1;\n\n    case \"i16\":\n      return 2;\n\n    case \"u16\":\n      return 2;\n\n    case \"u32\":\n      return 4;\n\n    case \"i32\":\n      return 4;\n\n    case \"u64\":\n      return 8;\n\n    case \"i64\":\n      return 8;\n\n    case \"u128\":\n      return 16;\n\n    case \"i128\":\n      return 16;\n\n    case \"bytes\":\n      return 1;\n\n    case \"string\":\n      return 1;\n\n    case \"publicKey\":\n      return 32;\n\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      } // @ts-ignore\n\n\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      } // @ts-ignore\n\n\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        const filtered = idl.types.filter(t => t.name === ty.defined);\n\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n\n        let typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      } // @ts-ignore\n\n\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        let arrayTy = ty.array[0]; // @ts-ignore\n\n        let arraySize = ty.array[1]; // @ts-ignore\n\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n} // Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\n\n\nexport function sighash(nameSpace, ixName) {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"sources":["../../../src/coder/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n    if (idlAccount.type.kind === \"enum\") {\n        let variantSizes = idlAccount.type.variants.map((variant) => {\n            if (variant.fields === undefined) {\n                return 0;\n            }\n            return (variant.fields\n                // @ts-ignore\n                .map((f) => {\n                // @ts-ignore\n                if (f.name === undefined) {\n                    throw new Error(\"Tuple enum variants not yet implemented.\");\n                }\n                // @ts-ignore\n                return typeSize(idl, f.type);\n            })\n                .reduce((a, b) => a + b));\n        });\n        return Math.max(...variantSizes) + 1;\n    }\n    if (idlAccount.type.fields === undefined) {\n        return 0;\n    }\n    return idlAccount.type.fields\n        .map((f) => typeSize(idl, f.type))\n        .reduce((a, b) => a + b);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n    switch (ty) {\n        case \"bool\":\n            return 1;\n        case \"u8\":\n            return 1;\n        case \"i8\":\n            return 1;\n        case \"i16\":\n            return 2;\n        case \"u16\":\n            return 2;\n        case \"u32\":\n            return 4;\n        case \"i32\":\n            return 4;\n        case \"u64\":\n            return 8;\n        case \"i64\":\n            return 8;\n        case \"u128\":\n            return 16;\n        case \"i128\":\n            return 16;\n        case \"bytes\":\n            return 1;\n        case \"string\":\n            return 1;\n        case \"publicKey\":\n            return 32;\n        default:\n            // @ts-ignore\n            if (ty.vec !== undefined) {\n                return 1;\n            }\n            // @ts-ignore\n            if (ty.option !== undefined) {\n                // @ts-ignore\n                return 1 + typeSize(idl, ty.option);\n            }\n            // @ts-ignore\n            if (ty.defined !== undefined) {\n                // @ts-ignore\n                const filtered = idl.types.filter((t) => t.name === ty.defined);\n                if (filtered.length !== 1) {\n                    throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                }\n                let typeDef = filtered[0];\n                return accountSize(idl, typeDef);\n            }\n            // @ts-ignore\n            if (ty.array !== undefined) {\n                // @ts-ignore\n                let arrayTy = ty.array[0];\n                // @ts-ignore\n                let arraySize = ty.array[1];\n                // @ts-ignore\n                return typeSize(idl, arrayTy) * arraySize;\n            }\n            throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n    }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n    let name = snakeCase(ixName);\n    let preimage = `${nameSpace}:${name}`;\n    return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}