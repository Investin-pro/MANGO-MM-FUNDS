{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPriceFromKey = exports.BookSide = void 0;\n\nconst layout_1 = require(\"./layout\"); // TODO - maybe store ref inside PerpMarket class\n\n\nclass BookSide {\n  constructor(publicKey, perpMarket, decoded) {\n    this.publicKey = publicKey;\n    this.isBids = decoded.metaData.dataType === layout_1.DataType.Bids;\n    this.perpMarket = perpMarket;\n    Object.assign(this, decoded);\n  }\n\n  *items() {\n    if (this.leafCount === 0) {\n      return;\n    }\n\n    const stack = [this.rootNode];\n\n    while (stack.length > 0) {\n      const index = stack.pop(); // @ts-ignore\n\n      const {\n        leafNode,\n        innerNode\n      } = this.nodes[index]; // we know index is undefined\n\n      if (leafNode) {\n        const price = getPriceFromKey(leafNode.key);\n        yield {\n          orderId: leafNode.key,\n          clientId: leafNode.clientOrderId,\n          owner: leafNode.owner,\n          openOrdersSlot: leafNode.ownerSlot,\n          feeTier: 0,\n          price: this.perpMarket.priceLotsToNumber(price),\n          priceLots: price,\n          size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n          sizeLots: leafNode.quantity,\n          side: this.isBids ? 'buy' : 'sell',\n          bestInitial: leafNode.bestInitial,\n          timestamp: leafNode.timestamp\n        };\n      } else if (innerNode) {\n        if (this.isBids) {\n          stack.push(innerNode.children[0], innerNode.children[1]);\n        } else {\n          stack.push(innerNode.children[1], innerNode.children[0]);\n        }\n      }\n    }\n  }\n\n  getBest() {\n    if (this.leafCount === 0) {\n      return;\n    }\n\n    let currNodeIndex = this.rootNode;\n    const left = this.isBids ? 1 : 0;\n    const side = this.isBids ? 'buy' : 'sell';\n\n    while (currNodeIndex !== undefined) {\n      const {\n        leafNode,\n        innerNode\n      } = this.nodes[currNodeIndex]; // we know index is not undefined\n\n      if (leafNode) {\n        const price = getPriceFromKey(leafNode.key);\n        return {\n          orderId: leafNode.key,\n          clientId: leafNode.clientOrderId,\n          owner: leafNode.owner,\n          openOrdersSlot: leafNode.ownerSlot,\n          feeTier: 0,\n          price: this.perpMarket.priceLotsToNumber(price),\n          priceLots: price,\n          size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n          sizeLots: leafNode.quantity,\n          side,\n          bestInitial: leafNode.bestInitial,\n          timestamp: leafNode.timestamp\n        };\n      } else if (innerNode) {\n        currNodeIndex = innerNode.children[left];\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.items();\n  }\n\n  getL2(depth) {\n    const levels = []; // (price, size)\n    //@ts-ignore\n\n    for (const {\n      priceLots,\n      sizeLots\n    } of this.items()) {\n      if (levels.length > 0 && levels[levels.length - 1][0].eq(priceLots)) {\n        levels[levels.length - 1][1].iadd(sizeLots);\n      } else if (levels.length === depth) {\n        break;\n      } else {\n        levels.push([priceLots, sizeLots]);\n      }\n    }\n\n    return levels.map(_ref => {\n      let [priceLots, sizeLots] = _ref;\n      return [this.perpMarket.priceLotsToNumber(priceLots), this.perpMarket.baseLotsToNumber(sizeLots), priceLots, sizeLots];\n    });\n  }\n\n}\n\nexports.BookSide = BookSide;\n\nfunction getPriceFromKey(key) {\n  return key.ushrn(64); // TODO - maybe use shrn instead\n}\n\nexports.getPriceFromKey = getPriceFromKey;","map":{"version":3,"sources":["../../src/book.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPriceFromKey = exports.BookSide = void 0;\nconst layout_1 = require(\"./layout\");\n// TODO - maybe store ref inside PerpMarket class\nclass BookSide {\n    constructor(publicKey, perpMarket, decoded) {\n        this.publicKey = publicKey;\n        this.isBids = decoded.metaData.dataType === layout_1.DataType.Bids;\n        this.perpMarket = perpMarket;\n        Object.assign(this, decoded);\n    }\n    *items() {\n        if (this.leafCount === 0) {\n            return;\n        }\n        const stack = [this.rootNode];\n        while (stack.length > 0) {\n            const index = stack.pop();\n            // @ts-ignore\n            const { leafNode, innerNode } = this.nodes[index]; // we know index is undefined\n            if (leafNode) {\n                const price = getPriceFromKey(leafNode.key);\n                yield {\n                    orderId: leafNode.key,\n                    clientId: leafNode.clientOrderId,\n                    owner: leafNode.owner,\n                    openOrdersSlot: leafNode.ownerSlot,\n                    feeTier: 0,\n                    price: this.perpMarket.priceLotsToNumber(price),\n                    priceLots: price,\n                    size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n                    sizeLots: leafNode.quantity,\n                    side: (this.isBids ? 'buy' : 'sell'),\n                    bestInitial: leafNode.bestInitial,\n                    timestamp: leafNode.timestamp,\n                };\n            }\n            else if (innerNode) {\n                if (this.isBids) {\n                    stack.push(innerNode.children[0], innerNode.children[1]);\n                }\n                else {\n                    stack.push(innerNode.children[1], innerNode.children[0]);\n                }\n            }\n        }\n    }\n    getBest() {\n        if (this.leafCount === 0) {\n            return;\n        }\n        let currNodeIndex = this.rootNode;\n        const left = this.isBids ? 1 : 0;\n        const side = this.isBids ? 'buy' : 'sell';\n        while (currNodeIndex !== undefined) {\n            const { leafNode, innerNode } = this.nodes[currNodeIndex]; // we know index is not undefined\n            if (leafNode) {\n                const price = getPriceFromKey(leafNode.key);\n                return {\n                    orderId: leafNode.key,\n                    clientId: leafNode.clientOrderId,\n                    owner: leafNode.owner,\n                    openOrdersSlot: leafNode.ownerSlot,\n                    feeTier: 0,\n                    price: this.perpMarket.priceLotsToNumber(price),\n                    priceLots: price,\n                    size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n                    sizeLots: leafNode.quantity,\n                    side,\n                    bestInitial: leafNode.bestInitial,\n                    timestamp: leafNode.timestamp,\n                };\n            }\n            else if (innerNode) {\n                currNodeIndex = innerNode.children[left];\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.items();\n    }\n    getL2(depth) {\n        const levels = []; // (price, size)\n        //@ts-ignore\n        for (const { priceLots, sizeLots } of this.items()) {\n            if (levels.length > 0 && levels[levels.length - 1][0].eq(priceLots)) {\n                levels[levels.length - 1][1].iadd(sizeLots);\n            }\n            else if (levels.length === depth) {\n                break;\n            }\n            else {\n                levels.push([priceLots, sizeLots]);\n            }\n        }\n        return levels.map(([priceLots, sizeLots]) => [\n            this.perpMarket.priceLotsToNumber(priceLots),\n            this.perpMarket.baseLotsToNumber(sizeLots),\n            priceLots,\n            sizeLots,\n        ]);\n    }\n}\nexports.BookSide = BookSide;\nfunction getPriceFromKey(key) {\n    return key.ushrn(64); // TODO - maybe use shrn instead\n}\nexports.getPriceFromKey = getPriceFromKey;\n//# sourceMappingURL=book.js.map"]},"metadata":{},"sourceType":"script"}