{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPriceFromKey = exports.BookSide = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst layout_1 = require(\"./layout\");\n\nconst utils_1 = require(\"./utils/utils\");\n\nconst client_1 = require(\"./client\"); // TODO - maybe store ref inside PerpMarket class\n\n\nclass BookSide {\n  constructor(publicKey, perpMarket, decoded) {\n    let includeExpired = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.publicKey = publicKey;\n    this.isBids = decoded.metaData.dataType === layout_1.DataType.Bids;\n    this.perpMarket = perpMarket;\n    this.includeExpired = includeExpired;\n    Object.assign(this, decoded); // Determine the maxTimestamp found on the book to use for tif\n\n    let maxTimestamp = new bn_js_1.default(client_1.getUnixTs() - 10);\n\n    for (const {\n      leafNode\n    } of this.nodes) {\n      if (leafNode && leafNode.timestamp.gt(maxTimestamp)) {\n        maxTimestamp = leafNode.timestamp;\n      }\n    }\n\n    this.now = maxTimestamp;\n  }\n\n  *items() {\n    if (this.leafCount === 0) {\n      return;\n    }\n\n    const now = this.now;\n    const stack = [this.rootNode];\n    const [left, right] = this.isBids ? [1, 0] : [0, 1];\n    const side = this.isBids ? 'buy' : 'sell';\n\n    while (stack.length > 0) {\n      const index = stack.pop(); // @ts-ignore\n\n      const {\n        leafNode,\n        innerNode\n      } = this.nodes[index]; // we know index is not undefined\n\n      if (leafNode) {\n        const price = getPriceFromKey(leafNode.key);\n        const expiryTimestamp = leafNode.timeInForce ? leafNode.timestamp.add(new bn_js_1.default(leafNode.timeInForce)) : utils_1.U64_MAX_BN;\n\n        if (now.lt(expiryTimestamp) || this.includeExpired) {\n          yield {\n            orderId: leafNode.key,\n            clientId: leafNode.clientOrderId,\n            owner: leafNode.owner,\n            openOrdersSlot: leafNode.ownerSlot,\n            feeTier: 0,\n            price: this.perpMarket.priceLotsToNumber(price),\n            priceLots: price,\n            size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n            sizeLots: leafNode.quantity,\n            side,\n            bestInitial: leafNode.bestInitial,\n            timestamp: leafNode.timestamp,\n            expiryTimestamp\n          };\n        }\n      } else if (innerNode) {\n        stack.push(innerNode.children[right], innerNode.children[left]);\n      }\n    }\n  }\n  /**\n   * Return the ui price reached at `quantity` lots up the book;\n   * return undefined if `quantity` not on book\n   */\n\n\n  getImpactPriceUi(quantity) {\n    const s = utils_1.ZERO_BN.clone();\n\n    for (const order of this) {\n      s.iadd(order.sizeLots);\n\n      if (s.gte(quantity)) {\n        return order.price;\n      }\n    }\n\n    return undefined;\n  }\n\n  getBest() {\n    if (this.leafCount === 0) {\n      return;\n    }\n\n    const [left, right] = this.isBids ? [1, 0] : [0, 1];\n    const side = this.isBids ? 'buy' : 'sell';\n    const stack = [this.rootNode];\n    const now = this.now;\n\n    while (stack.length > 0) {\n      let index = stack.pop(); // @ts-ignore\n\n      const {\n        leafNode,\n        innerNode\n      } = this.nodes[index]; // we know index is not undefined\n\n      if (leafNode) {\n        const price = getPriceFromKey(leafNode.key);\n        const expiryTimestamp = leafNode.timeInForce ? leafNode.timestamp.add(new bn_js_1.default(leafNode.timeInForce)) : utils_1.U64_MAX_BN;\n\n        if (now.lt(expiryTimestamp) || this.includeExpired) {\n          return {\n            orderId: leafNode.key,\n            clientId: leafNode.clientOrderId,\n            owner: leafNode.owner,\n            openOrdersSlot: leafNode.ownerSlot,\n            feeTier: 0,\n            price: this.perpMarket.priceLotsToNumber(price),\n            priceLots: price,\n            size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n            sizeLots: leafNode.quantity,\n            side,\n            bestInitial: leafNode.bestInitial,\n            timestamp: leafNode.timestamp,\n            expiryTimestamp\n          };\n        }\n      } else if (innerNode) {\n        stack.push(innerNode.children[right], innerNode.children[left]);\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.items();\n  }\n\n  getL2Ui(depth) {\n    const levels = []; // (price, size)\n    //@ts-ignore\n\n    for (const {\n      price,\n      size\n    } of this.items()) {\n      if (levels.length > 0 && levels[levels.length - 1][0] === price) {\n        levels[levels.length - 1][1] += size;\n      } else if (levels.length === depth) {\n        break;\n      } else {\n        levels.push([price, size]);\n      }\n    }\n\n    return levels;\n  }\n\n  getL2(depth) {\n    const levels = []; // (price, size)\n    //@ts-ignore\n\n    for (const {\n      priceLots,\n      sizeLots\n    } of this.items()) {\n      if (levels.length > 0 && levels[levels.length - 1][0].eq(priceLots)) {\n        levels[levels.length - 1][1].iadd(sizeLots);\n      } else if (levels.length === depth) {\n        break;\n      } else {\n        levels.push([priceLots, sizeLots]);\n      }\n    }\n\n    return levels.map(_ref => {\n      let [priceLots, sizeLots] = _ref;\n      return [this.perpMarket.priceLotsToNumber(priceLots), this.perpMarket.baseLotsToNumber(sizeLots), priceLots, sizeLots];\n    });\n  }\n\n}\n\nexports.BookSide = BookSide;\n\nfunction getPriceFromKey(key) {\n  return key.ushrn(64); // TODO - maybe use shrn instead\n}\n\nexports.getPriceFromKey = getPriceFromKey;","map":{"version":3,"sources":["../../src/book.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPriceFromKey = exports.BookSide = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst layout_1 = require(\"./layout\");\nconst utils_1 = require(\"./utils/utils\");\nconst client_1 = require(\"./client\");\n// TODO - maybe store ref inside PerpMarket class\nclass BookSide {\n    constructor(publicKey, perpMarket, decoded, includeExpired = false) {\n        this.publicKey = publicKey;\n        this.isBids = decoded.metaData.dataType === layout_1.DataType.Bids;\n        this.perpMarket = perpMarket;\n        this.includeExpired = includeExpired;\n        Object.assign(this, decoded);\n        // Determine the maxTimestamp found on the book to use for tif\n        let maxTimestamp = new bn_js_1.default(client_1.getUnixTs() - 10);\n        for (const { leafNode } of this.nodes) {\n            if (leafNode && leafNode.timestamp.gt(maxTimestamp)) {\n                maxTimestamp = leafNode.timestamp;\n            }\n        }\n        this.now = maxTimestamp;\n    }\n    *items() {\n        if (this.leafCount === 0) {\n            return;\n        }\n        const now = this.now;\n        const stack = [this.rootNode];\n        const [left, right] = this.isBids ? [1, 0] : [0, 1];\n        const side = (this.isBids ? 'buy' : 'sell');\n        while (stack.length > 0) {\n            const index = stack.pop();\n            // @ts-ignore\n            const { leafNode, innerNode } = this.nodes[index]; // we know index is not undefined\n            if (leafNode) {\n                const price = getPriceFromKey(leafNode.key);\n                const expiryTimestamp = leafNode.timeInForce\n                    ? leafNode.timestamp.add(new bn_js_1.default(leafNode.timeInForce))\n                    : utils_1.U64_MAX_BN;\n                if (now.lt(expiryTimestamp) || this.includeExpired) {\n                    yield {\n                        orderId: leafNode.key,\n                        clientId: leafNode.clientOrderId,\n                        owner: leafNode.owner,\n                        openOrdersSlot: leafNode.ownerSlot,\n                        feeTier: 0,\n                        price: this.perpMarket.priceLotsToNumber(price),\n                        priceLots: price,\n                        size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n                        sizeLots: leafNode.quantity,\n                        side,\n                        bestInitial: leafNode.bestInitial,\n                        timestamp: leafNode.timestamp,\n                        expiryTimestamp,\n                    };\n                }\n            }\n            else if (innerNode) {\n                stack.push(innerNode.children[right], innerNode.children[left]);\n            }\n        }\n    }\n    /**\n     * Return the ui price reached at `quantity` lots up the book;\n     * return undefined if `quantity` not on book\n     */\n    getImpactPriceUi(quantity) {\n        const s = utils_1.ZERO_BN.clone();\n        for (const order of this) {\n            s.iadd(order.sizeLots);\n            if (s.gte(quantity)) {\n                return order.price;\n            }\n        }\n        return undefined;\n    }\n    getBest() {\n        if (this.leafCount === 0) {\n            return;\n        }\n        const [left, right] = this.isBids ? [1, 0] : [0, 1];\n        const side = (this.isBids ? 'buy' : 'sell');\n        const stack = [this.rootNode];\n        const now = this.now;\n        while (stack.length > 0) {\n            let index = stack.pop();\n            // @ts-ignore\n            const { leafNode, innerNode } = this.nodes[index]; // we know index is not undefined\n            if (leafNode) {\n                const price = getPriceFromKey(leafNode.key);\n                const expiryTimestamp = leafNode.timeInForce\n                    ? leafNode.timestamp.add(new bn_js_1.default(leafNode.timeInForce))\n                    : utils_1.U64_MAX_BN;\n                if (now.lt(expiryTimestamp) || this.includeExpired) {\n                    return {\n                        orderId: leafNode.key,\n                        clientId: leafNode.clientOrderId,\n                        owner: leafNode.owner,\n                        openOrdersSlot: leafNode.ownerSlot,\n                        feeTier: 0,\n                        price: this.perpMarket.priceLotsToNumber(price),\n                        priceLots: price,\n                        size: this.perpMarket.baseLotsToNumber(leafNode.quantity),\n                        sizeLots: leafNode.quantity,\n                        side,\n                        bestInitial: leafNode.bestInitial,\n                        timestamp: leafNode.timestamp,\n                        expiryTimestamp,\n                    };\n                }\n            }\n            else if (innerNode) {\n                stack.push(innerNode.children[right], innerNode.children[left]);\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.items();\n    }\n    getL2Ui(depth) {\n        const levels = []; // (price, size)\n        //@ts-ignore\n        for (const { price, size } of this.items()) {\n            if (levels.length > 0 && levels[levels.length - 1][0] === price) {\n                levels[levels.length - 1][1] += size;\n            }\n            else if (levels.length === depth) {\n                break;\n            }\n            else {\n                levels.push([price, size]);\n            }\n        }\n        return levels;\n    }\n    getL2(depth) {\n        const levels = []; // (price, size)\n        //@ts-ignore\n        for (const { priceLots, sizeLots } of this.items()) {\n            if (levels.length > 0 && levels[levels.length - 1][0].eq(priceLots)) {\n                levels[levels.length - 1][1].iadd(sizeLots);\n            }\n            else if (levels.length === depth) {\n                break;\n            }\n            else {\n                levels.push([priceLots, sizeLots]);\n            }\n        }\n        return levels.map(([priceLots, sizeLots]) => [\n            this.perpMarket.priceLotsToNumber(priceLots),\n            this.perpMarket.baseLotsToNumber(sizeLots),\n            priceLots,\n            sizeLots,\n        ]);\n    }\n}\nexports.BookSide = BookSide;\nfunction getPriceFromKey(key) {\n    return key.ushrn(64); // TODO - maybe use shrn instead\n}\nexports.getPriceFromKey = getPriceFromKey;\n//# sourceMappingURL=book.js.map"]},"metadata":{},"sourceType":"script"}