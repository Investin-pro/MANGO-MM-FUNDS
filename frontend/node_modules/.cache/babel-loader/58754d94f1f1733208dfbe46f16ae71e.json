{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _1 = require(\".\");\n\nclass PerpEventQueue {\n  constructor(decoded) {\n    Object.assign(this, decoded);\n  }\n\n  getUnconsumedEvents() {\n    const events = [];\n    const head = this.head.toNumber();\n\n    for (let i = 0; i < this.count.toNumber(); i++) {\n      events.push(this.events[(head + i) % this.events.length]);\n    }\n\n    return events;\n  }\n  /**\n   * Returns events since the lastSeqNum you've seen. If you haven't seen any yet,\n   * send in undefined for lastSeqNum\n   */\n\n\n  eventsSince(lastSeqNum) {\n    const flatEvents = [];\n\n    for (const e of this.events) {\n      let event;\n\n      if (e.fill) {\n        event = e.fill;\n        event['eventType'] = 'fill';\n      } else if (e.out) {\n        event = e.out;\n        event['eventType'] = 'out';\n      } else if (e.liquidate) {\n        event = e.liquidate;\n        event['eventType'] = 'liquidate';\n      } else {\n        continue;\n      }\n\n      flatEvents.push(event);\n    }\n\n    let filtered;\n\n    if (lastSeqNum === undefined) {\n      filtered = flatEvents.filter(e => e.timestamp.gt(_1.ZERO_BN)).sort((a, b) => a.seqNum.cmp(b.seqNum));\n    } else {\n      filtered = flatEvents.filter(e => e.seqNum.gt(lastSeqNum)).sort((a, b) => a.seqNum.cmp(b.seqNum));\n    } // @ts-ignore\n\n\n    return filtered.map(e => {\n      if (e['eventType'] === 'fill') {\n        return {\n          fill: e\n        };\n      } else if (e['eventType'] === 'out') {\n        return {\n          out: e\n        };\n      } else if (e['eventType'] === 'liquidate') {\n        return {\n          liquidate: e\n        };\n      } // undefined if it's not one of those event types which it shouldn't be anyway\n\n    }); // const modulo64Uint = new BN('10000000000000000', 'hex');\n    // let missedEvents = this.seqNum\n    //   .add(modulo64Uint)\n    //   .sub(lastSeqNum)\n    //   .mod(modulo64Uint);\n    //\n    // /*\n    // console.log({\n    //   last: lastSeqNum.toString(),\n    //   now: this.seqNum.toString(),\n    //   missed: missedEvents.toString(),\n    //   mod: modulo64Uint.toString(),\n    // });\n    // */\n    //\n    // const bufferLength = new BN(this.events.length);\n    // if (missedEvents.gte(bufferLength)) {\n    //   missedEvents = bufferLength.sub(new BN(1));\n    // }\n    //\n    // const endIndex = this.head.add(this.count).mod(bufferLength);\n    // const startIndex = endIndex\n    //   .add(bufferLength)\n    //   .sub(missedEvents)\n    //   .mod(bufferLength);\n    //\n    // /*\n    // console.log({\n    //   bufLength: bufferLength.toString(),\n    //   missed: missedEvents.toString(),\n    //   head: this.head.toString(),\n    //   count: this.count.toString(),\n    //   end: endIndex.toString(),\n    //   start: startIndex.toString(),\n    // });\n    // */\n    //\n    // const results: {\n    //   fill?: FillEvent;\n    //   out?: OutEvent;\n    //   liquidate?: LiquidateEvent;\n    // }[] = [];\n    // let index = startIndex;\n    // while (!index.eq(endIndex)) {\n    //   const event = this.events[index.toNumber()];\n    //   if (event.fill || event.out || event.liquidate) results.push(event);\n    //   index = index.add(new BN(1)).mod(bufferLength);\n    // }\n    //\n    // return results;\n  }\n\n}\n\nexports.default = PerpEventQueue;","map":{"version":3,"sources":["../../src/PerpEventQueue.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _1 = require(\".\");\nclass PerpEventQueue {\n    constructor(decoded) {\n        Object.assign(this, decoded);\n    }\n    getUnconsumedEvents() {\n        const events = [];\n        const head = this.head.toNumber();\n        for (let i = 0; i < this.count.toNumber(); i++) {\n            events.push(this.events[(head + i) % this.events.length]);\n        }\n        return events;\n    }\n    /**\n     * Returns events since the lastSeqNum you've seen. If you haven't seen any yet,\n     * send in undefined for lastSeqNum\n     */\n    eventsSince(lastSeqNum) {\n        const flatEvents = [];\n        for (const e of this.events) {\n            let event;\n            if (e.fill) {\n                event = e.fill;\n                event['eventType'] = 'fill';\n            }\n            else if (e.out) {\n                event = e.out;\n                event['eventType'] = 'out';\n            }\n            else if (e.liquidate) {\n                event = e.liquidate;\n                event['eventType'] = 'liquidate';\n            }\n            else {\n                continue;\n            }\n            flatEvents.push(event);\n        }\n        let filtered;\n        if (lastSeqNum === undefined) {\n            filtered = flatEvents\n                .filter((e) => e.timestamp.gt(_1.ZERO_BN))\n                .sort((a, b) => a.seqNum.cmp(b.seqNum));\n        }\n        else {\n            filtered = flatEvents\n                .filter((e) => e.seqNum.gt(lastSeqNum))\n                .sort((a, b) => a.seqNum.cmp(b.seqNum));\n        }\n        // @ts-ignore\n        return filtered.map((e) => {\n            if (e['eventType'] === 'fill') {\n                return { fill: e };\n            }\n            else if (e['eventType'] === 'out') {\n                return { out: e };\n            }\n            else if (e['eventType'] === 'liquidate') {\n                return { liquidate: e };\n            }\n            // undefined if it's not one of those event types which it shouldn't be anyway\n        });\n        // const modulo64Uint = new BN('10000000000000000', 'hex');\n        // let missedEvents = this.seqNum\n        //   .add(modulo64Uint)\n        //   .sub(lastSeqNum)\n        //   .mod(modulo64Uint);\n        //\n        // /*\n        // console.log({\n        //   last: lastSeqNum.toString(),\n        //   now: this.seqNum.toString(),\n        //   missed: missedEvents.toString(),\n        //   mod: modulo64Uint.toString(),\n        // });\n        // */\n        //\n        // const bufferLength = new BN(this.events.length);\n        // if (missedEvents.gte(bufferLength)) {\n        //   missedEvents = bufferLength.sub(new BN(1));\n        // }\n        //\n        // const endIndex = this.head.add(this.count).mod(bufferLength);\n        // const startIndex = endIndex\n        //   .add(bufferLength)\n        //   .sub(missedEvents)\n        //   .mod(bufferLength);\n        //\n        // /*\n        // console.log({\n        //   bufLength: bufferLength.toString(),\n        //   missed: missedEvents.toString(),\n        //   head: this.head.toString(),\n        //   count: this.count.toString(),\n        //   end: endIndex.toString(),\n        //   start: startIndex.toString(),\n        // });\n        // */\n        //\n        // const results: {\n        //   fill?: FillEvent;\n        //   out?: OutEvent;\n        //   liquidate?: LiquidateEvent;\n        // }[] = [];\n        // let index = startIndex;\n        // while (!index.eq(endIndex)) {\n        //   const event = this.events[index.toNumber()];\n        //   if (event.fill || event.out || event.liquidate) results.push(event);\n        //   index = index.add(new BN(1)).mod(bufferLength);\n        // }\n        //\n        // return results;\n    }\n}\nexports.default = PerpEventQueue;\n//# sourceMappingURL=PerpEventQueue.js.map"]},"metadata":{},"sourceType":"script"}