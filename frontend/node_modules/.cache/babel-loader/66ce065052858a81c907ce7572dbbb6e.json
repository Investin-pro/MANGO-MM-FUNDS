{"ast":null,"code":"import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"../error\";\nexport class IdlCoder {\n  static fieldLayout(field, types) {\n    const fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n\n    switch (field.type) {\n      case \"bool\":\n        {\n          return borsh.bool(fieldName);\n        }\n\n      case \"u8\":\n        {\n          return borsh.u8(fieldName);\n        }\n\n      case \"i8\":\n        {\n          return borsh.i8(fieldName);\n        }\n\n      case \"u16\":\n        {\n          return borsh.u16(fieldName);\n        }\n\n      case \"i16\":\n        {\n          return borsh.i16(fieldName);\n        }\n\n      case \"u32\":\n        {\n          return borsh.u32(fieldName);\n        }\n\n      case \"i32\":\n        {\n          return borsh.i32(fieldName);\n        }\n\n      case \"u64\":\n        {\n          return borsh.u64(fieldName);\n        }\n\n      case \"i64\":\n        {\n          return borsh.i64(fieldName);\n        }\n\n      case \"u128\":\n        {\n          return borsh.u128(fieldName);\n        }\n\n      case \"i128\":\n        {\n          return borsh.i128(fieldName);\n        }\n\n      case \"bytes\":\n        {\n          return borsh.vecU8(fieldName);\n        }\n\n      case \"string\":\n        {\n          return borsh.str(fieldName);\n        }\n\n      case \"publicKey\":\n        {\n          return borsh.publicKey(fieldName);\n        }\n\n      default:\n        {\n          // @ts-ignore\n          if (field.type.vec) {\n            return borsh.vec(IdlCoder.fieldLayout({\n              name: undefined,\n              // @ts-ignore\n              type: field.type.vec\n            }, types), fieldName); // @ts-ignore\n          } else if (field.type.option) {\n            return borsh.option(IdlCoder.fieldLayout({\n              name: undefined,\n              // @ts-ignore\n              type: field.type.option\n            }, types), fieldName); // @ts-ignore\n          } else if (field.type.defined) {\n            // User defined type.\n            if (types === undefined) {\n              throw new IdlError(\"User defined types not provided\");\n            } // @ts-ignore\n\n\n            const filtered = types.filter(t => t.name === field.type.defined);\n\n            if (filtered.length !== 1) {\n              throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n            }\n\n            return IdlCoder.typeDefLayout(filtered[0], types, fieldName); // @ts-ignore\n          } else if (field.type.array) {\n            // @ts-ignore\n            let arrayTy = field.type.array[0]; // @ts-ignore\n\n            let arrayLen = field.type.array[1];\n            let innerLayout = IdlCoder.fieldLayout({\n              name: undefined,\n              type: arrayTy\n            }, types);\n            return borsh.array(innerLayout, arrayLen, fieldName);\n          } else {\n            throw new Error(`Not yet implemented: ${field}`);\n          }\n        }\n    }\n  }\n\n  static typeDefLayout(typeDef, types, name) {\n    if (typeDef.type.kind === \"struct\") {\n      const fieldLayouts = typeDef.type.fields.map(field => {\n        const x = IdlCoder.fieldLayout(field, types);\n        return x;\n      });\n      return borsh.struct(fieldLayouts, name);\n    } else if (typeDef.type.kind === \"enum\") {\n      let variants = typeDef.type.variants.map(variant => {\n        const name = camelCase(variant.name);\n\n        if (variant.fields === undefined) {\n          return borsh.struct([], name);\n        } // @ts-ignore\n\n\n        const fieldLayouts = variant.fields.map(f => {\n          // @ts-ignore\n          if (f.name === undefined) {\n            throw new Error(\"Tuple enum variants not yet implemented.\");\n          } // @ts-ignore\n\n\n          return IdlCoder.fieldLayout(f, types);\n        });\n        return borsh.struct(fieldLayouts, name);\n      });\n\n      if (name !== undefined) {\n        // Buffer-layout lib requires the name to be null (on construction)\n        // when used as a field.\n        return borsh.rustEnum(variants).replicate(name);\n      }\n\n      return borsh.rustEnum(variants, name);\n    } else {\n      throw new Error(`Unknown type kint: ${typeDef}`);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/coder/idl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlError } from \"../error\";\nexport class IdlCoder {\n    static fieldLayout(field, types) {\n        const fieldName = field.name !== undefined ? camelCase(field.name) : undefined;\n        switch (field.type) {\n            case \"bool\": {\n                return borsh.bool(fieldName);\n            }\n            case \"u8\": {\n                return borsh.u8(fieldName);\n            }\n            case \"i8\": {\n                return borsh.i8(fieldName);\n            }\n            case \"u16\": {\n                return borsh.u16(fieldName);\n            }\n            case \"i16\": {\n                return borsh.i16(fieldName);\n            }\n            case \"u32\": {\n                return borsh.u32(fieldName);\n            }\n            case \"i32\": {\n                return borsh.i32(fieldName);\n            }\n            case \"u64\": {\n                return borsh.u64(fieldName);\n            }\n            case \"i64\": {\n                return borsh.i64(fieldName);\n            }\n            case \"u128\": {\n                return borsh.u128(fieldName);\n            }\n            case \"i128\": {\n                return borsh.i128(fieldName);\n            }\n            case \"bytes\": {\n                return borsh.vecU8(fieldName);\n            }\n            case \"string\": {\n                return borsh.str(fieldName);\n            }\n            case \"publicKey\": {\n                return borsh.publicKey(fieldName);\n            }\n            default: {\n                // @ts-ignore\n                if (field.type.vec) {\n                    return borsh.vec(IdlCoder.fieldLayout({\n                        name: undefined,\n                        // @ts-ignore\n                        type: field.type.vec,\n                    }, types), fieldName);\n                    // @ts-ignore\n                }\n                else if (field.type.option) {\n                    return borsh.option(IdlCoder.fieldLayout({\n                        name: undefined,\n                        // @ts-ignore\n                        type: field.type.option,\n                    }, types), fieldName);\n                    // @ts-ignore\n                }\n                else if (field.type.defined) {\n                    // User defined type.\n                    if (types === undefined) {\n                        throw new IdlError(\"User defined types not provided\");\n                    }\n                    // @ts-ignore\n                    const filtered = types.filter((t) => t.name === field.type.defined);\n                    if (filtered.length !== 1) {\n                        throw new IdlError(`Type not found: ${JSON.stringify(field)}`);\n                    }\n                    return IdlCoder.typeDefLayout(filtered[0], types, fieldName);\n                    // @ts-ignore\n                }\n                else if (field.type.array) {\n                    // @ts-ignore\n                    let arrayTy = field.type.array[0];\n                    // @ts-ignore\n                    let arrayLen = field.type.array[1];\n                    let innerLayout = IdlCoder.fieldLayout({\n                        name: undefined,\n                        type: arrayTy,\n                    }, types);\n                    return borsh.array(innerLayout, arrayLen, fieldName);\n                }\n                else {\n                    throw new Error(`Not yet implemented: ${field}`);\n                }\n            }\n        }\n    }\n    static typeDefLayout(typeDef, types, name) {\n        if (typeDef.type.kind === \"struct\") {\n            const fieldLayouts = typeDef.type.fields.map((field) => {\n                const x = IdlCoder.fieldLayout(field, types);\n                return x;\n            });\n            return borsh.struct(fieldLayouts, name);\n        }\n        else if (typeDef.type.kind === \"enum\") {\n            let variants = typeDef.type.variants.map((variant) => {\n                const name = camelCase(variant.name);\n                if (variant.fields === undefined) {\n                    return borsh.struct([], name);\n                }\n                // @ts-ignore\n                const fieldLayouts = variant.fields.map((f) => {\n                    // @ts-ignore\n                    if (f.name === undefined) {\n                        throw new Error(\"Tuple enum variants not yet implemented.\");\n                    }\n                    // @ts-ignore\n                    return IdlCoder.fieldLayout(f, types);\n                });\n                return borsh.struct(fieldLayouts, name);\n            });\n            if (name !== undefined) {\n                // Buffer-layout lib requires the name to be null (on construction)\n                // when used as a field.\n                return borsh.rustEnum(variants).replicate(name);\n            }\n            return borsh.rustEnum(variants, name);\n        }\n        else {\n            throw new Error(`Unknown type kint: ${typeDef}`);\n        }\n    }\n}\n//# sourceMappingURL=idl.js.map"]},"metadata":{},"sourceType":"module"}