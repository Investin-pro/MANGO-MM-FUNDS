{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nlet converter;\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\n\nfunction toBigIntLE(buf) {\n  {\n    const reversed = Buffer.from(buf);\n    reversed.reverse();\n    const hex = reversed.toString('hex');\n\n    if (hex.length === 0) {\n      return BigInt(0);\n    }\n\n    return BigInt(`0x${hex}`);\n  }\n  return converter.toBigInt(buf, false);\n}\n\nexports.toBigIntLE = toBigIntLE;\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\n\nfunction toBigIntBE(buf) {\n  {\n    const hex = buf.toString('hex');\n\n    if (hex.length === 0) {\n      return BigInt(0);\n    }\n\n    return BigInt(`0x${hex}`);\n  }\n  return converter.toBigInt(buf, true);\n}\n\nexports.toBigIntBE = toBigIntBE;\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\n\nfunction toBufferLE(num, width) {\n  {\n    const hex = num.toString(16);\n    const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n    buffer.reverse();\n    return buffer;\n  } // Allocation is done here, since it is slower using napi in C\n\n  return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);\n}\n\nexports.toBufferLE = toBufferLE;\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\n\nfunction toBufferBE(num, width) {\n  {\n    const hex = num.toString(16);\n    return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n  }\n  return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);\n}\n\nexports.toBufferBE = toBufferBE;","map":{"version":3,"sources":["/Users/zohebshahzan/code/Solana-2/frontend/node_modules/bigint-buffer/dist/browser.js"],"names":["Object","defineProperty","exports","value","converter","toBigIntLE","buf","reversed","Buffer","from","reverse","hex","toString","length","BigInt","toBigInt","toBigIntBE","toBufferLE","num","width","buffer","padStart","slice","fromBigInt","allocUnsafe","toBufferBE"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA,IAAIC,SAAJ;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;AACrB;AACI,UAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAP,CAAYH,GAAZ,CAAjB;AACAC,IAAAA,QAAQ,CAACG,OAAT;AACA,UAAMC,GAAG,GAAGJ,QAAQ,CAACK,QAAT,CAAkB,KAAlB,CAAZ;;AACA,QAAID,GAAG,CAACE,MAAJ,KAAe,CAAnB,EAAsB;AAClB,aAAOC,MAAM,CAAC,CAAD,CAAb;AACH;;AACD,WAAOA,MAAM,CAAE,KAAIH,GAAI,EAAV,CAAb;AACH;AACD,SAAOP,SAAS,CAACW,QAAV,CAAmBT,GAAnB,EAAwB,KAAxB,CAAP;AACH;;AACDJ,OAAO,CAACG,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASW,UAAT,CAAoBV,GAApB,EAAyB;AACrB;AACI,UAAMK,GAAG,GAAGL,GAAG,CAACM,QAAJ,CAAa,KAAb,CAAZ;;AACA,QAAID,GAAG,CAACE,MAAJ,KAAe,CAAnB,EAAsB;AAClB,aAAOC,MAAM,CAAC,CAAD,CAAb;AACH;;AACD,WAAOA,MAAM,CAAE,KAAIH,GAAI,EAAV,CAAb;AACH;AACD,SAAOP,SAAS,CAACW,QAAV,CAAmBT,GAAnB,EAAwB,IAAxB,CAAP;AACH;;AACDJ,OAAO,CAACc,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,KAAzB,EAAgC;AAC5B;AACI,UAAMR,GAAG,GAAGO,GAAG,CAACN,QAAJ,CAAa,EAAb,CAAZ;AACA,UAAMQ,MAAM,GAAGZ,MAAM,CAACC,IAAP,CAAYE,GAAG,CAACU,QAAJ,CAAaF,KAAK,GAAG,CAArB,EAAwB,GAAxB,EAA6BG,KAA7B,CAAmC,CAAnC,EAAsCH,KAAK,GAAG,CAA9C,CAAZ,EAA8D,KAA9D,CAAf;AACAC,IAAAA,MAAM,CAACV,OAAP;AACA,WAAOU,MAAP;AACH,GAN2B,CAO5B;;AACA,SAAOhB,SAAS,CAACmB,UAAV,CAAqBL,GAArB,EAA0BV,MAAM,CAACgB,WAAP,CAAmBL,KAAnB,CAA1B,EAAqD,KAArD,CAAP;AACH;;AACDjB,OAAO,CAACe,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASQ,UAAT,CAAoBP,GAApB,EAAyBC,KAAzB,EAAgC;AAC5B;AACI,UAAMR,GAAG,GAAGO,GAAG,CAACN,QAAJ,CAAa,EAAb,CAAZ;AACA,WAAOJ,MAAM,CAACC,IAAP,CAAYE,GAAG,CAACU,QAAJ,CAAaF,KAAK,GAAG,CAArB,EAAwB,GAAxB,EAA6BG,KAA7B,CAAmC,CAAnC,EAAsCH,KAAK,GAAG,CAA9C,CAAZ,EAA8D,KAA9D,CAAP;AACH;AACD,SAAOf,SAAS,CAACmB,UAAV,CAAqBL,GAArB,EAA0BV,MAAM,CAACgB,WAAP,CAAmBL,KAAnB,CAA1B,EAAqD,IAArD,CAAP;AACH;;AACDjB,OAAO,CAACuB,UAAR,GAAqBA,UAArB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet converter;\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\nfunction toBigIntLE(buf) {\n    {\n        const reversed = Buffer.from(buf);\n        reversed.reverse();\n        const hex = reversed.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, false);\n}\nexports.toBigIntLE = toBigIntLE;\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\nfunction toBigIntBE(buf) {\n    {\n        const hex = buf.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, true);\n}\nexports.toBigIntBE = toBigIntBE;\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\nfunction toBufferLE(num, width) {\n    {\n        const hex = num.toString(16);\n        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n        buffer.reverse();\n        return buffer;\n    }\n    // Allocation is done here, since it is slower using napi in C\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);\n}\nexports.toBufferLE = toBufferLE;\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\nfunction toBufferBE(num, width) {\n    {\n        const hex = num.toString(16);\n        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n    }\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);\n}\nexports.toBufferBE = toBufferBE;\n"]},"metadata":{},"sourceType":"script"}