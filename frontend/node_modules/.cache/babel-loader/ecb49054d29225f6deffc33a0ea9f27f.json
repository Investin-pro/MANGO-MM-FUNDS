{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findLargestTokenAccountForOwner = exports.getTokenAccountsByOwnerWithWrappedSol = exports.TokenAccount = void 0;\n\nconst serum_1 = require(\"@project-serum/serum\");\n\nconst layout_1 = require(\"./layout\");\n\nclass TokenAccount {\n  constructor(publicKey, decoded) {\n    this.publicKey = publicKey;\n    Object.assign(this, decoded);\n  }\n\n}\n\nexports.TokenAccount = TokenAccount;\n\nfunction parseTokenResponse(r) {\n  return r.value.map(_ref => {\n    let {\n      pubkey,\n      account\n    } = _ref;\n    return new TokenAccount(pubkey, layout_1.TokenAccountLayout.decode(account.data));\n  });\n}\n\nfunction getTokenAccountsByOwnerWithWrappedSol(connection, owner) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const solReq = connection.getAccountInfo(owner);\n    const tokenReq = connection.getTokenAccountsByOwner(owner, {\n      programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID\n    }); // fetch data\n\n    const [solResp, tokenResp] = yield Promise.all([solReq, tokenReq]); // parse token accounts\n\n    const tokenAccounts = parseTokenResponse(tokenResp); // create fake wrapped sol account to reflect sol balances in user's wallet\n\n    const solAccount = new TokenAccount(owner, {\n      mint: serum_1.TokenInstructions.WRAPPED_SOL_MINT,\n      owner,\n      amount: (solResp === null || solResp === void 0 ? void 0 : solResp.lamports) || 0\n    }); // prepend SOL account to beginning of list\n\n    return [solAccount].concat(tokenAccounts);\n  });\n}\n\nexports.getTokenAccountsByOwnerWithWrappedSol = getTokenAccountsByOwnerWithWrappedSol;\n\nfunction findLargestTokenAccountForOwner(connection, owner, mint) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const response = yield connection.getTokenAccountsByOwner(owner, {\n      mint\n    }, connection.commitment);\n    let maxTokenAccount = null;\n\n    for (const acc of parseTokenResponse(response)) {\n      if (!maxTokenAccount || acc.amount > maxTokenAccount.amount) {\n        maxTokenAccount = acc;\n      }\n    }\n\n    if (!maxTokenAccount) {\n      throw new Error('No accounts for this token');\n    }\n\n    return maxTokenAccount;\n  });\n}\n\nexports.findLargestTokenAccountForOwner = findLargestTokenAccountForOwner;","map":{"version":3,"sources":["../../src/token.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAa,YAAb,CAAyB;AAMvB,EAAA,WAAA,CAAY,SAAZ,EAAkC,OAAlC,EAA8C;AAC5C,SAAK,SAAL,GAAiB,SAAjB;AACA,IAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB,OAApB;AACD;;AATsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA;;AAYA,SAAS,kBAAT,CAA4B,CAA5B,EAA6B;AAC3B,SAAO,CAAC,CAAC,KAAF,CAAQ,GAAR,CACL;AAAA,QAAC;AAAE,MAAA,MAAF;AAAU,MAAA;AAAV,KAAD;AAAA,WACE,IAAI,YAAJ,CAAiB,MAAjB,EAAyB,QAAA,CAAA,kBAAA,CAAmB,MAAnB,CAA0B,OAAO,CAAC,IAAlC,CAAzB,CADF;AAAA,GADK,CAAP;AAID;;AAED,SAAsB,qCAAtB,CACE,UADF,EAEE,KAFF,EAEkB;;AAEhB,UAAM,MAAM,GAAG,UAAU,CAAC,cAAX,CAA0B,KAA1B,CAAf;AACA,UAAM,QAAQ,GAAG,UAAU,CAAC,uBAAX,CAAmC,KAAnC,EAA0C;AACzD,MAAA,SAAS,EAAE,OAAA,CAAA,iBAAA,CAAkB;AAD4B,KAA1C,CAAjB,C,CAIA;;AACA,UAAM,CAAC,OAAD,EAAU,SAAV,IAAuB,MAAM,OAAO,CAAC,GAAR,CAAY,CAAC,MAAD,EAAS,QAAT,CAAZ,CAAnC,C,CAEA;;AACA,UAAM,aAAa,GAAG,kBAAkB,CAAC,SAAD,CAAxC,C,CACA;;AACA,UAAM,UAAU,GAAG,IAAI,YAAJ,CAAiB,KAAjB,EAAwB;AACzC,MAAA,IAAI,EAAE,OAAA,CAAA,iBAAA,CAAkB,gBADiB;AAEzC,MAAA,KAFyC;AAGzC,MAAA,MAAM,EAAE,CAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,QAAT,KAAqB;AAHY,KAAxB,CAAnB,C,CAMA;;AACA,WAAO,CAAC,UAAD,EAAa,MAAb,CAAoB,aAApB,CAAP;AACD,G;AAAA;;AAvBD,OAAA,CAAA,qCAAA,GAAA,qCAAA;;AAyBA,SAAsB,+BAAtB,CACE,UADF,EAEE,KAFF,EAGE,IAHF,EAGiB;;AAEf,UAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,uBAAX,CACrB,KADqB,EAErB;AAAE,MAAA;AAAF,KAFqB,EAGrB,UAAU,CAAC,UAHU,CAAvB;AAKA,QAAI,eAAe,GAAwB,IAA3C;;AACA,SAAK,MAAM,GAAX,IAAkB,kBAAkB,CAAC,QAAD,CAApC,EAAgD;AAC9C,UAAI,CAAC,eAAD,IAAoB,GAAG,CAAC,MAAJ,GAAa,eAAe,CAAC,MAArD,EAA6D;AAC3D,QAAA,eAAe,GAAG,GAAlB;AACD;AACF;;AAED,QAAI,CAAC,eAAL,EAAsB;AACpB,YAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,WAAO,eAAP;AACD,G;AAAA;;AAtBD,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findLargestTokenAccountForOwner = exports.getTokenAccountsByOwnerWithWrappedSol = exports.TokenAccount = void 0;\nconst serum_1 = require(\"@project-serum/serum\");\nconst layout_1 = require(\"./layout\");\nclass TokenAccount {\n    constructor(publicKey, decoded) {\n        this.publicKey = publicKey;\n        Object.assign(this, decoded);\n    }\n}\nexports.TokenAccount = TokenAccount;\nfunction parseTokenResponse(r) {\n    return r.value.map(({ pubkey, account }) => new TokenAccount(pubkey, layout_1.TokenAccountLayout.decode(account.data)));\n}\nfunction getTokenAccountsByOwnerWithWrappedSol(connection, owner) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const solReq = connection.getAccountInfo(owner);\n        const tokenReq = connection.getTokenAccountsByOwner(owner, {\n            programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,\n        });\n        // fetch data\n        const [solResp, tokenResp] = yield Promise.all([solReq, tokenReq]);\n        // parse token accounts\n        const tokenAccounts = parseTokenResponse(tokenResp);\n        // create fake wrapped sol account to reflect sol balances in user's wallet\n        const solAccount = new TokenAccount(owner, {\n            mint: serum_1.TokenInstructions.WRAPPED_SOL_MINT,\n            owner,\n            amount: (solResp === null || solResp === void 0 ? void 0 : solResp.lamports) || 0,\n        });\n        // prepend SOL account to beginning of list\n        return [solAccount].concat(tokenAccounts);\n    });\n}\nexports.getTokenAccountsByOwnerWithWrappedSol = getTokenAccountsByOwnerWithWrappedSol;\nfunction findLargestTokenAccountForOwner(connection, owner, mint) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const response = yield connection.getTokenAccountsByOwner(owner, { mint }, connection.commitment);\n        let maxTokenAccount = null;\n        for (const acc of parseTokenResponse(response)) {\n            if (!maxTokenAccount || acc.amount > maxTokenAccount.amount) {\n                maxTokenAccount = acc;\n            }\n        }\n        if (!maxTokenAccount) {\n            throw new Error('No accounts for this token');\n        }\n        return maxTokenAccount;\n    });\n}\nexports.findLargestTokenAccountForOwner = findLargestTokenAccountForOwner;\n//# sourceMappingURL=token.js.map"]},"metadata":{},"sourceType":"script"}