{"ast":null,"code":"import isEqual from 'fast-deep-equal/es6';\nimport React, { useRef, useState, useEffect, useContext } from 'react';\nimport produce$1, { enablePatches, produceWithPatches, produce, applyPatches } from 'immer';\n\nfunction useStoreState(store, getSubState, deps) {\n  const updateRef = useRef({\n    state: undefined,\n    initialized: false\n  });\n\n  if (!updateRef.current.initialized) {\n    updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();\n    updateRef.current.initialized = true;\n  }\n\n  const [, setUpdateTrigger] = useState(0);\n  useEffect(() => {\n    const effectState = {\n      shouldUpdate: true\n    };\n\n    function update() {\n      if (effectState.shouldUpdate) {\n        const nextSubState = getSubState ? getSubState(store.getRawState()) : store.getRawState();\n\n        if (!isEqual(updateRef.current.state, nextSubState)) {\n          if (effectState.shouldUpdate) {\n            updateRef.current.state = nextSubState;\n            setUpdateTrigger(val => val + 1);\n          }\n        }\n      }\n    }\n\n    store._addUpdateListener(update);\n\n    update();\n    return () => {\n      effectState.shouldUpdate = false;\n\n      store._removeUpdateListener(update);\n    };\n  }, deps !== null && deps !== void 0 ? deps : []);\n\n  if (deps !== undefined) {\n    const prevDeps = useRef(deps);\n\n    if (!isEqual(deps, prevDeps)) {\n      updateRef.current.state = getSubState(store.getRawState());\n    }\n  }\n\n  return updateRef.current.state;\n}\n\nlet updateListenerOrd = 0;\n\nfunction fastGet(obj, path) {\n  return path.reduce(function () {\n    let cur = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : obj;\n    let key = arguments.length > 1 ? arguments[1] : undefined;\n    return cur[key];\n  }, undefined);\n}\n\nfunction getSubStateFromPaths(store, paths) {\n  const state = store.getRawState();\n  const resp = [];\n\n  for (const path of paths) {\n    resp.push(fastGet(state, path));\n  }\n\n  return resp;\n}\n\nfunction useStoreStateOpt(store, paths) {\n  const [subState, setSubState] = useState(() => getSubStateFromPaths(store, paths));\n  const updateRef = useRef({\n    shouldUpdate: true,\n    onStoreUpdate: null,\n    currentSubState: null,\n    ordKey: `_${updateListenerOrd++}`\n  });\n  updateRef.current.currentSubState = subState;\n\n  if (updateRef.current.onStoreUpdate === null) {\n    updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {\n      if (updateRef.current.shouldUpdate) {\n        setSubState(getSubStateFromPaths(store, paths));\n      }\n    };\n\n    store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);\n  }\n\n  useEffect(() => () => {\n    updateRef.current.shouldUpdate = false;\n\n    store._removeUpdateListenerOpt(updateRef.current.ordKey);\n  }, []);\n  return subState;\n}\n\nfunction useLocalStore(initialState, deps) {\n  const storeRef = useRef();\n\n  if (storeRef.current == null) {\n    storeRef.current = new Store(initialState);\n  }\n\n  if (deps !== undefined) {\n    const prevDeps = useRef(deps);\n\n    if (!isEqual(deps, prevDeps)) {\n      storeRef.current = new Store(initialState);\n    }\n  }\n\n  return storeRef.current;\n}\n\nconst globalClientState = {\n  storeOrdinal: 0,\n  batching: false,\n  flushStores: {}\n};\nenablePatches();\n\nfunction makeSubscriptionFunction(store, watch, listener) {\n  let lastWatchState = watch(store.getRawState());\n  return () => {\n    const currentState = store.getRawState();\n    const nextWatchState = watch(currentState);\n\n    if (!isEqual(nextWatchState, lastWatchState)) {\n      listener(nextWatchState, currentState, lastWatchState);\n      lastWatchState = nextWatchState;\n    }\n  };\n}\n\nfunction makeReactionFunctionCreator(watch, reaction) {\n  return store => {\n    let lastWatchState = watch(store.getRawState());\n    return function () {\n      let forceRun = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      const currentState = store.getRawState();\n      const nextWatchState = watch(currentState);\n\n      if (forceRun || !isEqual(nextWatchState, lastWatchState)) {\n        if (store._optListenerCount > 0) {\n          const [nextState, patches, inversePatches] = produceWithPatches(currentState, s => reaction(nextWatchState, s, currentState, lastWatchState));\n\n          store._updateStateWithoutReaction(nextState);\n\n          lastWatchState = nextWatchState;\n\n          if (patches.length > 0) {\n            store._patchListeners.forEach(listener => listener(patches, inversePatches));\n\n            return Object.keys(getChangedPathsFromPatches(patches));\n          }\n        } else {\n          if (store._patchListeners.length > 0) {\n            const [nextState, patches, inversePatches] = produceWithPatches(currentState, s => reaction(nextWatchState, s, currentState, lastWatchState));\n\n            if (patches.length > 0) {\n              store._patchListeners.forEach(listener => listener(patches, inversePatches));\n            }\n\n            store._updateStateWithoutReaction(nextState);\n          } else {\n            store._updateStateWithoutReaction(produce(currentState, s => reaction(nextWatchState, s, currentState, lastWatchState)));\n          }\n\n          lastWatchState = nextWatchState;\n        }\n      }\n\n      return [];\n    };\n  };\n}\n\nconst optPathDivider = \"~._.~\";\n\nclass Store {\n  constructor(initialState) {\n    this.updateListeners = [];\n    this.ssr = false;\n    this.reactions = [];\n    this.clientSubscriptions = [];\n    this.reactionCreators = [];\n    this.optimizedUpdateListeners = {};\n    this.optimizedUpdateListenerPaths = {};\n    this.optimizedListenerPropertyMap = {};\n    this._optListenerCount = 0;\n    this._patchListeners = [];\n\n    if (initialState instanceof Function) {\n      const state = initialState();\n      this.currentState = state;\n      this.initialState = state;\n      this.createInitialState = initialState;\n    } else {\n      this.currentState = initialState;\n      this.initialState = initialState;\n\n      this.createInitialState = () => initialState;\n    }\n\n    this.internalOrdId = globalClientState.storeOrdinal++;\n  }\n\n  _setInternalOptions(_ref) {\n    let {\n      ssr,\n      reactionCreators = []\n    } = _ref;\n    this.ssr = ssr;\n    this.reactionCreators = reactionCreators;\n    this.reactions = reactionCreators.map(rc => rc(this));\n  }\n\n  _getReactionCreators() {\n    return this.reactionCreators;\n  }\n\n  _instantiateReactions() {\n    this.reactions = this.reactionCreators.map(rc => rc(this));\n  }\n\n  _getInitialState() {\n    return this.createInitialState();\n  }\n\n  _updateStateWithoutReaction(nextState) {\n    this.currentState = nextState;\n  }\n\n  _updateState(nextState) {\n    let updateKeyedPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.currentState = nextState;\n    this.batchState = undefined;\n\n    for (const runReaction of this.reactions) {\n      updateKeyedPaths.push(...runReaction());\n    }\n\n    if (!this.ssr) {\n      for (const runSubscription of this.clientSubscriptions) {\n        runSubscription();\n      }\n\n      if (updateKeyedPaths.length > 0) {\n        const updateOrds = new Set();\n\n        for (const keyedPath of updateKeyedPaths) {\n          if (this.optimizedListenerPropertyMap[keyedPath]) {\n            for (const ord of this.optimizedListenerPropertyMap[keyedPath]) {\n              updateOrds.add(ord);\n            }\n          }\n        }\n\n        for (const ord of updateOrds.values()) {\n          if (this.optimizedUpdateListeners[ord]) {\n            this.optimizedUpdateListeners[ord]();\n          }\n        }\n      }\n\n      this.updateListeners.forEach(listener => listener());\n    }\n  }\n\n  _addUpdateListener(listener) {\n    this.updateListeners.push(listener);\n  }\n\n  _addUpdateListenerOpt(listener, ordKey, paths) {\n    this.optimizedUpdateListeners[ordKey] = listener;\n    const listenerPathsKeyed = paths.map(path => path.join(optPathDivider));\n    this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;\n\n    for (const keyedPath of listenerPathsKeyed) {\n      if (this.optimizedListenerPropertyMap[keyedPath] == null) {\n        this.optimizedListenerPropertyMap[keyedPath] = [ordKey];\n      } else {\n        this.optimizedListenerPropertyMap[keyedPath].push(ordKey);\n      }\n    }\n\n    this._optListenerCount++;\n  }\n\n  _removeUpdateListener(listener) {\n    this.updateListeners = this.updateListeners.filter(f => f !== listener);\n  }\n\n  _removeUpdateListenerOpt(ordKey) {\n    const listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];\n\n    for (const keyedPath of listenerPathsKeyed) {\n      this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter(ord => ord !== ordKey);\n    }\n\n    delete this.optimizedUpdateListenerPaths[ordKey];\n    delete this.optimizedUpdateListeners[ordKey];\n    this._optListenerCount--;\n  }\n\n  listenToPatches(patchListener) {\n    this._patchListeners.push(patchListener);\n\n    return () => {\n      this._patchListeners = this._patchListeners.filter(f => f !== patchListener);\n    };\n  }\n\n  subscribe(watch, listener) {\n    if (!this.ssr) {\n      const func = makeSubscriptionFunction(this, watch, listener);\n      this.clientSubscriptions.push(func);\n      return () => {\n        this.clientSubscriptions = this.clientSubscriptions.filter(f => f !== func);\n      };\n    }\n\n    return () => {\n      console.warn(`Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.`);\n    };\n  }\n\n  createReaction(watch, reaction) {\n    let {\n      runNow = false,\n      runNowWithSideEffects = false\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const creator = makeReactionFunctionCreator(watch, reaction);\n    this.reactionCreators.push(creator);\n    const func = creator(this);\n    this.reactions.push(func);\n\n    if (runNow || runNowWithSideEffects) {\n      func(true);\n\n      if (runNowWithSideEffects && !this.ssr) {\n        this._updateState(this.currentState);\n      }\n    }\n\n    return () => {\n      this.reactions = this.reactions.filter(f => f !== func);\n    };\n  }\n\n  getRawState() {\n    if (this.batchState !== undefined) {\n      return this.batchState;\n    } else {\n      return this.currentState;\n    }\n  }\n\n  useState(getSubState, deps) {\n    return useStoreState(this, getSubState, deps);\n  }\n\n  useLocalCopyInitial(deps) {\n    return useLocalStore(this.createInitialState, deps);\n  }\n\n  useLocalCopySnapshot(deps) {\n    return useLocalStore(this.currentState, deps);\n  }\n\n  flushBatch() {\n    let ignoreError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (this.batchState !== undefined) {\n      if (this.batchState !== this.currentState) {\n        this._updateState(this.batchState);\n      }\n    } else if (!ignoreError) {\n      console.error(`Pullstate: Trying to flush batch state which was never created or updated on`);\n    }\n\n    this.batchState = undefined;\n  }\n\n  update(updater, patchesCallback) {\n    if (globalClientState.batching) {\n      if (this.batchState === undefined) {\n        this.batchState = this.currentState;\n        globalClientState.flushStores[this.internalOrdId] = this;\n      }\n\n      const func = typeof updater === \"function\";\n      const [nextState, patches, inversePatches] = runUpdates(this.batchState, updater, func);\n\n      if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {\n        if (patchesCallback) {\n          patchesCallback(patches, inversePatches);\n        }\n\n        this._patchListeners.forEach(listener => listener(patches, inversePatches));\n      }\n\n      this.batchState = nextState;\n    } else {\n      this.batchState = undefined;\n      update(this, updater, patchesCallback);\n    }\n  }\n\n  replace(newState) {\n    this._updateState(newState);\n  }\n\n  applyPatches(patches) {\n    applyPatchesToStore(this, patches);\n  }\n\n}\n\nfunction applyPatchesToStore(store, patches) {\n  const currentState = store.getRawState();\n  const nextState = applyPatches(currentState, patches);\n\n  if (nextState !== currentState) {\n    store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\n  }\n}\n\nfunction getChangedPathsFromPatches(changePatches) {\n  let prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (const patch of changePatches) {\n    let curKey;\n\n    for (const p of patch.path) {\n      if (curKey) {\n        curKey = `${curKey}${optPathDivider}${p}`;\n      } else {\n        curKey = p;\n      }\n\n      prev[curKey] = 1;\n    }\n  }\n\n  return prev;\n}\n\nfunction runUpdates(currentState, updater, func) {\n  return func ? produceWithPatches(currentState, s => updater(s, currentState)) : updater.reduce((_ref2, currentValue) => {\n    let [nextState, patches, inversePatches] = _ref2;\n    const resp = produceWithPatches(nextState, s => currentValue(s, nextState));\n    patches.push(...resp[1]);\n    inversePatches.push(...resp[2]);\n    return [resp[0], patches, inversePatches];\n  }, [currentState, [], []]);\n}\n\nfunction update(store, updater, patchesCallback) {\n  const currentState = store.getRawState();\n  const func = typeof updater === \"function\";\n\n  if (store._optListenerCount > 0) {\n    const [nextState, patches, inversePatches] = runUpdates(currentState, updater, func);\n\n    if (patches.length > 0) {\n      if (patchesCallback) {\n        patchesCallback(patches, inversePatches);\n      }\n\n      store._patchListeners.forEach(listener => listener(patches, inversePatches));\n\n      store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\n    }\n  } else {\n    let nextState;\n\n    if (store._patchListeners.length > 0 || patchesCallback) {\n      const [ns, patches, inversePatches] = runUpdates(currentState, updater, func);\n\n      if (patches.length > 0) {\n        if (patchesCallback) {\n          patchesCallback(patches, inversePatches);\n        }\n\n        store._patchListeners.forEach(listener => listener(patches, inversePatches));\n      }\n\n      nextState = ns;\n    } else {\n      nextState = produce(currentState, s => func ? updater(s, currentState) : updater.reduce((previousValue, currentUpdater) => {\n        return produce(previousValue, s => currentUpdater(s, previousValue));\n      }, currentState));\n    }\n\n    if (nextState !== currentState) {\n      store._updateState(nextState);\n    }\n  }\n}\n\nfunction InjectStoreState(_ref3) {\n  let {\n    store,\n    on = s => s,\n    children\n  } = _ref3;\n  const state = useStoreState(store, on);\n  return children(state);\n}\n\nvar EAsyncEndTags;\n\n(function (EAsyncEndTags) {\n  EAsyncEndTags[\"THREW_ERROR\"] = \"THREW_ERROR\";\n  EAsyncEndTags[\"RETURNED_ERROR\"] = \"RETURNED_ERROR\";\n  EAsyncEndTags[\"UNFINISHED\"] = \"UNFINISHED\";\n  EAsyncEndTags[\"DORMANT\"] = \"DORMANT\";\n})(EAsyncEndTags || (EAsyncEndTags = {}));\n\nvar EPostActionContext;\n\n(function (EPostActionContext) {\n  EPostActionContext[\"WATCH_HIT_CACHE\"] = \"WATCH_HIT_CACHE\";\n  EPostActionContext[\"BECKON_HIT_CACHE\"] = \"BECKON_HIT_CACHE\";\n  EPostActionContext[\"RUN_HIT_CACHE\"] = \"RUN_HIT_CACHE\";\n  EPostActionContext[\"READ_HIT_CACHE\"] = \"READ_HIT_CACHE\";\n  EPostActionContext[\"READ_RUN\"] = \"READ_RUN\";\n  EPostActionContext[\"SHORT_CIRCUIT\"] = \"SHORT_CIRCUIT\";\n  EPostActionContext[\"DIRECT_RUN\"] = \"DIRECT_RUN\";\n  EPostActionContext[\"BECKON_RUN\"] = \"BECKON_RUN\";\n  EPostActionContext[\"CACHE_UPDATE\"] = \"CACHE_UPDATE\";\n})(EPostActionContext || (EPostActionContext = {}));\n\nconst clientAsyncCache = {\n  listeners: {},\n  results: {},\n  actions: {},\n  actionOrd: {}\n};\nlet asyncCreationOrdinal = 0;\n\nfunction keyFromObject(json) {\n  if (json === null) {\n    return \"(n)\";\n  }\n\n  const typeOf = typeof json;\n\n  if (typeOf !== \"object\") {\n    if (typeOf === \"undefined\") {\n      return \"(u)\";\n    } else if (typeOf === \"string\") {\n      return \":\" + json + \";\";\n    } else if (typeOf === \"boolean\" || typeOf === \"number\") {\n      return \"(\" + json + \")\";\n    }\n  }\n\n  let prefix = \"{\";\n\n  for (const key of Object.keys(json).sort()) {\n    prefix += key + keyFromObject(json[key]);\n  }\n\n  return prefix + \"}\";\n}\n\nfunction notifyListeners(key) {\n  if (clientAsyncCache.listeners.hasOwnProperty(key)) {\n    for (const watchId of Object.keys(clientAsyncCache.listeners[key])) {\n      clientAsyncCache.listeners[key][watchId]();\n    }\n  }\n}\n\nfunction clearActionCache(key) {\n  let clearPending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let notify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {\n    clientAsyncCache.actionOrd[key] += 1;\n  }\n\n  delete clientAsyncCache.results[key];\n\n  if (notify) {\n    notifyListeners(key);\n  }\n}\n\nfunction actionOrdUpdate(cache, key) {\n  if (!cache.actionOrd.hasOwnProperty(key)) {\n    cache.actionOrd[key] = 0;\n  } else {\n    cache.actionOrd[key] += 1;\n  }\n\n  return cache.actionOrd[key];\n}\n\nfunction successResult() {\n  let payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  return {\n    payload,\n    tags,\n    message,\n    error: false,\n    errorPayload: null\n  };\n}\n\nfunction errorResult() {\n  let tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let errorPayload = arguments.length > 2 ? arguments[2] : undefined;\n  return {\n    payload: null,\n    tags: [EAsyncEndTags.RETURNED_ERROR, ...tags],\n    message,\n    error: true,\n    errorPayload: errorPayload\n  };\n}\n\nclass PullstateAsyncError extends Error {\n  constructor(message, tags) {\n    super(message);\n    this.tags = tags;\n  }\n\n}\n\nlet storeErrorProxy;\n\ntry {\n  storeErrorProxy = new Proxy({}, {\n    get: function (obj, prop) {\n      throw new Error(`Pullstate: Trying to access store (${String(prop)}) inside async actions without the correct usage or setup.\nIf this error occurred on the server:\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\n\nIf this error occurred on the client:\n* Make sure you have created your \"pullstateCore\" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`);\n    }\n  });\n} catch {\n  storeErrorProxy = {};\n}\n\nconst startedButUnfinishedResult = [true, false, {\n  message: \"\",\n  tags: [EAsyncEndTags.UNFINISHED],\n  error: true,\n  payload: null,\n  errorPayload: null\n}, false, -1];\n\nfunction createAsyncActionDirect(action) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return createAsyncAction(async (args, stores, customContext) => {\n    return successResult(await action(args, stores, customContext));\n  }, options);\n}\n\nfunction convertCustomCacheBreakHook(cacheBreakHook) {\n  if (cacheBreakHook != null) {\n    if (typeof cacheBreakHook === \"boolean\") {\n      return () => cacheBreakHook;\n    } else if (typeof cacheBreakHook === \"number\") {\n      return _ref4 => {\n        let {\n          timeCached,\n          result\n        } = _ref4;\n\n        if (!result.error) {\n          return Date.now() - timeCached > cacheBreakHook;\n        }\n\n        return true;\n      };\n    }\n\n    return cacheBreakHook;\n  }\n\n  return undefined;\n}\n\nfunction createAsyncAction(action) {\n  let {\n    forceContext = false,\n    shortCircuitHook,\n    cacheBreakHook,\n    postActionHook,\n    subsetKey,\n    actionId\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const ordinal = actionId != null ? `_${actionId}` : asyncCreationOrdinal++;\n  const onServer = typeof window === \"undefined\";\n\n  function _createKey(args, customKey) {\n    if (customKey != null) {\n      return `${ordinal}-c-${customKey}`;\n    }\n\n    if (subsetKey !== undefined) {\n      return `${ordinal}-${keyFromObject(subsetKey(args))}`;\n    }\n\n    return `${ordinal}-${keyFromObject(args)}`;\n  }\n\n  const deferWaitingKey = `def_wait_${_createKey({})}`;\n  let cacheBreakWatcher = {};\n  let watchIdOrd = 0;\n  const shouldUpdate = {};\n\n  function runPostActionHook(result, args, stores, context) {\n    if (postActionHook !== undefined) {\n      postActionHook({\n        args,\n        result,\n        stores,\n        context\n      });\n    }\n  }\n\n  function getCachedResult(_ref5) {\n    let {\n      args,\n      cache,\n      cacheBreakEnabled,\n      context,\n      fromListener,\n      key,\n      postActionEnabled,\n      stores,\n      customCacheBreak\n    } = _ref5;\n    const useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;\n\n    if (cache.results.hasOwnProperty(key)) {\n      const cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;\n\n      if (!onServer && !fromListener && cacheBreakEnabled && useCacheBreakHook != null && cache.results[key][1] && useCacheBreakHook({\n        args,\n        result: cache.results[key][2],\n        stores,\n        timeCached: cache.results[key][4]\n      }) && !cacheBreakLoop) {\n        if (cacheBreakWatcher.hasOwnProperty(key)) {\n          cacheBreakWatcher[key]++;\n        } else {\n          cacheBreakWatcher[key] = 1;\n        }\n\n        const previous = cache.results[key];\n        delete cache.results[key];\n        return {\n          cacheBroke: true,\n          response: undefined,\n          previous\n        };\n      } else {\n        if (cacheBreakLoop) {\n          console.error(`[${key}] Pullstate detected an infinite loop caused by cacheBreakHook()\nreturning true too often (breaking cache as soon as your action is resolving - hence\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\nfurther looping. Fix in your cacheBreakHook() is needed.`);\n        } else {\n          cacheBreakWatcher[key] = 0;\n        }\n\n        if (postActionEnabled && cache.results[key][1] && !fromListener) {\n          runPostActionHook(cache.results[key][2], args, stores, context);\n        }\n\n        return {\n          response: cache.results[key],\n          cacheBroke: false,\n          previous: undefined\n        };\n      }\n    }\n\n    return {\n      cacheBroke: false,\n      response: undefined,\n      previous: undefined\n    };\n  }\n\n  function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {\n    return () => action(args, stores, customContext).then(resp => {\n      if (currentActionOrd === cache.actionOrd[key]) {\n        if (postActionEnabled) {\n          runPostActionHook(resp, args, stores, executionContext);\n        }\n\n        cache.results[key] = [true, true, resp, false, Date.now()];\n      }\n\n      return resp;\n    }).catch(e => {\n      console.error(e);\n      const result = {\n        payload: null,\n        errorPayload: null,\n        error: true,\n        tags: [EAsyncEndTags.THREW_ERROR],\n        message: e.message\n      };\n\n      if (currentActionOrd === cache.actionOrd[key]) {\n        if (postActionEnabled) {\n          runPostActionHook(result, args, stores, executionContext);\n        }\n\n        cache.results[key] = [true, true, result, false, Date.now()];\n      }\n\n      return result;\n    }).then(resp => {\n      if (currentActionOrd === cache.actionOrd[key]) {\n        delete cache.actions[key];\n\n        if (!onServer) {\n          notifyListeners(key);\n        }\n      }\n\n      return resp;\n    });\n  }\n\n  function checkKeyAndReturnResponse(_ref6) {\n    let {\n      key,\n      cache,\n      initiate,\n      ssr,\n      args,\n      stores,\n      fromListener = false,\n      postActionEnabled = true,\n      cacheBreakEnabled = true,\n      holdingResult,\n      customContext,\n      customCacheBreak,\n      holdPrevious\n    } = _ref6;\n    const cached = getCachedResult({\n      key,\n      cache,\n      args,\n      stores,\n      context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,\n      postActionEnabled,\n      cacheBreakEnabled,\n      fromListener,\n      customCacheBreak\n    });\n\n    if (cached.response) {\n      return cached.response;\n    }\n\n    if (!cache.actions.hasOwnProperty(key)) {\n      const currentActionOrd = actionOrdUpdate(cache, key);\n\n      if (initiate) {\n        if (shortCircuitHook !== undefined) {\n          const shortCircuitResponse = shortCircuitHook({\n            args,\n            stores\n          });\n\n          if (shortCircuitResponse !== false) {\n            runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\n            cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n            return cache.results[key];\n          }\n        }\n\n        if (ssr || !onServer) {\n          cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);\n        }\n\n        if (!onServer) {\n          cache.actions[key]();\n          cache.results[key] = startedButUnfinishedResult;\n        } else {\n          return startedButUnfinishedResult;\n        }\n      } else {\n        const resp = [false, false, {\n          message: \"\",\n          tags: [EAsyncEndTags.UNFINISHED],\n          error: true,\n          payload: null,\n          errorPayload: null\n        }, false, -1];\n\n        if (!onServer) {\n          cache.results[key] = resp;\n        }\n\n        if (holdPrevious) {\n          if (holdingResult) {\n            const response = [...holdingResult];\n            response[3] = true;\n            return response;\n          }\n\n          if (cached.previous != null) {\n            const response = [...cached.previous];\n            response[3] = true;\n            return response;\n          }\n        }\n\n        return resp;\n      }\n    }\n\n    if (holdPrevious) {\n      if (holdingResult) {\n        const response = [...holdingResult];\n        response[3] = true;\n        return response;\n      }\n\n      if (cached.previous != null) {\n        const response = [...cached.previous];\n        response[3] = true;\n        return response;\n      }\n    }\n\n    return startedButUnfinishedResult;\n  }\n\n  const read = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      cacheBreakEnabled = true,\n      postActionEnabled = true,\n      key: customKey\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const key = _createKey(args, customKey);\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    let stores;\n    let customContext;\n\n    if (onServer || forceContext) {\n      const pullstateContext = useContext(PullstateContext);\n      stores = pullstateContext.stores;\n      customContext = pullstateContext.customContext;\n    } else if (clientStores.loaded) {\n      stores = clientStores.stores;\n    } else {\n      stores = storeErrorProxy;\n    }\n\n    const cached = getCachedResult({\n      key,\n      cache,\n      args,\n      stores,\n      context: EPostActionContext.READ_HIT_CACHE,\n      postActionEnabled,\n      cacheBreakEnabled,\n      fromListener: false\n    });\n\n    if (cached.response) {\n      if (!cached.response[2].error) {\n        return cached.response[2].payload;\n      } else {\n        throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);\n      }\n    }\n\n    if (!cache.actions.hasOwnProperty(key)) {\n      if (shortCircuitHook !== undefined) {\n        const shortCircuitResponse = shortCircuitHook({\n          args,\n          stores\n        });\n\n        if (shortCircuitResponse !== false) {\n          runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\n          cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n\n          if (!shortCircuitResponse.error) {\n            return shortCircuitResponse.payload;\n          } else {\n            throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);\n          }\n        }\n      }\n\n      const currentActionOrd = actionOrdUpdate(cache, key);\n      cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);\n\n      if (onServer) {\n        throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\n      }\n\n      throw cache.actions[key]();\n    }\n\n    if (onServer) {\n      throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\n    }\n\n    const watchOrd = watchIdOrd++;\n    throw new Promise(resolve => {\n      cache.listeners[key][watchOrd] = () => {\n        delete cache.listeners[key][watchOrd];\n        resolve();\n      };\n    });\n  };\n\n  const useWatch = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      initiate = false,\n      ssr = true,\n      postActionEnabled = false,\n      cacheBreakEnabled = false,\n      holdPrevious = false,\n      dormant = false,\n      key: customKey,\n      cacheBreak: customCacheBreakIncoming\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const responseRef = useRef();\n    const prevKeyRef = useRef(\".\");\n    const key = dormant ? \".\" : _createKey(args, customKey);\n    let watchId = useRef(-1);\n\n    if (watchId.current === -1) {\n      watchId.current = watchIdOrd++;\n    }\n\n    if (!dormant) {\n      if (!shouldUpdate.hasOwnProperty(key)) {\n        shouldUpdate[key] = {\n          [watchId.current]: true\n        };\n      } else {\n        shouldUpdate[key][watchId.current] = true;\n      }\n    }\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    let stores;\n    let customContext;\n\n    if (onServer || forceContext) {\n      const pullstateContext = useContext(PullstateContext);\n      stores = pullstateContext.stores;\n      customContext = pullstateContext.customContext;\n    } else if (clientStores.loaded) {\n      stores = clientStores.stores;\n    } else {\n      stores = storeErrorProxy;\n    }\n\n    if (!onServer) {\n      const onAsyncStateChanged = () => {\n        if (shouldUpdate[key][watchId.current] && !isEqual(responseRef.current, cache.results[key])) {\n          const nextResponse = checkKeyAndReturnResponse({\n            key,\n            cache,\n            initiate,\n            ssr,\n            args,\n            stores,\n            fromListener: true,\n            postActionEnabled,\n            cacheBreakEnabled,\n            holdingResult: undefined,\n            customContext,\n            holdPrevious\n          });\n\n          if (holdPrevious && !nextResponse[1] && responseRef.current != null && responseRef.current[1]) {\n            responseRef.current = [...responseRef.current];\n            responseRef.current[3] = true;\n          } else {\n            responseRef.current = nextResponse;\n          }\n\n          setWatchUpdate(prev => {\n            return prev + 1;\n          });\n        }\n      };\n\n      if (!dormant) {\n        if (!cache.listeners.hasOwnProperty(key)) {\n          cache.listeners[key] = {};\n        }\n\n        cache.listeners[key][watchId.current] = onAsyncStateChanged;\n        shouldUpdate[key][watchId.current] = true;\n      }\n\n      useEffect(() => {\n        if (!dormant) {\n          cache.listeners[key][watchId.current] = onAsyncStateChanged;\n          shouldUpdate[key][watchId.current] = true;\n        }\n\n        return () => {\n          if (!dormant) {\n            delete cache.listeners[key][watchId.current];\n            shouldUpdate[key][watchId.current] = false;\n          }\n        };\n      }, [key]);\n    }\n\n    const [_, setWatchUpdate] = useState(0);\n\n    if (dormant) {\n      responseRef.current = holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : [false, false, {\n        message: \"\",\n        tags: [EAsyncEndTags.DORMANT],\n        error: true,\n        payload: null\n      }, false, -1];\n      prevKeyRef.current = \".\";\n    } else if (prevKeyRef.current !== key) {\n      if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {\n        delete cache.listeners[prevKeyRef.current][watchId.current];\n        shouldUpdate[prevKeyRef.current][watchId.current] = false;\n      }\n\n      prevKeyRef.current = key;\n      responseRef.current = checkKeyAndReturnResponse({\n        key,\n        cache,\n        initiate,\n        ssr,\n        args,\n        stores,\n        fromListener: false,\n        postActionEnabled,\n        cacheBreakEnabled,\n        holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : undefined,\n        customContext,\n        customCacheBreak: convertCustomCacheBreakHook(customCacheBreakIncoming),\n        holdPrevious\n      });\n    }\n\n    return responseRef.current;\n  };\n\n  const useBeckon = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      ssr = true,\n      postActionEnabled = true,\n      cacheBreakEnabled = true,\n      holdPrevious = false,\n      dormant = false,\n      key\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const result = useWatch(args, {\n      initiate: true,\n      ssr,\n      postActionEnabled,\n      cacheBreakEnabled,\n      holdPrevious,\n      dormant,\n      key\n    });\n    return [result[1], result[2], result[3]];\n  };\n\n  const run = async function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      treatAsUpdate = false,\n      ignoreShortCircuit = false,\n      respectCache = false,\n      key: customKey,\n      _asyncCache = clientAsyncCache,\n      _stores = clientStores.loaded ? clientStores.stores : storeErrorProxy,\n      _customContext,\n      cacheBreak: customCacheBreak\n    } = inputs;\n\n    const key = _createKey(args, customKey);\n\n    if (respectCache) {\n      const cached = getCachedResult({\n        key,\n        cache: _asyncCache,\n        args,\n        stores: _stores,\n        context: EPostActionContext.RUN_HIT_CACHE,\n        postActionEnabled: true,\n        cacheBreakEnabled: true,\n        fromListener: false,\n        customCacheBreak: convertCustomCacheBreakHook(customCacheBreak)\n      });\n\n      if (cached.response && cached.response[0]) {\n        if (!cached.response[1]) {\n          const watchOrd = watchIdOrd++;\n\n          if (!_asyncCache.listeners.hasOwnProperty(key)) {\n            _asyncCache.listeners[key] = {};\n          }\n\n          return new Promise(resolve => {\n            _asyncCache.listeners[key][watchOrd] = () => {\n              const [, finished, resp] = _asyncCache.results[key];\n\n              if (finished) {\n                delete _asyncCache.listeners[key][watchOrd];\n                resolve(resp);\n              }\n            };\n          });\n        }\n\n        return cached.response[2];\n      }\n    }\n\n    if (!ignoreShortCircuit && shortCircuitHook !== undefined) {\n      const shortCircuitResponse = shortCircuitHook({\n        args,\n        stores: _stores\n      });\n\n      if (shortCircuitResponse !== false) {\n        _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n        runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);\n        notifyListeners(key);\n        return shortCircuitResponse;\n      }\n    }\n\n    const [, prevFinished, prevResp, prevUpdate, prevCacheTime] = _asyncCache.results[key] || [false, false, {\n      error: true,\n      message: \"\",\n      payload: null,\n      tags: [EAsyncEndTags.UNFINISHED]\n    }, false, -1];\n\n    if (prevFinished && treatAsUpdate) {\n      _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];\n    } else {\n      _asyncCache.results[key] = [true, false, {\n        error: true,\n        message: \"\",\n        payload: null,\n        tags: [EAsyncEndTags.UNFINISHED]\n      }, false, -1];\n    }\n\n    let currentActionOrd = actionOrdUpdate(_asyncCache, key);\n    _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);\n    notifyListeners(key);\n    return _asyncCache.actions[key]();\n  };\n\n  const clearCache = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      key: customKey,\n      notify = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const key = _createKey(args, customKey);\n\n    clearActionCache(key, true, notify);\n  };\n\n  const clearAllCache = function () {\n    let {\n      notify = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    for (const key of Object.keys(clientAsyncCache.actionOrd)) {\n      if (key.startsWith(`${ordinal}-`)) {\n        clearActionCache(key, true, notify);\n      }\n    }\n  };\n\n  const clearAllUnwatchedCache = function () {\n    let {\n      notify = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    for (const key of Object.keys(shouldUpdate)) {\n      if (!Object.values(shouldUpdate[key]).some(su => su)) {\n        delete shouldUpdate[key];\n        clearActionCache(key, false, notify);\n      }\n    }\n  };\n\n  const setCached = (args, result, options) => {\n    const {\n      notify = true,\n      key: customKey\n    } = options || {};\n\n    const key = _createKey(args, customKey);\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    cache.results[key] = [true, true, result, false, Date.now()];\n\n    if (notify) {\n      notifyListeners(key);\n    }\n  };\n\n  const setCachedPayload = (args, payload, options) => {\n    return setCached(args, successResult(payload), options);\n  };\n\n  const updateCached = (args, updater, options) => {\n    const {\n      notify = true,\n      resetTimeCached = true,\n      runPostActionHook: postAction = false,\n      key: customKey\n    } = options || {};\n\n    const key = _createKey(args, customKey);\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n\n    if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {\n      const currentCached = cache.results[key][2].payload;\n      const newResult = {\n        payload: produce$1(currentCached, s => updater(s, currentCached)),\n        error: false,\n        message: cache.results[key][2].message,\n        tags: cache.results[key][2].tags\n      };\n\n      if (postAction) {\n        runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);\n      }\n\n      cache.results[key] = [true, true, newResult, cache.results[key][3], resetTimeCached ? Date.now() : cache.results[key][4]];\n\n      if (notify) {\n        notifyListeners(key);\n      }\n    }\n  };\n\n  const getCached = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n\n    var _a;\n\n    const {\n      checkCacheBreak = false,\n      key: customKey,\n      cacheBreak: incomingCacheBreak\n    } = options || {};\n\n    const key = _createKey(args, customKey);\n\n    let cacheBreakable = false;\n    const cache = clientAsyncCache;\n\n    if (cache.results.hasOwnProperty(key)) {\n      const finalizedCacheBreakHook = (_a = convertCustomCacheBreakHook(incomingCacheBreak)) !== null && _a !== void 0 ? _a : cacheBreakHook;\n\n      if (checkCacheBreak && finalizedCacheBreakHook !== undefined) {\n        const stores = onServer ? useContext(PullstateContext).stores : clientStores.loaded ? clientStores.stores : storeErrorProxy;\n\n        if (finalizedCacheBreakHook({\n          args,\n          result: cache.results[key][2],\n          stores,\n          timeCached: cache.results[key][4]\n        })) {\n          cacheBreakable = true;\n        }\n      }\n\n      const [started, finished, result, updating, timeCached] = cache.results[key];\n      return {\n        started,\n        finished,\n        result: result,\n        existed: true,\n        cacheBreakable,\n        updating,\n        timeCached\n      };\n    } else {\n      return {\n        started: false,\n        finished: false,\n        result: {\n          message: \"\",\n          tags: [EAsyncEndTags.UNFINISHED],\n          error: true,\n          payload: null,\n          errorPayload: null\n        },\n        updating: false,\n        existed: false,\n        cacheBreakable,\n        timeCached: -1\n      };\n    }\n  };\n\n  let delayedRunActionTimeout;\n\n  const delayedRun = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      clearOldRun = true,\n      delay,\n      immediateIfCached = true,\n      ...otherRunOptions\n    } = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (clearOldRun) {\n      clearTimeout(delayedRunActionTimeout);\n    }\n\n    if (immediateIfCached) {\n      const {\n        finished,\n        cacheBreakable\n      } = getCached(args, {\n        checkCacheBreak: true\n      });\n\n      if (finished && !cacheBreakable) {\n        run(args, otherRunOptions);\n        return () => {};\n      }\n    }\n\n    let ref = {\n      cancelled: false\n    };\n    delayedRunActionTimeout = setTimeout(() => {\n      if (!ref.cancelled) {\n        run(args, otherRunOptions);\n      }\n    }, delay);\n    return () => {\n      ref.cancelled = true;\n    };\n  };\n\n  const use = function () {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      initiate = true,\n      ssr = true,\n      postActionEnabled,\n      cacheBreakEnabled,\n      holdPrevious = false,\n      dormant = false,\n      key,\n      onSuccess,\n      cacheBreak: customCacheBreakHook\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (postActionEnabled == null) {\n      postActionEnabled = initiate;\n    }\n\n    if (cacheBreakEnabled == null) {\n      cacheBreakEnabled = initiate;\n    }\n\n    const raw = useWatch(args, {\n      initiate,\n      ssr,\n      postActionEnabled,\n      cacheBreakEnabled,\n      holdPrevious,\n      dormant,\n      key,\n      cacheBreak: customCacheBreakHook\n    });\n    const [isStarted, isFinished, result, isUpdating] = raw;\n    const isSuccess = isFinished && !result.error;\n    const isFailure = isFinished && result.error;\n\n    if (onSuccess) {\n      useEffect(() => {\n        if (isSuccess && !dormant) {\n          onSuccess(result.payload, args);\n        }\n      }, [isSuccess]);\n    }\n\n    const renderPayload = func => {\n      if (!result.error) {\n        return func(result.payload);\n      }\n\n      return React.Fragment;\n    };\n\n    return {\n      isStarted,\n      isFinished,\n      isUpdating,\n      isSuccess,\n      isFailure,\n      isLoading: isStarted && (!isFinished || isUpdating),\n      endTags: result.tags,\n      error: result.error,\n      payload: result.payload,\n      errorPayload: result.errorPayload,\n      renderPayload,\n      message: result.message,\n      raw,\n      execute: runOptions => run(args, runOptions),\n      clearCached: () => clearCache(args),\n      setCached: (response, options) => {\n        setCached(args, response, options);\n      },\n      setCachedPayload: (payload, options) => {\n        setCachedPayload(args, payload, options);\n      },\n      updateCached: (updater, options) => {\n        updateCached(args, updater, options);\n      }\n    };\n  };\n\n  const useDefer = function () {\n    let inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [argState, setArgState] = useState(() => ({\n      key: inputs.key ? inputs.key : deferWaitingKey,\n      args: {}\n    }));\n    const initialResponse = use({}, { ...inputs,\n      key: argState.key,\n      initiate: false\n    });\n\n    const hasCached = function () {\n      let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a, _b;\n\n      const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\n      const {\n        checkCacheBreak = true,\n        successOnly = false\n      } = options;\n      const cached = getCached(args, {\n        key: executionKey,\n        cacheBreak: (_b = options.cacheBreak) !== null && _b !== void 0 ? _b : inputs.cacheBreak,\n        checkCacheBreak\n      });\n\n      if (cached.existed) {\n        if (!checkCacheBreak || !cached.cacheBreakable) {\n          return !successOnly || !cached.result.error;\n        }\n      }\n\n      return false;\n    };\n\n    const unwatchExecuted = () => {\n      setArgState({\n        key: deferWaitingKey,\n        args: {}\n      });\n    };\n\n    const execute = function () {\n      let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let runOptions = arguments.length > 1 ? arguments[1] : undefined;\n\n      var _a;\n\n      const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\n\n      if (executionKey !== argState.key) {\n        setArgState({\n          key: executionKey,\n          args\n        });\n      }\n\n      return run(args, { ...runOptions,\n        key: executionKey,\n        cacheBreak: inputs.cacheBreak\n      }).then(resp => {\n        if (inputs.clearOnSuccess) {\n          clearCache({}, {\n            key: executionKey\n          });\n        }\n\n        return resp;\n      });\n    };\n\n    return { ...initialResponse,\n      clearCached: () => {\n        clearCache({}, {\n          key: argState.key\n        });\n      },\n      unwatchExecuted,\n      setCached: function (response) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        options.key = argState.key;\n        setCached({}, response, options);\n      },\n      setCachedPayload: function (payload) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        options.key = argState.key;\n        setCachedPayload({}, payload, options);\n      },\n      updateCached: function (updater) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        options.key = argState.key;\n        updateCached({}, updater, options);\n      },\n      useDebouncedExecution: function (args, delay) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (!onServer) {\n          const stateRef = useRef({\n            update: false\n          });\n          const currentValue = useRef(undefined);\n          const executionOrd = useRef(-1);\n          const timeout = useRef(undefined);\n          useEffect(() => {\n            stateRef.current.update = true;\n            return () => {\n              stateRef.current.update = false;\n            };\n          }, []);\n          const hasEqualityCheck = options.equality != null;\n\n          if (hasEqualityCheck) {\n            if (typeof options.equality === \"function\") {\n              if (currentValue.current === undefined || options.equality(currentValue.current, args)) {\n                currentValue.current = args;\n                executionOrd.current += 1;\n              }\n            } else if (currentValue.current !== options.equality) {\n              currentValue.current = options.equality;\n              executionOrd.current += 1;\n            }\n          } else if (!isEqual(currentValue.current, args)) {\n            currentValue.current = args;\n            executionOrd.current += 1;\n          }\n\n          useEffect(() => {\n            var _a, _b, _c;\n\n            clearTimeout(timeout.current);\n\n            const executeAction = () => {\n              var _a;\n\n              if (stateRef.current.update) {\n                execute(args, (_a = options.executeOptions) !== null && _a !== void 0 ? _a : {\n                  respectCache: true\n                });\n              }\n            };\n\n            if ((_b = (_a = options.validInput) === null || _a === void 0 ? void 0 : _a.call(options, args)) !== null && _b !== void 0 ? _b : true) {\n              if (hasCached(args)) {\n                executeAction();\n              } else {\n                timeout.current = setTimeout(executeAction, delay);\n              }\n            } else if (!((_c = options.watchLastValid) !== null && _c !== void 0 ? _c : false)) {\n              unwatchExecuted();\n            }\n          }, [executionOrd.current]);\n        }\n      },\n      hasCached,\n      execute,\n      args: argState.args,\n      key: argState.key\n    };\n  };\n\n  return {\n    use,\n    useDefer,\n    read,\n    useBeckon,\n    useWatch,\n    run,\n    delayedRun,\n    clearCache,\n    clearAllCache,\n    clearAllUnwatchedCache,\n    getCached,\n    setCached,\n    setCachedPayload,\n    updateCached\n  };\n}\n\nconst PullstateContext = React.createContext(null);\n\nconst PullstateProvider = _ref7 => {\n  let {\n    instance,\n    children\n  } = _ref7;\n  return React.createElement(PullstateContext.Provider, {\n    value: instance\n  }, children);\n};\n\nlet singleton = null;\nconst clientStores = {\n  internalClientStores: true,\n  loaded: false,\n  stores: {}\n};\n\nclass PullstateSingleton {\n  constructor(allStores) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.options = {};\n\n    if (singleton !== null) {\n      console.error(`Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.`);\n    }\n\n    singleton = this;\n    clientStores.stores = allStores;\n    clientStores.loaded = true;\n    this.options = options;\n  }\n\n  instantiate() {\n    let {\n      hydrateSnapshot,\n      ssr = false,\n      customContext\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!ssr) {\n      const instantiated = new PullstateInstance(clientStores.stores, false, customContext);\n\n      if (hydrateSnapshot != null) {\n        instantiated.hydrateFromSnapshot(hydrateSnapshot);\n      }\n\n      instantiated.instantiateReactions();\n      return instantiated;\n    }\n\n    const newStores = {};\n\n    for (const storeName of Object.keys(clientStores.stores)) {\n      if (hydrateSnapshot == null) {\n        newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\n      } else if (hydrateSnapshot.hasOwnProperty(storeName)) {\n        newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);\n      } else {\n        newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\n        console.warn(`Pullstate (instantiate): store [${storeName}] didn't hydrate any state (data was non-existent on hydration object)`);\n      }\n\n      newStores[storeName]._setInternalOptions({\n        ssr,\n        reactionCreators: clientStores.stores[storeName]._getReactionCreators()\n      });\n    }\n\n    return new PullstateInstance(newStores, true, customContext);\n  }\n\n  useStores() {\n    return useStores();\n  }\n\n  useInstance() {\n    return useInstance();\n  }\n\n  createAsyncActionDirect(action) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return createAsyncActionDirect(action, options);\n  }\n\n  createAsyncAction(action) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {\n      options.cacheBreakHook = inputs => inputs.timeCached < Date.now() - this.options.asyncActions.defaultCachingSeconds * 1000;\n    }\n\n    return createAsyncAction(action, options);\n  }\n\n}\n\nclass PullstateInstance {\n  constructor(allStores, ssr, customContext) {\n    this._ssr = false;\n    this._stores = {};\n    this._asyncCache = {\n      listeners: {},\n      results: {},\n      actions: {},\n      actionOrd: {}\n    };\n    this._stores = allStores;\n    this._ssr = ssr;\n    this._customContext = customContext;\n  }\n\n  getAllUnresolvedAsyncActions() {\n    return Object.keys(this._asyncCache.actions).map(key => this._asyncCache.actions[key]());\n  }\n\n  instantiateReactions() {\n    for (const storeName of Object.keys(this._stores)) {\n      this._stores[storeName]._instantiateReactions();\n    }\n  }\n\n  getPullstateSnapshot() {\n    const allState = {};\n\n    for (const storeName of Object.keys(this._stores)) {\n      allState[storeName] = this._stores[storeName].getRawState();\n    }\n\n    return {\n      allState,\n      asyncResults: this._asyncCache.results,\n      asyncActionOrd: this._asyncCache.actionOrd\n    };\n  }\n\n  async resolveAsyncState() {\n    const promises = this.getAllUnresolvedAsyncActions();\n    await Promise.all(promises);\n  }\n\n  hasAsyncStateToResolve() {\n    return Object.keys(this._asyncCache.actions).length > 0;\n  }\n\n  get stores() {\n    return this._stores;\n  }\n\n  get customContext() {\n    return this._customContext;\n  }\n\n  async runAsyncAction(asyncAction) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let runOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (this._ssr) {\n      runOptions._asyncCache = this._asyncCache;\n      runOptions._stores = this._stores;\n      runOptions._customContext = this._customContext;\n    }\n\n    return await asyncAction.run(args, runOptions);\n  }\n\n  hydrateFromSnapshot(snapshot) {\n    for (const storeName of Object.keys(this._stores)) {\n      if (snapshot.allState.hasOwnProperty(storeName)) {\n        this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);\n      } else {\n        console.warn(`${storeName} didn't hydrate any state (data was non-existent on hydration object)`);\n      }\n    }\n\n    clientAsyncCache.results = snapshot.asyncResults || {};\n    clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};\n  }\n\n}\n\nfunction createPullstateCore() {\n  let allStores = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new PullstateSingleton(allStores, options);\n}\n\nfunction useStores() {\n  return useContext(PullstateContext).stores;\n}\n\nfunction useInstance() {\n  return useContext(PullstateContext);\n}\n\nvar EAsyncActionInjectType;\n\n(function (EAsyncActionInjectType) {\n  EAsyncActionInjectType[\"WATCH\"] = \"watch\";\n  EAsyncActionInjectType[\"BECKON\"] = \"beckon\";\n})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));\n\nfunction InjectAsyncAction(props) {\n  if (props.type === EAsyncActionInjectType.BECKON) {\n    const response = props.action.useBeckon(props.args, props.options);\n    return props.children(response);\n  }\n\n  const response = props.action.useWatch(props.args, props.options);\n  return props.children(response);\n}\n\nfunction InjectStoreStateOpt(_ref8) {\n  let {\n    store,\n    paths,\n    children\n  } = _ref8;\n  const state = useStoreStateOpt(store, paths);\n  return children(state);\n}\n\nfunction registerInDevtools(stores) {\n  let {\n    namespace = \"\"\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  const devToolsExtension = typeof window !== \"undefined\" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : undefined;\n\n  if (devToolsExtension) {\n    for (const key of Object.keys(stores)) {\n      const store = stores[key];\n      const devTools = devToolsExtension.connect({\n        name: `${namespace}${key}`\n      });\n      devTools.init(store.getRawState());\n      let ignoreNext = false;\n      store.subscribe(s => s, watched => {\n        if (ignoreNext) {\n          ignoreNext = false;\n          return;\n        }\n\n        devTools.send(\"Change\", watched);\n      });\n      devTools.subscribe(message => {\n        if (message.type === \"DISPATCH\" && message.state) {\n          ignoreNext = true;\n          const parsed = JSON.parse(message.state);\n          store.replace(parsed);\n        }\n      });\n    }\n  }\n}\n\nconst batchState = {};\n\nfunction setupBatch(_ref9) {\n  let {\n    uiBatchFunction\n  } = _ref9;\n  batchState.uiBatchFunction = uiBatchFunction;\n}\n\nfunction batch(runUpdates) {\n  if (globalClientState.batching) {\n    throw new Error(\"Pullstate: Can't enact two batch() update functions at the same time-\\n\" + \"make sure you are not running a batch() inside of a batch() by mistake.\");\n  }\n\n  globalClientState.batching = true;\n\n  try {\n    runUpdates();\n  } finally {\n    if (batchState.uiBatchFunction) {\n      batchState.uiBatchFunction(() => {\n        Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\n      });\n    } else {\n      Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\n    }\n\n    globalClientState.flushStores = {};\n    globalClientState.batching = false;\n  }\n}\n\nexport { EAsyncActionInjectType, EAsyncEndTags, EPostActionContext, InjectAsyncAction, InjectStoreState, InjectStoreStateOpt, PullstateContext, PullstateProvider, Store, batch, createAsyncAction, createAsyncActionDirect, createPullstateCore, errorResult, registerInDevtools, setupBatch, successResult, update, useInstance, useLocalStore, useStoreState, useStoreStateOpt, useStores };","map":{"version":3,"sources":["/Users/zohebshahzan/code/Solana-2/frontend/node_modules/pullstate/dist/index.es.js"],"names":["isEqual","React","useRef","useState","useEffect","useContext","produce$1","enablePatches","produceWithPatches","produce","applyPatches","useStoreState","store","getSubState","deps","updateRef","state","undefined","initialized","current","getRawState","setUpdateTrigger","effectState","shouldUpdate","update","nextSubState","val","_addUpdateListener","_removeUpdateListener","prevDeps","updateListenerOrd","fastGet","obj","path","reduce","cur","key","getSubStateFromPaths","paths","resp","push","useStoreStateOpt","subState","setSubState","onStoreUpdate","currentSubState","ordKey","onStoreUpdateOpt","_addUpdateListenerOpt","_removeUpdateListenerOpt","useLocalStore","initialState","storeRef","Store","globalClientState","storeOrdinal","batching","flushStores","makeSubscriptionFunction","watch","listener","lastWatchState","currentState","nextWatchState","makeReactionFunctionCreator","reaction","forceRun","_optListenerCount","nextState","patches","inversePatches","s","_updateStateWithoutReaction","length","_patchListeners","forEach","Object","keys","getChangedPathsFromPatches","optPathDivider","constructor","updateListeners","ssr","reactions","clientSubscriptions","reactionCreators","optimizedUpdateListeners","optimizedUpdateListenerPaths","optimizedListenerPropertyMap","Function","createInitialState","internalOrdId","_setInternalOptions","map","rc","_getReactionCreators","_instantiateReactions","_getInitialState","_updateState","updateKeyedPaths","batchState","runReaction","runSubscription","updateOrds","Set","keyedPath","ord","add","values","listenerPathsKeyed","join","filter","f","listenToPatches","patchListener","subscribe","func","console","warn","createReaction","runNow","runNowWithSideEffects","creator","useLocalCopyInitial","useLocalCopySnapshot","flushBatch","ignoreError","error","updater","patchesCallback","runUpdates","replace","newState","applyPatchesToStore","changePatches","prev","patch","curKey","p","currentValue","ns","previousValue","currentUpdater","InjectStoreState","on","children","EAsyncEndTags","EPostActionContext","clientAsyncCache","listeners","results","actions","actionOrd","asyncCreationOrdinal","keyFromObject","json","typeOf","prefix","sort","notifyListeners","hasOwnProperty","watchId","clearActionCache","clearPending","notify","actionOrdUpdate","cache","successResult","payload","tags","message","errorPayload","errorResult","RETURNED_ERROR","PullstateAsyncError","Error","storeErrorProxy","Proxy","get","prop","String","startedButUnfinishedResult","UNFINISHED","createAsyncActionDirect","action","options","createAsyncAction","args","stores","customContext","convertCustomCacheBreakHook","cacheBreakHook","timeCached","result","Date","now","forceContext","shortCircuitHook","postActionHook","subsetKey","actionId","ordinal","onServer","window","_createKey","customKey","deferWaitingKey","cacheBreakWatcher","watchIdOrd","runPostActionHook","context","getCachedResult","cacheBreakEnabled","fromListener","postActionEnabled","customCacheBreak","useCacheBreakHook","cacheBreakLoop","previous","cacheBroke","response","createInternalAction","currentActionOrd","executionContext","then","catch","e","THREW_ERROR","checkKeyAndReturnResponse","initiate","holdingResult","holdPrevious","cached","BECKON_HIT_CACHE","WATCH_HIT_CACHE","shortCircuitResponse","SHORT_CIRCUIT","BECKON_RUN","read","PullstateContext","_asyncCache","pullstateContext","clientStores","loaded","READ_HIT_CACHE","READ_RUN","watchOrd","Promise","resolve","useWatch","dormant","cacheBreak","customCacheBreakIncoming","responseRef","prevKeyRef","onAsyncStateChanged","nextResponse","setWatchUpdate","_","DORMANT","useBeckon","run","inputs","treatAsUpdate","ignoreShortCircuit","respectCache","_stores","_customContext","RUN_HIT_CACHE","finished","prevFinished","prevResp","prevUpdate","prevCacheTime","DIRECT_RUN","clearCache","clearAllCache","startsWith","clearAllUnwatchedCache","some","su","setCached","setCachedPayload","updateCached","resetTimeCached","postAction","currentCached","newResult","CACHE_UPDATE","getCached","_a","checkCacheBreak","incomingCacheBreak","cacheBreakable","finalizedCacheBreakHook","started","updating","existed","delayedRunActionTimeout","delayedRun","clearOldRun","delay","immediateIfCached","otherRunOptions","clearTimeout","ref","cancelled","setTimeout","use","onSuccess","customCacheBreakHook","raw","isStarted","isFinished","isUpdating","isSuccess","isFailure","renderPayload","Fragment","isLoading","endTags","execute","runOptions","clearCached","useDefer","argState","setArgState","initialResponse","hasCached","_b","executionKey","successOnly","unwatchExecuted","clearOnSuccess","useDebouncedExecution","stateRef","executionOrd","timeout","hasEqualityCheck","equality","_c","executeAction","executeOptions","validInput","call","watchLastValid","createContext","PullstateProvider","instance","createElement","Provider","value","singleton","internalClientStores","PullstateSingleton","allStores","instantiate","hydrateSnapshot","instantiated","PullstateInstance","hydrateFromSnapshot","instantiateReactions","newStores","storeName","allState","useStores","useInstance","asyncActions","defaultCachingSeconds","_ssr","getAllUnresolvedAsyncActions","getPullstateSnapshot","asyncResults","asyncActionOrd","resolveAsyncState","promises","all","hasAsyncStateToResolve","runAsyncAction","asyncAction","snapshot","createPullstateCore","EAsyncActionInjectType","InjectAsyncAction","props","type","BECKON","InjectStoreStateOpt","registerInDevtools","namespace","devToolsExtension","__REDUX_DEVTOOLS_EXTENSION__","devTools","connect","name","init","ignoreNext","watched","send","parsed","JSON","parse","setupBatch","uiBatchFunction","batch"],"mappings":"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","sourcesContent":["import isEqual from'fast-deep-equal/es6';import React,{useRef,useState,useEffect,useContext}from'react';import produce$1,{enablePatches,produceWithPatches,produce,applyPatches}from'immer';function useStoreState(store, getSubState, deps) {\r\n    const updateRef = useRef({ state: undefined, initialized: false });\r\n    if (!updateRef.current.initialized) {\r\n        updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();\r\n        updateRef.current.initialized = true;\r\n    }\r\n    const [, setUpdateTrigger] = useState(0);\r\n    useEffect(() => {\r\n        const effectState = { shouldUpdate: true };\r\n        function update() {\r\n            if (effectState.shouldUpdate) {\r\n                const nextSubState = getSubState\r\n                    ? getSubState(store.getRawState())\r\n                    : store.getRawState();\r\n                if (!isEqual(updateRef.current.state, nextSubState)) {\r\n                    if (effectState.shouldUpdate) {\r\n                        updateRef.current.state = nextSubState;\r\n                        setUpdateTrigger((val) => val + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        store._addUpdateListener(update);\r\n        update();\r\n        return () => {\r\n            effectState.shouldUpdate = false;\r\n            store._removeUpdateListener(update);\r\n        };\r\n    }, deps !== null && deps !== void 0 ? deps : []);\r\n    if (deps !== undefined) {\r\n        const prevDeps = useRef(deps);\r\n        if (!isEqual(deps, prevDeps)) {\r\n            updateRef.current.state = getSubState(store.getRawState());\r\n        }\r\n    }\r\n    return updateRef.current.state;\r\n}let updateListenerOrd = 0;\r\nfunction fastGet(obj, path) {\r\n    return path.reduce((cur = obj, key) => {\r\n        return cur[key];\r\n    }, undefined);\r\n}\r\nfunction getSubStateFromPaths(store, paths) {\r\n    const state = store.getRawState();\r\n    const resp = [];\r\n    for (const path of paths) {\r\n        resp.push(fastGet(state, path));\r\n    }\r\n    return resp;\r\n}\r\nfunction useStoreStateOpt(store, paths) {\r\n    const [subState, setSubState] = useState(() => getSubStateFromPaths(store, paths));\r\n    const updateRef = useRef({\r\n        shouldUpdate: true,\r\n        onStoreUpdate: null,\r\n        currentSubState: null,\r\n        ordKey: `_${updateListenerOrd++}`,\r\n    });\r\n    updateRef.current.currentSubState = subState;\r\n    if (updateRef.current.onStoreUpdate === null) {\r\n        updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {\r\n            if (updateRef.current.shouldUpdate) {\r\n                setSubState(getSubStateFromPaths(store, paths));\r\n            }\r\n        };\r\n        store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);\r\n    }\r\n    useEffect(() => () => {\r\n        updateRef.current.shouldUpdate = false;\r\n        store._removeUpdateListenerOpt(updateRef.current.ordKey);\r\n    }, []);\r\n    return subState;\r\n}function useLocalStore(initialState, deps) {\r\n    const storeRef = useRef();\r\n    if (storeRef.current == null) {\r\n        storeRef.current = new Store(initialState);\r\n    }\r\n    if (deps !== undefined) {\r\n        const prevDeps = useRef(deps);\r\n        if (!isEqual(deps, prevDeps)) {\r\n            storeRef.current = new Store(initialState);\r\n        }\r\n    }\r\n    return storeRef.current;\r\n}const globalClientState = {\r\n    storeOrdinal: 0,\r\n    batching: false,\r\n    flushStores: {}\r\n};enablePatches();\r\nfunction makeSubscriptionFunction(store, watch, listener) {\r\n    let lastWatchState = watch(store.getRawState());\r\n    return () => {\r\n        const currentState = store.getRawState();\r\n        const nextWatchState = watch(currentState);\r\n        if (!isEqual(nextWatchState, lastWatchState)) {\r\n            listener(nextWatchState, currentState, lastWatchState);\r\n            lastWatchState = nextWatchState;\r\n        }\r\n    };\r\n}\r\nfunction makeReactionFunctionCreator(watch, reaction) {\r\n    return (store) => {\r\n        let lastWatchState = watch(store.getRawState());\r\n        return (forceRun = false) => {\r\n            const currentState = store.getRawState();\r\n            const nextWatchState = watch(currentState);\r\n            if (forceRun || !isEqual(nextWatchState, lastWatchState)) {\r\n                if (store._optListenerCount > 0) {\r\n                    const [nextState, patches, inversePatches] = produceWithPatches(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState));\r\n                    store._updateStateWithoutReaction(nextState);\r\n                    lastWatchState = nextWatchState;\r\n                    if (patches.length > 0) {\r\n                        store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n                        return Object.keys(getChangedPathsFromPatches(patches));\r\n                    }\r\n                }\r\n                else {\r\n                    if (store._patchListeners.length > 0) {\r\n                        const [nextState, patches, inversePatches] = produceWithPatches(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState));\r\n                        if (patches.length > 0) {\r\n                            store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n                        }\r\n                        store._updateStateWithoutReaction(nextState);\r\n                    }\r\n                    else {\r\n                        store._updateStateWithoutReaction(produce(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState)));\r\n                    }\r\n                    lastWatchState = nextWatchState;\r\n                }\r\n            }\r\n            return [];\r\n        };\r\n    };\r\n}\r\nconst optPathDivider = \"~._.~\";\r\nclass Store {\r\n    constructor(initialState) {\r\n        this.updateListeners = [];\r\n        this.ssr = false;\r\n        this.reactions = [];\r\n        this.clientSubscriptions = [];\r\n        this.reactionCreators = [];\r\n        this.optimizedUpdateListeners = {};\r\n        this.optimizedUpdateListenerPaths = {};\r\n        this.optimizedListenerPropertyMap = {};\r\n        this._optListenerCount = 0;\r\n        this._patchListeners = [];\r\n        if (initialState instanceof Function) {\r\n            const state = initialState();\r\n            this.currentState = state;\r\n            this.initialState = state;\r\n            this.createInitialState = initialState;\r\n        }\r\n        else {\r\n            this.currentState = initialState;\r\n            this.initialState = initialState;\r\n            this.createInitialState = () => initialState;\r\n        }\r\n        this.internalOrdId = globalClientState.storeOrdinal++;\r\n    }\r\n    _setInternalOptions({ ssr, reactionCreators = [] }) {\r\n        this.ssr = ssr;\r\n        this.reactionCreators = reactionCreators;\r\n        this.reactions = reactionCreators.map((rc) => rc(this));\r\n    }\r\n    _getReactionCreators() {\r\n        return this.reactionCreators;\r\n    }\r\n    _instantiateReactions() {\r\n        this.reactions = this.reactionCreators.map((rc) => rc(this));\r\n    }\r\n    _getInitialState() {\r\n        return this.createInitialState();\r\n    }\r\n    _updateStateWithoutReaction(nextState) {\r\n        this.currentState = nextState;\r\n    }\r\n    _updateState(nextState, updateKeyedPaths = []) {\r\n        this.currentState = nextState;\r\n        this.batchState = undefined;\r\n        for (const runReaction of this.reactions) {\r\n            updateKeyedPaths.push(...runReaction());\r\n        }\r\n        if (!this.ssr) {\r\n            for (const runSubscription of this.clientSubscriptions) {\r\n                runSubscription();\r\n            }\r\n            if (updateKeyedPaths.length > 0) {\r\n                const updateOrds = new Set();\r\n                for (const keyedPath of updateKeyedPaths) {\r\n                    if (this.optimizedListenerPropertyMap[keyedPath]) {\r\n                        for (const ord of this.optimizedListenerPropertyMap[keyedPath]) {\r\n                            updateOrds.add(ord);\r\n                        }\r\n                    }\r\n                }\r\n                for (const ord of updateOrds.values()) {\r\n                    if (this.optimizedUpdateListeners[ord]) {\r\n                        this.optimizedUpdateListeners[ord]();\r\n                    }\r\n                }\r\n            }\r\n            this.updateListeners.forEach((listener) => listener());\r\n        }\r\n    }\r\n    _addUpdateListener(listener) {\r\n        this.updateListeners.push(listener);\r\n    }\r\n    _addUpdateListenerOpt(listener, ordKey, paths) {\r\n        this.optimizedUpdateListeners[ordKey] = listener;\r\n        const listenerPathsKeyed = paths.map((path) => path.join(optPathDivider));\r\n        this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;\r\n        for (const keyedPath of listenerPathsKeyed) {\r\n            if (this.optimizedListenerPropertyMap[keyedPath] == null) {\r\n                this.optimizedListenerPropertyMap[keyedPath] = [ordKey];\r\n            }\r\n            else {\r\n                this.optimizedListenerPropertyMap[keyedPath].push(ordKey);\r\n            }\r\n        }\r\n        this._optListenerCount++;\r\n    }\r\n    _removeUpdateListener(listener) {\r\n        this.updateListeners = this.updateListeners.filter((f) => f !== listener);\r\n    }\r\n    _removeUpdateListenerOpt(ordKey) {\r\n        const listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];\r\n        for (const keyedPath of listenerPathsKeyed) {\r\n            this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter((ord) => ord !== ordKey);\r\n        }\r\n        delete this.optimizedUpdateListenerPaths[ordKey];\r\n        delete this.optimizedUpdateListeners[ordKey];\r\n        this._optListenerCount--;\r\n    }\r\n    listenToPatches(patchListener) {\r\n        this._patchListeners.push(patchListener);\r\n        return () => {\r\n            this._patchListeners = this._patchListeners.filter((f) => f !== patchListener);\r\n        };\r\n    }\r\n    subscribe(watch, listener) {\r\n        if (!this.ssr) {\r\n            const func = makeSubscriptionFunction(this, watch, listener);\r\n            this.clientSubscriptions.push(func);\r\n            return () => {\r\n                this.clientSubscriptions = this.clientSubscriptions.filter((f) => f !== func);\r\n            };\r\n        }\r\n        return () => {\r\n            console.warn(`Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.`);\r\n        };\r\n    }\r\n    createReaction(watch, reaction, { runNow = false, runNowWithSideEffects = false } = {}) {\r\n        const creator = makeReactionFunctionCreator(watch, reaction);\r\n        this.reactionCreators.push(creator);\r\n        const func = creator(this);\r\n        this.reactions.push(func);\r\n        if (runNow || runNowWithSideEffects) {\r\n            func(true);\r\n            if (runNowWithSideEffects && !this.ssr) {\r\n                this._updateState(this.currentState);\r\n            }\r\n        }\r\n        return () => {\r\n            this.reactions = this.reactions.filter((f) => f !== func);\r\n        };\r\n    }\r\n    getRawState() {\r\n        if (this.batchState !== undefined) {\r\n            return this.batchState;\r\n        }\r\n        else {\r\n            return this.currentState;\r\n        }\r\n    }\r\n    useState(getSubState, deps) {\r\n        return useStoreState(this, getSubState, deps);\r\n    }\r\n    useLocalCopyInitial(deps) {\r\n        return useLocalStore(this.createInitialState, deps);\r\n    }\r\n    useLocalCopySnapshot(deps) {\r\n        return useLocalStore(this.currentState, deps);\r\n    }\r\n    flushBatch(ignoreError = false) {\r\n        if (this.batchState !== undefined) {\r\n            if (this.batchState !== this.currentState) {\r\n                this._updateState(this.batchState);\r\n            }\r\n        }\r\n        else if (!ignoreError) {\r\n            console.error(`Pullstate: Trying to flush batch state which was never created or updated on`);\r\n        }\r\n        this.batchState = undefined;\r\n    }\r\n    update(updater, patchesCallback) {\r\n        if (globalClientState.batching) {\r\n            if (this.batchState === undefined) {\r\n                this.batchState = this.currentState;\r\n                globalClientState.flushStores[this.internalOrdId] = this;\r\n            }\r\n            const func = typeof updater === \"function\";\r\n            const [nextState, patches, inversePatches] = runUpdates(this.batchState, updater, func);\r\n            if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {\r\n                if (patchesCallback) {\r\n                    patchesCallback(patches, inversePatches);\r\n                }\r\n                this._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            }\r\n            this.batchState = nextState;\r\n        }\r\n        else {\r\n            this.batchState = undefined;\r\n            update(this, updater, patchesCallback);\r\n        }\r\n    }\r\n    replace(newState) {\r\n        this._updateState(newState);\r\n    }\r\n    applyPatches(patches) {\r\n        applyPatchesToStore(this, patches);\r\n    }\r\n}\r\nfunction applyPatchesToStore(store, patches) {\r\n    const currentState = store.getRawState();\r\n    const nextState = applyPatches(currentState, patches);\r\n    if (nextState !== currentState) {\r\n        store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\r\n    }\r\n}\r\nfunction getChangedPathsFromPatches(changePatches, prev = {}) {\r\n    for (const patch of changePatches) {\r\n        let curKey;\r\n        for (const p of patch.path) {\r\n            if (curKey) {\r\n                curKey = `${curKey}${optPathDivider}${p}`;\r\n            }\r\n            else {\r\n                curKey = p;\r\n            }\r\n            prev[curKey] = 1;\r\n        }\r\n    }\r\n    return prev;\r\n}\r\nfunction runUpdates(currentState, updater, func) {\r\n    return func\r\n        ? produceWithPatches(currentState, (s) => updater(s, currentState))\r\n        : updater.reduce(([nextState, patches, inversePatches], currentValue) => {\r\n            const resp = produceWithPatches(nextState, (s) => currentValue(s, nextState));\r\n            patches.push(...resp[1]);\r\n            inversePatches.push(...resp[2]);\r\n            return [resp[0], patches, inversePatches];\r\n        }, [currentState, [], []]);\r\n}\r\nfunction update(store, updater, patchesCallback) {\r\n    const currentState = store.getRawState();\r\n    const func = typeof updater === \"function\";\r\n    if (store._optListenerCount > 0) {\r\n        const [nextState, patches, inversePatches] = runUpdates(currentState, updater, func);\r\n        if (patches.length > 0) {\r\n            if (patchesCallback) {\r\n                patchesCallback(patches, inversePatches);\r\n            }\r\n            store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\r\n        }\r\n    }\r\n    else {\r\n        let nextState;\r\n        if (store._patchListeners.length > 0 || patchesCallback) {\r\n            const [ns, patches, inversePatches] = runUpdates(currentState, updater, func);\r\n            if (patches.length > 0) {\r\n                if (patchesCallback) {\r\n                    patchesCallback(patches, inversePatches);\r\n                }\r\n                store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            }\r\n            nextState = ns;\r\n        }\r\n        else {\r\n            nextState = produce(currentState, (s) => func\r\n                ? updater(s, currentState)\r\n                : updater.reduce((previousValue, currentUpdater) => {\r\n                    return produce(previousValue, (s) => currentUpdater(s, previousValue));\r\n                }, currentState));\r\n        }\r\n        if (nextState !== currentState) {\r\n            store._updateState(nextState);\r\n        }\r\n    }\r\n}function InjectStoreState({ store, on = s => s, children, }) {\r\n    const state = useStoreState(store, on);\r\n    return children(state);\r\n}var EAsyncEndTags;\r\n(function (EAsyncEndTags) {\r\n    EAsyncEndTags[\"THREW_ERROR\"] = \"THREW_ERROR\";\r\n    EAsyncEndTags[\"RETURNED_ERROR\"] = \"RETURNED_ERROR\";\r\n    EAsyncEndTags[\"UNFINISHED\"] = \"UNFINISHED\";\r\n    EAsyncEndTags[\"DORMANT\"] = \"DORMANT\";\r\n})(EAsyncEndTags || (EAsyncEndTags = {}));\r\nvar EPostActionContext;\r\n(function (EPostActionContext) {\r\n    EPostActionContext[\"WATCH_HIT_CACHE\"] = \"WATCH_HIT_CACHE\";\r\n    EPostActionContext[\"BECKON_HIT_CACHE\"] = \"BECKON_HIT_CACHE\";\r\n    EPostActionContext[\"RUN_HIT_CACHE\"] = \"RUN_HIT_CACHE\";\r\n    EPostActionContext[\"READ_HIT_CACHE\"] = \"READ_HIT_CACHE\";\r\n    EPostActionContext[\"READ_RUN\"] = \"READ_RUN\";\r\n    EPostActionContext[\"SHORT_CIRCUIT\"] = \"SHORT_CIRCUIT\";\r\n    EPostActionContext[\"DIRECT_RUN\"] = \"DIRECT_RUN\";\r\n    EPostActionContext[\"BECKON_RUN\"] = \"BECKON_RUN\";\r\n    EPostActionContext[\"CACHE_UPDATE\"] = \"CACHE_UPDATE\";\r\n})(EPostActionContext || (EPostActionContext = {}));const clientAsyncCache = {\r\n    listeners: {},\r\n    results: {},\r\n    actions: {},\r\n    actionOrd: {}\r\n};\r\nlet asyncCreationOrdinal = 0;\r\nfunction keyFromObject(json) {\r\n    if (json === null) {\r\n        return \"(n)\";\r\n    }\r\n    const typeOf = typeof json;\r\n    if (typeOf !== \"object\") {\r\n        if (typeOf === \"undefined\") {\r\n            return \"(u)\";\r\n        }\r\n        else if (typeOf === \"string\") {\r\n            return \":\" + json + \";\";\r\n        }\r\n        else if (typeOf === \"boolean\" || typeOf === \"number\") {\r\n            return \"(\" + json + \")\";\r\n        }\r\n    }\r\n    let prefix = \"{\";\r\n    for (const key of Object.keys(json).sort()) {\r\n        prefix += key + keyFromObject(json[key]);\r\n    }\r\n    return prefix + \"}\";\r\n}\r\nfunction notifyListeners(key) {\r\n    if (clientAsyncCache.listeners.hasOwnProperty(key)) {\r\n        for (const watchId of Object.keys(clientAsyncCache.listeners[key])) {\r\n            clientAsyncCache.listeners[key][watchId]();\r\n        }\r\n    }\r\n}\r\nfunction clearActionCache(key, clearPending = true, notify = true) {\r\n    if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {\r\n        clientAsyncCache.actionOrd[key] += 1;\r\n    }\r\n    delete clientAsyncCache.results[key];\r\n    if (notify) {\r\n        notifyListeners(key);\r\n    }\r\n}\r\nfunction actionOrdUpdate(cache, key) {\r\n    if (!cache.actionOrd.hasOwnProperty(key)) {\r\n        cache.actionOrd[key] = 0;\r\n    }\r\n    else {\r\n        cache.actionOrd[key] += 1;\r\n    }\r\n    return cache.actionOrd[key];\r\n}\r\nfunction successResult(payload = null, tags = [], message = \"\") {\r\n    return {\r\n        payload,\r\n        tags,\r\n        message,\r\n        error: false,\r\n        errorPayload: null\r\n    };\r\n}\r\nfunction errorResult(tags = [], message = \"\", errorPayload) {\r\n    return {\r\n        payload: null,\r\n        tags: [EAsyncEndTags.RETURNED_ERROR, ...tags],\r\n        message,\r\n        error: true,\r\n        errorPayload: errorPayload\r\n    };\r\n}\r\nclass PullstateAsyncError extends Error {\r\n    constructor(message, tags) {\r\n        super(message);\r\n        this.tags = tags;\r\n    }\r\n}\r\nlet storeErrorProxy;\r\ntry {\r\n    storeErrorProxy = new Proxy({}, {\r\n        get: function (obj, prop) {\r\n            throw new Error(`Pullstate: Trying to access store (${String(prop)}) inside async actions without the correct usage or setup.\r\nIf this error occurred on the server:\r\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\r\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\r\n\r\nIf this error occurred on the client:\r\n* Make sure you have created your \"pullstateCore\" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`);\r\n        }\r\n    });\r\n}\r\ncatch {\r\n    storeErrorProxy = {};\r\n}\r\nconst startedButUnfinishedResult = [\r\n    true,\r\n    false,\r\n    {\r\n        message: \"\",\r\n        tags: [EAsyncEndTags.UNFINISHED],\r\n        error: true,\r\n        payload: null,\r\n        errorPayload: null\r\n    },\r\n    false,\r\n    -1\r\n];\r\nfunction createAsyncActionDirect(action, options = {}) {\r\n    return createAsyncAction(async (args, stores, customContext) => {\r\n        return successResult(await action(args, stores, customContext));\r\n    }, options);\r\n}\r\nfunction convertCustomCacheBreakHook(cacheBreakHook) {\r\n    if (cacheBreakHook != null) {\r\n        if (typeof cacheBreakHook === \"boolean\") {\r\n            return () => cacheBreakHook;\r\n        }\r\n        else if (typeof cacheBreakHook === \"number\") {\r\n            return ({ timeCached, result }) => {\r\n                if (!result.error) {\r\n                    return Date.now() - timeCached > cacheBreakHook;\r\n                }\r\n                return true;\r\n            };\r\n        }\r\n        return cacheBreakHook;\r\n    }\r\n    return undefined;\r\n}\r\nfunction createAsyncAction(action, { forceContext = false, shortCircuitHook, cacheBreakHook, postActionHook, subsetKey, actionId } = {}) {\r\n    const ordinal = actionId != null ? `_${actionId}` : asyncCreationOrdinal++;\r\n    const onServer = typeof window === \"undefined\";\r\n    function _createKey(args, customKey) {\r\n        if (customKey != null) {\r\n            return `${ordinal}-c-${customKey}`;\r\n        }\r\n        if (subsetKey !== undefined) {\r\n            return `${ordinal}-${keyFromObject(subsetKey(args))}`;\r\n        }\r\n        return `${ordinal}-${keyFromObject(args)}`;\r\n    }\r\n    const deferWaitingKey = `def_wait_${_createKey({})}`;\r\n    let cacheBreakWatcher = {};\r\n    let watchIdOrd = 0;\r\n    const shouldUpdate = {};\r\n    function runPostActionHook(result, args, stores, context) {\r\n        if (postActionHook !== undefined) {\r\n            postActionHook({ args, result, stores, context });\r\n        }\r\n    }\r\n    function getCachedResult({ args, cache, cacheBreakEnabled, context, fromListener, key, postActionEnabled, stores, customCacheBreak }) {\r\n        const useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;\r\n        if (cache.results.hasOwnProperty(key)) {\r\n            const cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;\r\n            if (!onServer &&\r\n                !fromListener &&\r\n                cacheBreakEnabled &&\r\n                useCacheBreakHook != null\r\n                && cache.results[key][1] &&\r\n                useCacheBreakHook({\r\n                    args,\r\n                    result: cache.results[key][2],\r\n                    stores,\r\n                    timeCached: cache.results[key][4]\r\n                }) &&\r\n                !cacheBreakLoop) {\r\n                if (cacheBreakWatcher.hasOwnProperty(key)) {\r\n                    cacheBreakWatcher[key]++;\r\n                }\r\n                else {\r\n                    cacheBreakWatcher[key] = 1;\r\n                }\r\n                const previous = cache.results[key];\r\n                delete cache.results[key];\r\n                return { cacheBroke: true, response: undefined, previous };\r\n            }\r\n            else {\r\n                if (cacheBreakLoop) {\r\n                    console.error(`[${key}] Pullstate detected an infinite loop caused by cacheBreakHook()\r\nreturning true too often (breaking cache as soon as your action is resolving - hence\r\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\r\nfurther looping. Fix in your cacheBreakHook() is needed.`);\r\n                }\r\n                else {\r\n                    cacheBreakWatcher[key] = 0;\r\n                }\r\n                if (postActionEnabled && cache.results[key][1] && !fromListener) {\r\n                    runPostActionHook(cache.results[key][2], args, stores, context);\r\n                }\r\n                return {\r\n                    response: cache.results[key],\r\n                    cacheBroke: false,\r\n                    previous: undefined\r\n                };\r\n            }\r\n        }\r\n        return { cacheBroke: false, response: undefined, previous: undefined };\r\n    }\r\n    function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {\r\n        return () => action(args, stores, customContext)\r\n            .then((resp) => {\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                if (postActionEnabled) {\r\n                    runPostActionHook(resp, args, stores, executionContext);\r\n                }\r\n                cache.results[key] = [true, true, resp, false, Date.now()];\r\n            }\r\n            return resp;\r\n        })\r\n            .catch((e) => {\r\n            console.error(e);\r\n            const result = {\r\n                payload: null,\r\n                errorPayload: null,\r\n                error: true,\r\n                tags: [EAsyncEndTags.THREW_ERROR],\r\n                message: e.message\r\n            };\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                if (postActionEnabled) {\r\n                    runPostActionHook(result, args, stores, executionContext);\r\n                }\r\n                cache.results[key] = [true, true, result, false, Date.now()];\r\n            }\r\n            return result;\r\n        })\r\n            .then((resp) => {\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                delete cache.actions[key];\r\n                if (!onServer) {\r\n                    notifyListeners(key);\r\n                }\r\n            }\r\n            return resp;\r\n        });\r\n    }\r\n    function checkKeyAndReturnResponse({ key, cache, initiate, ssr, args, stores, fromListener = false, postActionEnabled = true, cacheBreakEnabled = true, holdingResult, customContext, customCacheBreak, holdPrevious }) {\r\n        const cached = getCachedResult({\r\n            key,\r\n            cache,\r\n            args,\r\n            stores,\r\n            context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            fromListener,\r\n            customCacheBreak\r\n        });\r\n        if (cached.response) {\r\n            return cached.response;\r\n        }\r\n        if (!cache.actions.hasOwnProperty(key)) {\r\n            const currentActionOrd = actionOrdUpdate(cache, key);\r\n            if (initiate) {\r\n                if (shortCircuitHook !== undefined) {\r\n                    const shortCircuitResponse = shortCircuitHook({ args, stores });\r\n                    if (shortCircuitResponse !== false) {\r\n                        runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\r\n                        cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                        return cache.results[key];\r\n                    }\r\n                }\r\n                if (ssr || !onServer) {\r\n                    cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);\r\n                }\r\n                if (!onServer) {\r\n                    cache.actions[key]();\r\n                    cache.results[key] = startedButUnfinishedResult;\r\n                }\r\n                else {\r\n                    return startedButUnfinishedResult;\r\n                }\r\n            }\r\n            else {\r\n                const resp = [\r\n                    false,\r\n                    false,\r\n                    {\r\n                        message: \"\",\r\n                        tags: [EAsyncEndTags.UNFINISHED],\r\n                        error: true,\r\n                        payload: null,\r\n                        errorPayload: null\r\n                    },\r\n                    false,\r\n                    -1\r\n                ];\r\n                if (!onServer) {\r\n                    cache.results[key] = resp;\r\n                }\r\n                if (holdPrevious) {\r\n                    if (holdingResult) {\r\n                        const response = [...holdingResult];\r\n                        response[3] = true;\r\n                        return response;\r\n                    }\r\n                    if (cached.previous != null) {\r\n                        const response = [...cached.previous];\r\n                        response[3] = true;\r\n                        return response;\r\n                    }\r\n                }\r\n                return resp;\r\n            }\r\n        }\r\n        if (holdPrevious) {\r\n            if (holdingResult) {\r\n                const response = [...holdingResult];\r\n                response[3] = true;\r\n                return response;\r\n            }\r\n            if (cached.previous != null) {\r\n                const response = [...cached.previous];\r\n                response[3] = true;\r\n                return response;\r\n            }\r\n        }\r\n        return startedButUnfinishedResult;\r\n    }\r\n    const read = (args = {}, { cacheBreakEnabled = true, postActionEnabled = true, key: customKey } = {}) => {\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        let stores;\r\n        let customContext;\r\n        if (onServer || forceContext) {\r\n            const pullstateContext = useContext(PullstateContext);\r\n            stores = pullstateContext.stores;\r\n            customContext = pullstateContext.customContext;\r\n        }\r\n        else if (clientStores.loaded) {\r\n            stores = clientStores.stores;\r\n        }\r\n        else {\r\n            stores = storeErrorProxy;\r\n        }\r\n        const cached = getCachedResult({\r\n            key,\r\n            cache,\r\n            args,\r\n            stores,\r\n            context: EPostActionContext.READ_HIT_CACHE,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            fromListener: false\r\n        });\r\n        if (cached.response) {\r\n            if (!cached.response[2].error) {\r\n                return cached.response[2].payload;\r\n            }\r\n            else {\r\n                throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);\r\n            }\r\n        }\r\n        if (!cache.actions.hasOwnProperty(key)) {\r\n            if (shortCircuitHook !== undefined) {\r\n                const shortCircuitResponse = shortCircuitHook({ args, stores });\r\n                if (shortCircuitResponse !== false) {\r\n                    runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\r\n                    cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                    if (!shortCircuitResponse.error) {\r\n                        return shortCircuitResponse.payload;\r\n                    }\r\n                    else {\r\n                        throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);\r\n                    }\r\n                }\r\n            }\r\n            const currentActionOrd = actionOrdUpdate(cache, key);\r\n            cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);\r\n            if (onServer) {\r\n                throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\r\n            }\r\n            throw cache.actions[key]();\r\n        }\r\n        if (onServer) {\r\n            throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\r\n        }\r\n        const watchOrd = watchIdOrd++;\r\n        throw new Promise((resolve) => {\r\n            cache.listeners[key][watchOrd] = () => {\r\n                delete cache.listeners[key][watchOrd];\r\n                resolve();\r\n            };\r\n        });\r\n    };\r\n    const useWatch = (args = {}, { initiate = false, ssr = true, postActionEnabled = false, cacheBreakEnabled = false, holdPrevious = false, dormant = false, key: customKey, cacheBreak: customCacheBreakIncoming } = {}) => {\r\n        const responseRef = useRef();\r\n        const prevKeyRef = useRef(\".\");\r\n        const key = dormant ? \".\" : _createKey(args, customKey);\r\n        let watchId = useRef(-1);\r\n        if (watchId.current === -1) {\r\n            watchId.current = watchIdOrd++;\r\n        }\r\n        if (!dormant) {\r\n            if (!shouldUpdate.hasOwnProperty(key)) {\r\n                shouldUpdate[key] = {\r\n                    [watchId.current]: true\r\n                };\r\n            }\r\n            else {\r\n                shouldUpdate[key][watchId.current] = true;\r\n            }\r\n        }\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        let stores;\r\n        let customContext;\r\n        if (onServer || forceContext) {\r\n            const pullstateContext = useContext(PullstateContext);\r\n            stores = pullstateContext.stores;\r\n            customContext = pullstateContext.customContext;\r\n        }\r\n        else if (clientStores.loaded) {\r\n            stores = clientStores.stores;\r\n        }\r\n        else {\r\n            stores = storeErrorProxy;\r\n        }\r\n        if (!onServer) {\r\n            const onAsyncStateChanged = () => {\r\n                if (shouldUpdate[key][watchId.current] && !isEqual(responseRef.current, cache.results[key])) {\r\n                    const nextResponse = checkKeyAndReturnResponse({\r\n                        key,\r\n                        cache,\r\n                        initiate,\r\n                        ssr,\r\n                        args,\r\n                        stores,\r\n                        fromListener: true,\r\n                        postActionEnabled,\r\n                        cacheBreakEnabled,\r\n                        holdingResult: undefined,\r\n                        customContext,\r\n                        holdPrevious\r\n                    });\r\n                    if (holdPrevious && !nextResponse[1] && responseRef.current != null && responseRef.current[1]) {\r\n                        responseRef.current = [...responseRef.current];\r\n                        responseRef.current[3] = true;\r\n                    }\r\n                    else {\r\n                        responseRef.current = nextResponse;\r\n                    }\r\n                    setWatchUpdate((prev) => {\r\n                        return prev + 1;\r\n                    });\r\n                }\r\n            };\r\n            if (!dormant) {\r\n                if (!cache.listeners.hasOwnProperty(key)) {\r\n                    cache.listeners[key] = {};\r\n                }\r\n                cache.listeners[key][watchId.current] = onAsyncStateChanged;\r\n                shouldUpdate[key][watchId.current] = true;\r\n            }\r\n            useEffect(() => {\r\n                if (!dormant) {\r\n                    cache.listeners[key][watchId.current] = onAsyncStateChanged;\r\n                    shouldUpdate[key][watchId.current] = true;\r\n                }\r\n                return () => {\r\n                    if (!dormant) {\r\n                        delete cache.listeners[key][watchId.current];\r\n                        shouldUpdate[key][watchId.current] = false;\r\n                    }\r\n                };\r\n            }, [key]);\r\n        }\r\n        const [_, setWatchUpdate] = useState(0);\r\n        if (dormant) {\r\n            responseRef.current =\r\n                holdPrevious && responseRef.current && responseRef.current[1]\r\n                    ? responseRef.current\r\n                    : [\r\n                        false,\r\n                        false,\r\n                        {\r\n                            message: \"\",\r\n                            tags: [EAsyncEndTags.DORMANT],\r\n                            error: true,\r\n                            payload: null\r\n                        },\r\n                        false,\r\n                        -1\r\n                    ];\r\n            prevKeyRef.current = \".\";\r\n        }\r\n        else if (prevKeyRef.current !== key) {\r\n            if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {\r\n                delete cache.listeners[prevKeyRef.current][watchId.current];\r\n                shouldUpdate[prevKeyRef.current][watchId.current] = false;\r\n            }\r\n            prevKeyRef.current = key;\r\n            responseRef.current = checkKeyAndReturnResponse({\r\n                key,\r\n                cache,\r\n                initiate,\r\n                ssr,\r\n                args,\r\n                stores,\r\n                fromListener: false,\r\n                postActionEnabled,\r\n                cacheBreakEnabled,\r\n                holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : undefined,\r\n                customContext,\r\n                customCacheBreak: convertCustomCacheBreakHook(customCacheBreakIncoming),\r\n                holdPrevious\r\n            });\r\n        }\r\n        return responseRef.current;\r\n    };\r\n    const useBeckon = (args = {}, { ssr = true, postActionEnabled = true, cacheBreakEnabled = true, holdPrevious = false, dormant = false, key } = {}) => {\r\n        const result = useWatch(args, {\r\n            initiate: true,\r\n            ssr,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            holdPrevious,\r\n            dormant,\r\n            key\r\n        });\r\n        return [result[1], result[2], result[3]];\r\n    };\r\n    const run = async (args = {}, inputs = {}) => {\r\n        const { treatAsUpdate = false, ignoreShortCircuit = false, respectCache = false, key: customKey, _asyncCache = clientAsyncCache, _stores = clientStores.loaded ? clientStores.stores : storeErrorProxy, _customContext, cacheBreak: customCacheBreak } = inputs;\r\n        const key = _createKey(args, customKey);\r\n        if (respectCache) {\r\n            const cached = getCachedResult({\r\n                key,\r\n                cache: _asyncCache,\r\n                args,\r\n                stores: _stores,\r\n                context: EPostActionContext.RUN_HIT_CACHE,\r\n                postActionEnabled: true,\r\n                cacheBreakEnabled: true,\r\n                fromListener: false,\r\n                customCacheBreak: convertCustomCacheBreakHook(customCacheBreak)\r\n            });\r\n            if (cached.response && cached.response[0]) {\r\n                if (!cached.response[1]) {\r\n                    const watchOrd = watchIdOrd++;\r\n                    if (!_asyncCache.listeners.hasOwnProperty(key)) {\r\n                        _asyncCache.listeners[key] = {};\r\n                    }\r\n                    return new Promise((resolve) => {\r\n                        _asyncCache.listeners[key][watchOrd] = () => {\r\n                            const [, finished, resp] = _asyncCache.results[key];\r\n                            if (finished) {\r\n                                delete _asyncCache.listeners[key][watchOrd];\r\n                                resolve(resp);\r\n                            }\r\n                        };\r\n                    });\r\n                }\r\n                return cached.response[2];\r\n            }\r\n        }\r\n        if (!ignoreShortCircuit && shortCircuitHook !== undefined) {\r\n            const shortCircuitResponse = shortCircuitHook({ args, stores: _stores });\r\n            if (shortCircuitResponse !== false) {\r\n                _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);\r\n                notifyListeners(key);\r\n                return shortCircuitResponse;\r\n            }\r\n        }\r\n        const [, prevFinished, prevResp, prevUpdate, prevCacheTime] = _asyncCache.results[key] || [\r\n            false,\r\n            false,\r\n            {\r\n                error: true,\r\n                message: \"\",\r\n                payload: null,\r\n                tags: [EAsyncEndTags.UNFINISHED]\r\n            },\r\n            false,\r\n            -1\r\n        ];\r\n        if (prevFinished && treatAsUpdate) {\r\n            _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];\r\n        }\r\n        else {\r\n            _asyncCache.results[key] = [\r\n                true,\r\n                false,\r\n                {\r\n                    error: true,\r\n                    message: \"\",\r\n                    payload: null,\r\n                    tags: [EAsyncEndTags.UNFINISHED]\r\n                },\r\n                false,\r\n                -1\r\n            ];\r\n        }\r\n        let currentActionOrd = actionOrdUpdate(_asyncCache, key);\r\n        _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);\r\n        notifyListeners(key);\r\n        return _asyncCache.actions[key]();\r\n    };\r\n    const clearCache = (args = {}, { key: customKey, notify = true } = {}) => {\r\n        const key = _createKey(args, customKey);\r\n        clearActionCache(key, true, notify);\r\n    };\r\n    const clearAllCache = ({ notify = true } = {}) => {\r\n        for (const key of Object.keys(clientAsyncCache.actionOrd)) {\r\n            if (key.startsWith(`${ordinal}-`)) {\r\n                clearActionCache(key, true, notify);\r\n            }\r\n        }\r\n    };\r\n    const clearAllUnwatchedCache = ({ notify = true } = {}) => {\r\n        for (const key of Object.keys(shouldUpdate)) {\r\n            if (!Object.values(shouldUpdate[key]).some((su) => su)) {\r\n                delete shouldUpdate[key];\r\n                clearActionCache(key, false, notify);\r\n            }\r\n        }\r\n    };\r\n    const setCached = (args, result, options) => {\r\n        const { notify = true, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        cache.results[key] = [true, true, result, false, Date.now()];\r\n        if (notify) {\r\n            notifyListeners(key);\r\n        }\r\n    };\r\n    const setCachedPayload = (args, payload, options) => {\r\n        return setCached(args, successResult(payload), options);\r\n    };\r\n    const updateCached = (args, updater, options) => {\r\n        const { notify = true, resetTimeCached = true, runPostActionHook: postAction = false, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {\r\n            const currentCached = cache.results[key][2].payload;\r\n            const newResult = {\r\n                payload: produce$1(currentCached, (s) => updater(s, currentCached)),\r\n                error: false,\r\n                message: cache.results[key][2].message,\r\n                tags: cache.results[key][2].tags\r\n            };\r\n            if (postAction) {\r\n                runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);\r\n            }\r\n            cache.results[key] = [\r\n                true,\r\n                true,\r\n                newResult,\r\n                cache.results[key][3],\r\n                resetTimeCached ? Date.now() : cache.results[key][4]\r\n            ];\r\n            if (notify) {\r\n                notifyListeners(key);\r\n            }\r\n        }\r\n    };\r\n    const getCached = (args = {}, options) => {\r\n        var _a;\r\n        const { checkCacheBreak = false, key: customKey, cacheBreak: incomingCacheBreak } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        let cacheBreakable = false;\r\n        const cache = clientAsyncCache;\r\n        if (cache.results.hasOwnProperty(key)) {\r\n            const finalizedCacheBreakHook = (_a = convertCustomCacheBreakHook(incomingCacheBreak)) !== null && _a !== void 0 ? _a : cacheBreakHook;\r\n            if (checkCacheBreak && finalizedCacheBreakHook !== undefined) {\r\n                const stores = onServer\r\n                    ? useContext(PullstateContext).stores\r\n                    : clientStores.loaded\r\n                        ? clientStores.stores\r\n                        : storeErrorProxy;\r\n                if (finalizedCacheBreakHook({\r\n                    args,\r\n                    result: cache.results[key][2],\r\n                    stores,\r\n                    timeCached: cache.results[key][4]\r\n                })) {\r\n                    cacheBreakable = true;\r\n                }\r\n            }\r\n            const [started, finished, result, updating, timeCached] = cache.results[key];\r\n            return {\r\n                started,\r\n                finished,\r\n                result: result,\r\n                existed: true,\r\n                cacheBreakable,\r\n                updating,\r\n                timeCached\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                started: false,\r\n                finished: false,\r\n                result: {\r\n                    message: \"\",\r\n                    tags: [EAsyncEndTags.UNFINISHED],\r\n                    error: true,\r\n                    payload: null,\r\n                    errorPayload: null\r\n                },\r\n                updating: false,\r\n                existed: false,\r\n                cacheBreakable,\r\n                timeCached: -1\r\n            };\r\n        }\r\n    };\r\n    let delayedRunActionTimeout;\r\n    const delayedRun = (args = {}, { clearOldRun = true, delay, immediateIfCached = true, ...otherRunOptions }) => {\r\n        if (clearOldRun) {\r\n            clearTimeout(delayedRunActionTimeout);\r\n        }\r\n        if (immediateIfCached) {\r\n            const { finished, cacheBreakable } = getCached(args, { checkCacheBreak: true });\r\n            if (finished && !cacheBreakable) {\r\n                run(args, otherRunOptions);\r\n                return () => {\r\n                };\r\n            }\r\n        }\r\n        let ref = { cancelled: false };\r\n        delayedRunActionTimeout = setTimeout(() => {\r\n            if (!ref.cancelled) {\r\n                run(args, otherRunOptions);\r\n            }\r\n        }, delay);\r\n        return () => {\r\n            ref.cancelled = true;\r\n        };\r\n    };\r\n    const use = (args = {}, { initiate = true, ssr = true, postActionEnabled, cacheBreakEnabled, holdPrevious = false, dormant = false, key, onSuccess, cacheBreak: customCacheBreakHook } = {}) => {\r\n        if (postActionEnabled == null) {\r\n            postActionEnabled = initiate;\r\n        }\r\n        if (cacheBreakEnabled == null) {\r\n            cacheBreakEnabled = initiate;\r\n        }\r\n        const raw = useWatch(args, {\r\n            initiate,\r\n            ssr,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            holdPrevious,\r\n            dormant,\r\n            key,\r\n            cacheBreak: customCacheBreakHook\r\n        });\r\n        const [isStarted, isFinished, result, isUpdating] = raw;\r\n        const isSuccess = isFinished && !result.error;\r\n        const isFailure = isFinished && result.error;\r\n        if (onSuccess) {\r\n            useEffect(() => {\r\n                if (isSuccess && !dormant) {\r\n                    onSuccess(result.payload, args);\r\n                }\r\n            }, [isSuccess]);\r\n        }\r\n        const renderPayload = (func) => {\r\n            if (!result.error) {\r\n                return func(result.payload);\r\n            }\r\n            return React.Fragment;\r\n        };\r\n        return {\r\n            isStarted,\r\n            isFinished,\r\n            isUpdating,\r\n            isSuccess,\r\n            isFailure,\r\n            isLoading: isStarted && (!isFinished || isUpdating),\r\n            endTags: result.tags,\r\n            error: result.error,\r\n            payload: result.payload,\r\n            errorPayload: result.errorPayload,\r\n            renderPayload,\r\n            message: result.message,\r\n            raw,\r\n            execute: (runOptions) => run(args, runOptions),\r\n            clearCached: () => clearCache(args),\r\n            setCached: (response, options) => {\r\n                setCached(args, response, options);\r\n            },\r\n            setCachedPayload: (payload, options) => {\r\n                setCachedPayload(args, payload, options);\r\n            },\r\n            updateCached: (updater, options) => {\r\n                updateCached(args, updater, options);\r\n            }\r\n        };\r\n    };\r\n    const useDefer = (inputs = {}) => {\r\n        const [argState, setArgState] = useState(() => ({\r\n            key: inputs.key ? inputs.key : deferWaitingKey,\r\n            args: {}\r\n        }));\r\n        const initialResponse = use({}, {\r\n            ...inputs,\r\n            key: argState.key,\r\n            initiate: false\r\n        });\r\n        const hasCached = (args = {}, options = {}) => {\r\n            var _a, _b;\r\n            const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\r\n            const { checkCacheBreak = true, successOnly = false } = options;\r\n            const cached = getCached(args, {\r\n                key: executionKey,\r\n                cacheBreak: (_b = options.cacheBreak) !== null && _b !== void 0 ? _b : inputs.cacheBreak,\r\n                checkCacheBreak\r\n            });\r\n            if (cached.existed) {\r\n                if (!checkCacheBreak || !cached.cacheBreakable) {\r\n                    return !successOnly || !cached.result.error;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        const unwatchExecuted = () => {\r\n            setArgState({ key: deferWaitingKey, args: {} });\r\n        };\r\n        const execute = (args = {}, runOptions) => {\r\n            var _a;\r\n            const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\r\n            if (executionKey !== argState.key) {\r\n                setArgState({ key: executionKey, args });\r\n            }\r\n            return run(args, {\r\n                ...runOptions,\r\n                key: executionKey,\r\n                cacheBreak: inputs.cacheBreak\r\n            }).then(resp => {\r\n                if (inputs.clearOnSuccess) {\r\n                    clearCache({}, { key: executionKey });\r\n                }\r\n                return resp;\r\n            });\r\n        };\r\n        return {\r\n            ...initialResponse,\r\n            clearCached: () => {\r\n                clearCache({}, { key: argState.key });\r\n            },\r\n            unwatchExecuted,\r\n            setCached: (response, options = {}) => {\r\n                options.key = argState.key;\r\n                setCached({}, response, options);\r\n            },\r\n            setCachedPayload: (payload, options = {}) => {\r\n                options.key = argState.key;\r\n                setCachedPayload({}, payload, options);\r\n            },\r\n            updateCached: (updater, options = {}) => {\r\n                options.key = argState.key;\r\n                updateCached({}, updater, options);\r\n            },\r\n            useDebouncedExecution: (args, delay, options = {}) => {\r\n                if (!onServer) {\r\n                    const stateRef = useRef({ update: false });\r\n                    const currentValue = useRef(undefined);\r\n                    const executionOrd = useRef(-1);\r\n                    const timeout = useRef(undefined);\r\n                    useEffect(() => {\r\n                        stateRef.current.update = true;\r\n                        return () => {\r\n                            stateRef.current.update = false;\r\n                        };\r\n                    }, []);\r\n                    const hasEqualityCheck = options.equality != null;\r\n                    if (hasEqualityCheck) {\r\n                        if (typeof options.equality === \"function\") {\r\n                            if ((currentValue.current === undefined || options.equality(currentValue.current, args))) {\r\n                                currentValue.current = args;\r\n                                executionOrd.current += 1;\r\n                            }\r\n                        }\r\n                        else if (currentValue.current !== options.equality) {\r\n                            currentValue.current = options.equality;\r\n                            executionOrd.current += 1;\r\n                        }\r\n                    }\r\n                    else if (!isEqual(currentValue.current, args)) {\r\n                        currentValue.current = args;\r\n                        executionOrd.current += 1;\r\n                    }\r\n                    useEffect(() => {\r\n                        var _a, _b, _c;\r\n                        clearTimeout(timeout.current);\r\n                        const executeAction = () => {\r\n                            var _a;\r\n                            if (stateRef.current.update) {\r\n                                execute(args, (_a = options.executeOptions) !== null && _a !== void 0 ? _a : { respectCache: true });\r\n                            }\r\n                        };\r\n                        if ((_b = (_a = options.validInput) === null || _a === void 0 ? void 0 : _a.call(options, args)) !== null && _b !== void 0 ? _b : true) {\r\n                            if (hasCached(args)) {\r\n                                executeAction();\r\n                            }\r\n                            else {\r\n                                timeout.current = setTimeout(executeAction, delay);\r\n                            }\r\n                        }\r\n                        else if (!((_c = options.watchLastValid) !== null && _c !== void 0 ? _c : false)) {\r\n                            unwatchExecuted();\r\n                        }\r\n                    }, [executionOrd.current]);\r\n                }\r\n            },\r\n            hasCached,\r\n            execute,\r\n            args: argState.args,\r\n            key: argState.key\r\n        };\r\n    };\r\n    return {\r\n        use,\r\n        useDefer,\r\n        read,\r\n        useBeckon,\r\n        useWatch,\r\n        run,\r\n        delayedRun,\r\n        clearCache,\r\n        clearAllCache,\r\n        clearAllUnwatchedCache,\r\n        getCached,\r\n        setCached,\r\n        setCachedPayload,\r\n        updateCached\r\n    };\r\n}const PullstateContext = React.createContext(null);\r\nconst PullstateProvider = ({ instance, children }) => {\r\n    return React.createElement(PullstateContext.Provider, { value: instance }, children);\r\n};\r\nlet singleton = null;\r\nconst clientStores = {\r\n    internalClientStores: true,\r\n    loaded: false,\r\n    stores: {}\r\n};\r\nclass PullstateSingleton {\r\n    constructor(allStores, options = {}) {\r\n        this.options = {};\r\n        if (singleton !== null) {\r\n            console.error(`Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.`);\r\n        }\r\n        singleton = this;\r\n        clientStores.stores = allStores;\r\n        clientStores.loaded = true;\r\n        this.options = options;\r\n    }\r\n    instantiate({ hydrateSnapshot, ssr = false, customContext } = {}) {\r\n        if (!ssr) {\r\n            const instantiated = new PullstateInstance(clientStores.stores, false, customContext);\r\n            if (hydrateSnapshot != null) {\r\n                instantiated.hydrateFromSnapshot(hydrateSnapshot);\r\n            }\r\n            instantiated.instantiateReactions();\r\n            return instantiated;\r\n        }\r\n        const newStores = {};\r\n        for (const storeName of Object.keys(clientStores.stores)) {\r\n            if (hydrateSnapshot == null) {\r\n                newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\r\n            }\r\n            else if (hydrateSnapshot.hasOwnProperty(storeName)) {\r\n                newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);\r\n            }\r\n            else {\r\n                newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\r\n                console.warn(`Pullstate (instantiate): store [${storeName}] didn't hydrate any state (data was non-existent on hydration object)`);\r\n            }\r\n            newStores[storeName]._setInternalOptions({\r\n                ssr,\r\n                reactionCreators: clientStores.stores[storeName]._getReactionCreators()\r\n            });\r\n        }\r\n        return new PullstateInstance(newStores, true, customContext);\r\n    }\r\n    useStores() {\r\n        return useStores();\r\n    }\r\n    useInstance() {\r\n        return useInstance();\r\n    }\r\n    createAsyncActionDirect(action, options = {}) {\r\n        return createAsyncActionDirect(action, options);\r\n    }\r\n    createAsyncAction(action, options = {}) {\r\n        var _a;\r\n        if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {\r\n            options.cacheBreakHook = (inputs) => inputs.timeCached < Date.now() - this.options.asyncActions.defaultCachingSeconds * 1000;\r\n        }\r\n        return createAsyncAction(action, options);\r\n    }\r\n}\r\nclass PullstateInstance {\r\n    constructor(allStores, ssr, customContext) {\r\n        this._ssr = false;\r\n        this._stores = {};\r\n        this._asyncCache = {\r\n            listeners: {},\r\n            results: {},\r\n            actions: {},\r\n            actionOrd: {}\r\n        };\r\n        this._stores = allStores;\r\n        this._ssr = ssr;\r\n        this._customContext = customContext;\r\n    }\r\n    getAllUnresolvedAsyncActions() {\r\n        return Object.keys(this._asyncCache.actions).map((key) => this._asyncCache.actions[key]());\r\n    }\r\n    instantiateReactions() {\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            this._stores[storeName]._instantiateReactions();\r\n        }\r\n    }\r\n    getPullstateSnapshot() {\r\n        const allState = {};\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            allState[storeName] = this._stores[storeName].getRawState();\r\n        }\r\n        return { allState, asyncResults: this._asyncCache.results, asyncActionOrd: this._asyncCache.actionOrd };\r\n    }\r\n    async resolveAsyncState() {\r\n        const promises = this.getAllUnresolvedAsyncActions();\r\n        await Promise.all(promises);\r\n    }\r\n    hasAsyncStateToResolve() {\r\n        return Object.keys(this._asyncCache.actions).length > 0;\r\n    }\r\n    get stores() {\r\n        return this._stores;\r\n    }\r\n    get customContext() {\r\n        return this._customContext;\r\n    }\r\n    async runAsyncAction(asyncAction, args = {}, runOptions = {}) {\r\n        if (this._ssr) {\r\n            runOptions._asyncCache = this._asyncCache;\r\n            runOptions._stores = this._stores;\r\n            runOptions._customContext = this._customContext;\r\n        }\r\n        return await asyncAction.run(args, runOptions);\r\n    }\r\n    hydrateFromSnapshot(snapshot) {\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            if (snapshot.allState.hasOwnProperty(storeName)) {\r\n                this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);\r\n            }\r\n            else {\r\n                console.warn(`${storeName} didn't hydrate any state (data was non-existent on hydration object)`);\r\n            }\r\n        }\r\n        clientAsyncCache.results = snapshot.asyncResults || {};\r\n        clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};\r\n    }\r\n}\r\nfunction createPullstateCore(allStores = {}, options = {}) {\r\n    return new PullstateSingleton(allStores, options);\r\n}\r\nfunction useStores() {\r\n    return useContext(PullstateContext).stores;\r\n}\r\nfunction useInstance() {\r\n    return useContext(PullstateContext);\r\n}var EAsyncActionInjectType;\r\n(function (EAsyncActionInjectType) {\r\n    EAsyncActionInjectType[\"WATCH\"] = \"watch\";\r\n    EAsyncActionInjectType[\"BECKON\"] = \"beckon\";\r\n})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));\r\nfunction InjectAsyncAction(props) {\r\n    if (props.type === EAsyncActionInjectType.BECKON) {\r\n        const response = props.action.useBeckon(props.args, props.options);\r\n        return props.children(response);\r\n    }\r\n    const response = props.action.useWatch(props.args, props.options);\r\n    return props.children(response);\r\n}function InjectStoreStateOpt({ store, paths, children }) {\r\n    const state = useStoreStateOpt(store, paths);\r\n    return children(state);\r\n}function registerInDevtools(stores, { namespace = \"\" } = {}) {\r\n    var _a;\r\n    const devToolsExtension = typeof window !== \"undefined\" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : undefined;\r\n    if (devToolsExtension) {\r\n        for (const key of Object.keys(stores)) {\r\n            const store = stores[key];\r\n            const devTools = devToolsExtension.connect({ name: `${namespace}${key}` });\r\n            devTools.init(store.getRawState());\r\n            let ignoreNext = false;\r\n            store.subscribe((s) => s, (watched) => {\r\n                if (ignoreNext) {\r\n                    ignoreNext = false;\r\n                    return;\r\n                }\r\n                devTools.send(\"Change\", watched);\r\n            });\r\n            devTools.subscribe((message) => {\r\n                if (message.type === \"DISPATCH\" && message.state) {\r\n                    ignoreNext = true;\r\n                    const parsed = JSON.parse(message.state);\r\n                    store.replace(parsed);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}const batchState = {};\r\nfunction setupBatch({ uiBatchFunction }) {\r\n    batchState.uiBatchFunction = uiBatchFunction;\r\n}\r\nfunction batch(runUpdates) {\r\n    if (globalClientState.batching) {\r\n        throw new Error(\"Pullstate: Can't enact two batch() update functions at the same time-\\n\" +\r\n            \"make sure you are not running a batch() inside of a batch() by mistake.\");\r\n    }\r\n    globalClientState.batching = true;\r\n    try {\r\n        runUpdates();\r\n    }\r\n    finally {\r\n        if (batchState.uiBatchFunction) {\r\n            batchState.uiBatchFunction(() => {\r\n                Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\r\n            });\r\n        }\r\n        else {\r\n            Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\r\n        }\r\n        globalClientState.flushStores = {};\r\n        globalClientState.batching = false;\r\n    }\r\n}export{EAsyncActionInjectType,EAsyncEndTags,EPostActionContext,InjectAsyncAction,InjectStoreState,InjectStoreStateOpt,PullstateContext,PullstateProvider,Store,batch,createAsyncAction,createAsyncActionDirect,createPullstateCore,errorResult,registerInDevtools,setupBatch,successResult,update,useInstance,useLocalStore,useStoreState,useStoreStateOpt,useStores};"]},"metadata":{},"sourceType":"module"}