{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MangoClient = exports.getUnixTs = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nconst utils_1 = require(\"./utils/utils\");\n\nconst layout_1 = require(\"./layout\");\n\nconst MangoAccount_1 = __importDefault(require(\"./MangoAccount\"));\n\nconst PerpMarket_1 = __importDefault(require(\"./PerpMarket\"));\n\nconst instruction_1 = require(\"./instruction\");\n\nconst serum_1 = require(\"@project-serum/serum\");\n\nconst fixednum_1 = require(\"./utils/fixednum\");\n\nconst adapterTypes_1 = require(\"./utils/adapterTypes\");\n\nconst book_1 = require(\"./book\");\n\nconst token_instructions_1 = require(\"@project-serum/serum/lib/token-instructions\");\n\nconst spl_token_1 = require(\"@solana/spl-token\");\n\nconst MangoGroup_1 = __importDefault(require(\"./MangoGroup\"));\n\nconst _1 = require(\".\");\n\nconst bs58 = __importStar(require(\"bs58\"));\n/**\n * Get the current epoch timestamp in seconds with microsecond precision\n */\n\n\nconst getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexports.getUnixTs = getUnixTs;\n/**\n * A class for interacting with the Mango V3 Program\n *\n * @param connection A solana web.js Connection object\n * @param programId The PublicKey of the Mango V3 Program\n * @param opts An object used to configure the MangoClient. Accepts a postSendTxCallback\n */\n\nclass MangoClient {\n  constructor(connection, programId) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.connection = connection;\n    this.programId = programId;\n    this.lastSlot = 0;\n    this.recentBlockhash = '';\n    this.recentBlockhashTime = 0;\n    this.maxStoredBlockhashes = (opts === null || opts === void 0 ? void 0 : opts.maxStoredBlockhashes) || 7;\n    this.blockhashCommitment = (opts === null || opts === void 0 ? void 0 : opts.blockhashCommitment) || 'confirmed';\n    this.timeout = (opts === null || opts === void 0 ? void 0 : opts.timeout) || 60000;\n    this.sendConnection = opts.sendConnection;\n\n    if (opts.postSendTxCallback) {\n      this.postSendTxCallback = opts.postSendTxCallback;\n    }\n  }\n\n  sendTransactions(transactions, payer, additionalSigners) {\n    let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.timeout;\n    let confirmLevel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'confirmed';\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield Promise.all(transactions.map(tx => this.sendTransaction(tx, payer, additionalSigners, timeout, confirmLevel)));\n    });\n  }\n\n  signTransaction(_ref) {\n    let {\n      transaction,\n      payer,\n      signers\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = exports.getUnixTs();\n      let blockhash; // Get new blockhash if stored blockhash more than 70 seconds old\n\n      if (this.recentBlockhashTime && now < this.recentBlockhashTime + 70) {\n        blockhash = this.recentBlockhash;\n      } else {\n        blockhash = (yield this.connection.getRecentBlockhash(this.blockhashCommitment)).blockhash;\n      }\n\n      transaction.recentBlockhash = blockhash;\n      transaction.setSigners(payer.publicKey, ...signers.map(s => s.publicKey));\n\n      if (signers.length > 0) {\n        transaction.partialSign(...signers);\n      }\n\n      if (payer === null || payer === void 0 ? void 0 : payer.connected) {\n        console.log('signing as wallet', payer.publicKey);\n        return yield payer.signTransaction(transaction);\n      } else {\n        transaction.sign(...[payer].concat(signers));\n      }\n    });\n  }\n\n  signTransactions(_ref2) {\n    let {\n      transactionsAndSigners,\n      payer\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const now = exports.getUnixTs();\n      let blockhash; // Get new blockhash if stored blockhash more than 70 seconds old\n\n      if (this.recentBlockhashTime && now < this.recentBlockhashTime + 70) {\n        blockhash = this.recentBlockhash;\n      } else {\n        blockhash = (yield this.connection.getRecentBlockhash(this.blockhashCommitment)).blockhash;\n      }\n\n      transactionsAndSigners.forEach(_ref3 => {\n        let {\n          transaction,\n          signers = []\n        } = _ref3;\n        transaction.recentBlockhash = blockhash;\n\n        if (payer.publicKey) {\n          transaction.setSigners(payer.publicKey, ...signers.map(s => s.publicKey));\n        }\n\n        if ((signers === null || signers === void 0 ? void 0 : signers.length) > 0) {\n          transaction.partialSign(...signers);\n        }\n      });\n\n      if (adapterTypes_1.adapterHasSignAllTransactions(payer)) {\n        return yield payer.signAllTransactions(transactionsAndSigners.map(_ref4 => {\n          let {\n            transaction\n          } = _ref4;\n          return transaction;\n        }));\n      } else {\n        transactionsAndSigners.forEach(_ref5 => {\n          let {\n            transaction,\n            signers\n          } = _ref5;\n          // @ts-ignore\n          transaction.sign(...[payer].concat(signers));\n        });\n        return transactionsAndSigners.map(t => t.transaction);\n      }\n    });\n  }\n  /**\n   * Send a transaction using the Solana Web3.js connection on the mango client\n   *\n   * @param transaction\n   * @param payer\n   * @param additionalSigners\n   * @param timeout Retries sending the transaction and trying to confirm it until the given timeout. Passing null will disable the transaction confirmation check and always return success.\n   */\n\n\n  sendTransaction(transaction, payer, additionalSigners) {\n    let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.timeout;\n    let confirmLevel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'processed';\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.signTransaction({\n        transaction,\n        payer,\n        signers: additionalSigners\n      });\n      const rawTransaction = transaction.serialize();\n      let txid = bs58.encode(transaction.signatures[0].signature);\n      const startTime = exports.getUnixTs();\n\n      if (this.sendConnection) {\n        const promise = this.sendConnection.sendRawTransaction(rawTransaction);\n\n        if (this.postSendTxCallback) {\n          try {\n            this.postSendTxCallback({\n              txid\n            });\n          } catch (e) {\n            console.warn(`postSendTxCallback error ${e}`);\n          }\n        }\n\n        try {\n          return yield promise;\n        } catch (e) {\n          console.error(e);\n          throw new _1.MangoError({\n            message: 'Transaction failed',\n            txid\n          });\n        }\n      } else {\n        txid = yield this.connection.sendRawTransaction(rawTransaction, {\n          skipPreflight: true\n        });\n\n        if (this.postSendTxCallback) {\n          try {\n            this.postSendTxCallback({\n              txid\n            });\n          } catch (e) {\n            console.warn(`postSendTxCallback error ${e}`);\n          }\n        }\n\n        if (this.timeout) {\n          timeout = this.timeout < 0 ? timeout : this.timeout * 1000;\n        }\n\n        if (!timeout) return txid;\n        console.log('Started awaiting confirmation for', txid, 'size:', rawTransaction.length);\n        let done = false;\n        let retrySleep = 1000;\n\n        (() => __awaiter(this, void 0, void 0, function* () {\n          // TODO - make sure this works well on mainnet\n          while (!done && exports.getUnixTs() - startTime < timeout / 1000) {\n            yield utils_1.sleep(retrySleep); // console.log(new Date().toUTCString(), ' sending tx ', txid);\n\n            this.connection.sendRawTransaction(rawTransaction, {\n              skipPreflight: true\n            });\n          }\n\n          if (retrySleep <= 8000) {\n            retrySleep = retrySleep * 2;\n          }\n        }))();\n\n        try {\n          yield this.awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel);\n        } catch (err) {\n          if (err.timeout) {\n            throw new _1.TimeoutError({\n              txid\n            });\n          }\n\n          let simulateResult = null;\n\n          try {\n            simulateResult = (yield utils_1.simulateTransaction(this.connection, transaction, 'processed')).value;\n          } catch (e) {\n            console.warn('Simulate transaction failed');\n          }\n\n          if (simulateResult && simulateResult.err) {\n            if (simulateResult.logs) {\n              for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n                const line = simulateResult.logs[i];\n\n                if (line.startsWith('Program log: ')) {\n                  throw new _1.MangoError({\n                    message: 'Transaction failed: ' + line.slice('Program log: '.length),\n                    txid\n                  });\n                }\n              }\n            }\n\n            throw new _1.MangoError({\n              message: JSON.stringify(simulateResult.err),\n              txid\n            });\n          }\n\n          throw new _1.MangoError({\n            message: 'Transaction failed',\n            txid\n          });\n        } finally {\n          done = true;\n        }\n      }\n\n      console.log('Latency', txid, exports.getUnixTs() - startTime);\n      return txid;\n    });\n  }\n\n  sendSignedTransaction(_ref6) {\n    let {\n      signedTransaction,\n      timeout = this.timeout,\n      confirmLevel = 'processed'\n    } = _ref6;\n    return __awaiter(this, void 0, void 0, function* () {\n      const rawTransaction = signedTransaction.serialize();\n      let txid = bs58.encode(signedTransaction.signatures[0].signature);\n      const startTime = exports.getUnixTs();\n\n      if (this.sendConnection) {\n        const promise = this.sendConnection.sendRawTransaction(rawTransaction);\n\n        if (this.postSendTxCallback) {\n          try {\n            this.postSendTxCallback({\n              txid\n            });\n          } catch (e) {\n            console.warn(`postSendTxCallback error ${e}`);\n          }\n        }\n\n        try {\n          return yield promise;\n        } catch (e) {\n          console.error(e);\n          throw new _1.MangoError({\n            message: 'Transaction failed',\n            txid\n          });\n        }\n      } else {\n        txid = yield this.connection.sendRawTransaction(rawTransaction, {\n          skipPreflight: true\n        });\n\n        if (this.postSendTxCallback) {\n          try {\n            this.postSendTxCallback({\n              txid\n            });\n          } catch (e) {\n            console.log(`postSendTxCallback error ${e}`);\n          }\n        }\n\n        if (!timeout) return txid; // console.log('Started awaiting confirmation for', txid);\n\n        let done = false;\n\n        (() => __awaiter(this, void 0, void 0, function* () {\n          yield utils_1.sleep(500);\n\n          while (!done && exports.getUnixTs() - startTime < timeout) {\n            this.connection.sendRawTransaction(rawTransaction, {\n              skipPreflight: true\n            });\n            yield utils_1.sleep(1000);\n          }\n        }))();\n\n        try {\n          yield this.awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel);\n        } catch (err) {\n          if (err.timeout) {\n            throw new _1.TimeoutError({\n              txid\n            });\n          }\n\n          let simulateResult = null;\n\n          try {\n            simulateResult = (yield utils_1.simulateTransaction(this.connection, signedTransaction, 'single')).value;\n          } catch (e) {\n            console.log('Simulate tx failed');\n          }\n\n          if (simulateResult && simulateResult.err) {\n            if (simulateResult.logs) {\n              for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n                const line = simulateResult.logs[i];\n\n                if (line.startsWith('Program log: ')) {\n                  throw new _1.MangoError({\n                    message: 'Transaction failed: ' + line.slice('Program log: '.length),\n                    txid\n                  });\n                }\n              }\n            }\n\n            throw new _1.MangoError({\n              message: JSON.stringify(simulateResult.err),\n              txid\n            });\n          }\n\n          throw new _1.MangoError({\n            message: 'Transaction failed',\n            txid\n          });\n        } finally {\n          done = true;\n        } // console.log('Latency', txid, getUnixTs() - startTime);\n\n\n        return txid;\n      }\n    });\n  }\n\n  awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let done = false;\n      const confirmLevels = ['finalized'];\n\n      if (confirmLevel === 'confirmed') {\n        confirmLevels.push('confirmed');\n      } else if (confirmLevel === 'processed') {\n        confirmLevels.push('confirmed');\n        confirmLevels.push('processed');\n      }\n\n      let subscriptionId;\n      const result = yield new Promise((resolve, reject) => {\n        (() => __awaiter(this, void 0, void 0, function* () {\n          setTimeout(() => {\n            if (done) {\n              return;\n            }\n\n            done = true;\n            console.log('Timed out for txid: ', txid);\n            reject({\n              timeout: true\n            });\n          }, timeout);\n\n          try {\n            subscriptionId = this.connection.onSignature(txid, (result, context) => {\n              subscriptionId = undefined;\n              done = true;\n\n              if (result.err) {\n                reject(result.err);\n              } else {\n                this.lastSlot = context === null || context === void 0 ? void 0 : context.slot;\n                resolve(result);\n              }\n            }, 'processed');\n          } catch (e) {\n            done = true;\n            console.log('WS error in setup', txid, e);\n          }\n\n          let retrySleep = 400;\n\n          while (!done) {\n            // eslint-disable-next-line no-loop-func\n            yield utils_1.sleep(retrySleep);\n\n            (() => __awaiter(this, void 0, void 0, function* () {\n              var _a;\n\n              try {\n                const response = yield this.connection.getSignatureStatuses([txid]);\n                const result = response && response.value[0];\n\n                if (!done) {\n                  if (!result) {// console.log('REST null result for', txid, result);\n                  } else if (result.err) {\n                    console.log('REST error for', txid, result);\n                    done = true;\n                    reject(result.err);\n                  } else if (!(result.confirmations || confirmLevels.includes(result.confirmationStatus))) {\n                    console.log('REST not confirmed', txid, result);\n                  } else {\n                    this.lastSlot = (_a = response === null || response === void 0 ? void 0 : response.context) === null || _a === void 0 ? void 0 : _a.slot;\n                    console.log('REST confirmed', txid, result);\n                    done = true;\n                    resolve(result);\n                  }\n                }\n              } catch (e) {\n                if (!done) {\n                  console.log('REST connection error: txid', txid, e);\n                }\n              }\n            }))();\n\n            if (retrySleep <= 1600) {\n              retrySleep = retrySleep * 2;\n            }\n          }\n        }))();\n      });\n\n      if (subscriptionId) {\n        this.connection.removeSignatureListener(subscriptionId).catch(e => {\n          console.log('WS error in cleanup', e);\n        });\n      }\n\n      done = true;\n      return result;\n    });\n  }\n\n  updateRecentBlockhash(blockhashTimes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = exports.getUnixTs();\n      const blockhash = (yield this.connection.getRecentBlockhash(this.blockhashCommitment)).blockhash;\n      blockhashTimes.push({\n        blockhash,\n        timestamp: now\n      });\n      const blockhashTime = blockhashTimes.length >= this.maxStoredBlockhashes ? blockhashTimes.shift() : blockhashTimes[0];\n      this.timeout = 90 - (now - blockhashTime.timestamp);\n      this.recentBlockhash = blockhashTime.blockhash;\n      this.recentBlockhashTime = blockhashTime.timestamp;\n    });\n  }\n  /**\n   * Maintain a timeout of 30 seconds\n   * @param client\n   */\n\n\n  maintainTimeouts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const blockhashTimes = []; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        yield this.updateRecentBlockhash(blockhashTimes);\n        yield utils_1.sleep(10);\n      }\n    });\n  }\n  /**\n   * Create a new Mango group\n   */\n\n\n  initMangoGroup(quoteMint, msrmMint, dexProgram, feesVault, // owned by Mango DAO token governance\n  validInterval, quoteOptimalUtil, quoteOptimalRate, quoteMaxRate, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const accountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.MangoGroupLayout.span, this.programId);\n      const {\n        signerKey,\n        signerNonce\n      } = yield utils_1.createSignerKeyAndNonce(this.programId, accountInstruction.account.publicKey);\n      const quoteVaultAccount = new web3_js_1.Keypair();\n      const quoteVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, payer.publicKey, quoteVaultAccount.publicKey, quoteMint, signerKey);\n      const insuranceVaultAccount = new web3_js_1.Keypair();\n      const insuranceVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, payer.publicKey, insuranceVaultAccount.publicKey, quoteMint, signerKey);\n      const quoteNodeBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.NodeBankLayout.span, this.programId);\n      const quoteRootBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.RootBankLayout.span, this.programId);\n      const cacheAccountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.MangoCacheLayout.span, this.programId);\n      const createAccountsTransaction = new web3_js_1.Transaction();\n      createAccountsTransaction.add(accountInstruction.instruction);\n      createAccountsTransaction.add(...quoteVaultAccountInstructions);\n      createAccountsTransaction.add(quoteNodeBankAccountInstruction.instruction);\n      createAccountsTransaction.add(quoteRootBankAccountInstruction.instruction);\n      createAccountsTransaction.add(cacheAccountInstruction.instruction);\n      createAccountsTransaction.add(...insuranceVaultAccountInstructions);\n      const signers = [accountInstruction.account, quoteVaultAccount, quoteNodeBankAccountInstruction.account, quoteRootBankAccountInstruction.account, cacheAccountInstruction.account, insuranceVaultAccount];\n      yield this.sendTransaction(createAccountsTransaction, payer, signers); // If valid msrmMint passed in, then create new msrmVault\n\n      let msrmVaultPk;\n\n      if (!msrmMint.equals(utils_1.zeroKey)) {\n        const msrmVaultAccount = new web3_js_1.Keypair();\n        const msrmVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, payer.publicKey, msrmVaultAccount.publicKey, msrmMint, signerKey);\n        const createMsrmVaultTransaction = new web3_js_1.Transaction();\n        createMsrmVaultTransaction.add(...msrmVaultAccountInstructions);\n        msrmVaultPk = msrmVaultAccount.publicKey;\n        yield this.sendTransaction(createMsrmVaultTransaction, payer, [msrmVaultAccount]);\n      } else {\n        msrmVaultPk = utils_1.zeroKey;\n      }\n\n      const initMangoGroupInstruction = instruction_1.makeInitMangoGroupInstruction(this.programId, accountInstruction.account.publicKey, signerKey, payer.publicKey, quoteMint, quoteVaultAccount.publicKey, quoteNodeBankAccountInstruction.account.publicKey, quoteRootBankAccountInstruction.account.publicKey, insuranceVaultAccount.publicKey, msrmVaultPk, feesVault, cacheAccountInstruction.account.publicKey, dexProgram, new bn_js_1.default(signerNonce), new bn_js_1.default(validInterval), fixednum_1.I80F48.fromNumber(quoteOptimalUtil), fixednum_1.I80F48.fromNumber(quoteOptimalRate), fixednum_1.I80F48.fromNumber(quoteMaxRate));\n      const initMangoGroupTransaction = new web3_js_1.Transaction();\n      initMangoGroupTransaction.add(initMangoGroupInstruction);\n      yield this.sendTransaction(initMangoGroupTransaction, payer, []);\n      return accountInstruction.account.publicKey;\n    });\n  }\n  /**\n   * Retrieve information about a Mango Group\n   */\n\n\n  getMangoGroup(mangoGroup) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const accountInfo = yield this.connection.getAccountInfo(mangoGroup);\n      const decoded = layout_1.MangoGroupLayout.decode(accountInfo == null ? undefined : accountInfo.data);\n      return new MangoGroup_1.default(mangoGroup, decoded);\n    });\n  }\n  /**\n   * DEPRECATED - Create a new Mango Account on a given group\n   */\n\n\n  initMangoAccount(mangoGroup, owner) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const accountInstruction = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, layout_1.MangoAccountLayout.span, this.programId);\n      const initMangoAccountInstruction = instruction_1.makeInitMangoAccountInstruction(this.programId, mangoGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey); // Add all instructions to one atomic transaction\n\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(accountInstruction.instruction);\n      transaction.add(initMangoAccountInstruction);\n      const additionalSigners = [accountInstruction.account];\n      yield this.sendTransaction(transaction, owner, additionalSigners);\n      return accountInstruction.account.publicKey;\n    });\n  }\n  /**\n   * Create a new Mango Account (PDA) on a given group\n   */\n\n\n  createMangoAccount(mangoGroup, owner, accountNum, payerPk) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const payer = payerPk !== null && payerPk !== void 0 ? payerPk : owner.publicKey;\n      const accountNumBN = new bn_js_1.default(accountNum);\n      const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), owner.publicKey.toBytes(), accountNumBN.toBuffer('le', 8)], this.programId);\n      const createMangoAccountInstruction = instruction_1.makeCreateMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, accountNumBN, payer); // Add all instructions to one atomic transaction\n\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(createMangoAccountInstruction);\n      yield this.sendTransaction(transaction, owner, []);\n      return mangoAccountPk;\n    });\n  }\n  /**\n   * Upgrade a Mango Account from V0 (not deletable) to V1 (deletable)\n   */\n\n\n  upgradeMangoAccountV0V1(mangoGroup, owner, accountNum) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const accountNumBN = new bn_js_1.default(accountNum);\n      const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), owner.publicKey.toBytes(), accountNumBN.toBuffer()], this.programId);\n      const upgradeMangoAccountInstruction = instruction_1.makeUpgradeMangoAccountV0V1Instruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(upgradeMangoAccountInstruction);\n      yield this.sendTransaction(transaction, owner, []);\n      return mangoAccountPk;\n    });\n  }\n  /**\n   * Retrieve information about a Mango Account\n   */\n\n\n  getMangoAccount(mangoAccountPk, dexProgramId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const acc = yield this.connection.getAccountInfo(mangoAccountPk, 'processed');\n      const mangoAccount = new MangoAccount_1.default(mangoAccountPk, layout_1.MangoAccountLayout.decode(acc == null ? undefined : acc.data));\n      yield mangoAccount.loadOpenOrders(this.connection, dexProgramId);\n      return mangoAccount;\n    });\n  }\n  /**\n   * Create a new Mango Account and deposit some tokens in a single transaction\n   *\n   * @param rootBank The RootBank for the deposit currency\n   * @param nodeBank The NodeBank asociated with the RootBank\n   * @param vault The token account asociated with the NodeBank\n   * @param tokenAcc The token account to transfer from\n   * @param info An optional UI name for the account\n   */\n\n\n  initMangoAccountAndDeposit(mangoGroup, owner, rootBank, nodeBank, vault, tokenAcc, quantity, info) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const accountInstruction = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, layout_1.MangoAccountLayout.span, this.programId);\n      const initMangoAccountInstruction = instruction_1.makeInitMangoAccountInstruction(this.programId, mangoGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey);\n      transaction.add(accountInstruction.instruction);\n      transaction.add(initMangoAccountInstruction);\n      const additionalSigners = [accountInstruction.account];\n      const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n      const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n      let wrappedSolAccount = null;\n\n      if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) && tokenAcc.toBase58() === owner.publicKey.toBase58()) {\n        wrappedSolAccount = new web3_js_1.Keypair();\n        const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n          fromPubkey: owner.publicKey,\n          newAccountPubkey: wrappedSolAccount.publicKey,\n          lamports,\n          space: 165,\n          programId: spl_token_1.TOKEN_PROGRAM_ID\n        }));\n        transaction.add(token_instructions_1.initializeAccount({\n          account: wrappedSolAccount.publicKey,\n          mint: token_instructions_1.WRAPPED_SOL_MINT,\n          owner: owner.publicKey\n        }));\n        additionalSigners.push(wrappedSolAccount);\n      }\n\n      const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n      const instruction = instruction_1.makeDepositInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoGroup.mangoCache, accountInstruction.account.publicKey, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);\n      transaction.add(instruction);\n\n      if (info) {\n        const addAccountNameinstruction = instruction_1.makeAddMangoAccountInfoInstruction(this.programId, mangoGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey, info);\n        transaction.add(addAccountNameinstruction);\n      }\n\n      if (wrappedSolAccount) {\n        transaction.add(token_instructions_1.closeAccount({\n          source: wrappedSolAccount.publicKey,\n          destination: owner.publicKey,\n          owner: owner.publicKey\n        }));\n      }\n\n      yield this.sendTransaction(transaction, owner, additionalSigners);\n      return accountInstruction.account.publicKey.toString();\n    });\n  }\n  /**\n   * Create a new Mango Account (PDA) and deposit some tokens in a single transaction\n   *\n   * @param rootBank The RootBank for the deposit currency\n   * @param nodeBank The NodeBank asociated with the RootBank\n   * @param vault The token account asociated with the NodeBank\n   * @param tokenAcc The token account to transfer from\n   * @param info An optional UI name for the account\n   */\n\n\n  createMangoAccountAndDeposit(mangoGroup, owner, rootBank, nodeBank, vault, tokenAcc, quantity, accountNum, info, referrerPk, payerPk) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const payer = payerPk !== null && payerPk !== void 0 ? payerPk : owner.publicKey;\n      const accountNumBN = new bn_js_1.default(accountNum);\n      const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), owner.publicKey.toBytes(), accountNumBN.toArrayLike(Buffer, 'le', 8)], this.programId);\n      const createMangoAccountInstruction = instruction_1.makeCreateMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, accountNumBN, payer);\n      transaction.add(createMangoAccountInstruction);\n\n      if (referrerPk) {\n        const [referrerMemoryPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccountPk.toBytes(), new Buffer('ReferrerMemory', 'utf-8')], this.programId);\n        const setReferrerInstruction = instruction_1.makeSetReferrerMemoryInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, referrerMemoryPk, referrerPk, owner.publicKey);\n        transaction.add(setReferrerInstruction);\n      }\n\n      const additionalSigners = [];\n      const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n      const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n      let wrappedSolAccount = null;\n\n      if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) && tokenAcc.toBase58() === owner.publicKey.toBase58()) {\n        wrappedSolAccount = new web3_js_1.Keypair();\n        const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n          fromPubkey: owner.publicKey,\n          newAccountPubkey: wrappedSolAccount.publicKey,\n          lamports,\n          space: 165,\n          programId: spl_token_1.TOKEN_PROGRAM_ID\n        }));\n        transaction.add(token_instructions_1.initializeAccount({\n          account: wrappedSolAccount.publicKey,\n          mint: token_instructions_1.WRAPPED_SOL_MINT,\n          owner: owner.publicKey\n        }));\n        additionalSigners.push(wrappedSolAccount);\n      }\n\n      const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n      const instruction = instruction_1.makeDepositInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoGroup.mangoCache, mangoAccountPk, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);\n      transaction.add(instruction);\n\n      if (info) {\n        const addAccountNameinstruction = instruction_1.makeAddMangoAccountInfoInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, info);\n        transaction.add(addAccountNameinstruction);\n      }\n\n      if (wrappedSolAccount) {\n        transaction.add(token_instructions_1.closeAccount({\n          source: wrappedSolAccount.publicKey,\n          destination: owner.publicKey,\n          owner: owner.publicKey\n        }));\n      }\n\n      const txid = yield this.sendTransaction(transaction, owner, additionalSigners);\n      return [mangoAccountPk.toString(), txid];\n    });\n  }\n  /**\n   * Deposit tokens in a Mango Account\n   *\n   * @param rootBank The RootBank for the deposit currency\n   * @param nodeBank The NodeBank asociated with the RootBank\n   * @param vault The token account asociated with the NodeBank\n   * @param tokenAcc The token account to transfer from\n   */\n\n\n  deposit(mangoGroup, mangoAccount, owner, rootBank, nodeBank, vault, tokenAcc, quantity) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n      const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n      let wrappedSolAccount = null;\n\n      if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) && tokenAcc.toBase58() === owner.publicKey.toBase58()) {\n        wrappedSolAccount = new web3_js_1.Keypair();\n        const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n          fromPubkey: owner.publicKey,\n          newAccountPubkey: wrappedSolAccount.publicKey,\n          lamports,\n          space: 165,\n          programId: spl_token_1.TOKEN_PROGRAM_ID\n        }));\n        transaction.add(token_instructions_1.initializeAccount({\n          account: wrappedSolAccount.publicKey,\n          mint: token_instructions_1.WRAPPED_SOL_MINT,\n          owner: owner.publicKey\n        }));\n        additionalSigners.push(wrappedSolAccount);\n      }\n\n      const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n      const instruction = instruction_1.makeDepositInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);\n      transaction.add(instruction);\n\n      if (wrappedSolAccount) {\n        transaction.add(token_instructions_1.closeAccount({\n          source: wrappedSolAccount.publicKey,\n          destination: owner.publicKey,\n          owner: owner.publicKey\n        }));\n      }\n\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n  /**\n   * Withdraw tokens from a Mango Account\n   *\n   * @param rootBank The RootBank for the withdrawn currency\n   * @param nodeBank The NodeBank asociated with the RootBank\n   * @param vault The token account asociated with the NodeBank\n   * @param allowBorrow Whether to borrow tokens if there are not enough deposits for the withdrawal\n   */\n\n\n  withdraw(mangoGroup, mangoAccount, owner, rootBank, nodeBank, vault, quantity, allowBorrow) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n      const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n      let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner.publicKey);\n      let wrappedSolAccount = null;\n\n      if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n        wrappedSolAccount = new web3_js_1.Keypair();\n        tokenAcc = wrappedSolAccount.publicKey;\n        const space = 165;\n        const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'processed');\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n          fromPubkey: owner.publicKey,\n          newAccountPubkey: tokenAcc,\n          lamports,\n          space,\n          programId: spl_token_1.TOKEN_PROGRAM_ID\n        }));\n        transaction.add(token_instructions_1.initializeAccount({\n          account: tokenAcc,\n          mint: token_instructions_1.WRAPPED_SOL_MINT,\n          owner: owner.publicKey\n        }));\n        additionalSigners.push(wrappedSolAccount);\n      } else {\n        const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc);\n\n        if (!tokenAccExists) {\n          transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, owner.publicKey, owner.publicKey));\n        }\n      }\n\n      const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n      const instruction = instruction_1.makeWithdrawInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, rootBank, nodeBank, vault, tokenAcc, mangoGroup.signerKey, mangoAccount.spotOpenOrders, nativeQuantity, allowBorrow);\n      transaction.add(instruction);\n\n      if (wrappedSolAccount) {\n        transaction.add(token_instructions_1.closeAccount({\n          source: wrappedSolAccount.publicKey,\n          destination: owner.publicKey,\n          owner: owner.publicKey\n        }));\n      }\n\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  withdrawAll(mangoGroup, mangoAccount, owner) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transactionsAndSigners = [];\n\n      for (const rootBank of mangoGroup.rootBankAccounts) {\n        const transactionAndSigners = {\n          transaction: new web3_js_1.Transaction(),\n          signers: []\n        };\n\n        if (rootBank) {\n          const tokenIndex = mangoGroup.getRootBankIndex(rootBank === null || rootBank === void 0 ? void 0 : rootBank.publicKey);\n          const tokenMint = mangoGroup.tokens[tokenIndex].mint; // const decimals = mangoGroup.tokens[tokenIndex].decimals;\n\n          if (mangoAccount.deposits[tokenIndex].isPos()) {\n            let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner.publicKey);\n            let wrappedSolAccount = null;\n\n            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n              wrappedSolAccount = new web3_js_1.Keypair();\n              tokenAcc = wrappedSolAccount.publicKey;\n              const space = 165;\n              const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'processed');\n              transactionAndSigners.transaction.add(web3_js_1.SystemProgram.createAccount({\n                fromPubkey: owner.publicKey,\n                newAccountPubkey: tokenAcc,\n                lamports,\n                space,\n                programId: spl_token_1.TOKEN_PROGRAM_ID\n              }));\n              transactionAndSigners.transaction.add(token_instructions_1.initializeAccount({\n                account: tokenAcc,\n                mint: token_instructions_1.WRAPPED_SOL_MINT,\n                owner: owner.publicKey\n              }));\n              transactionAndSigners.signers.push(wrappedSolAccount);\n            } else {\n              const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc, 'recent');\n\n              if (!tokenAccExists) {\n                transactionAndSigners.transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, owner.publicKey, owner.publicKey));\n              }\n            }\n\n            const instruction = instruction_1.makeWithdrawInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, rootBank.publicKey, rootBank.nodeBanks[0], rootBank.nodeBankAccounts[0].vault, tokenAcc, mangoGroup.signerKey, mangoAccount.spotOpenOrders, new bn_js_1.default('18446744073709551615'), // u64::MAX to withdraw errything\n            false);\n            transactionAndSigners.transaction.add(instruction);\n\n            if (wrappedSolAccount) {\n              transactionAndSigners.transaction.add(token_instructions_1.closeAccount({\n                source: wrappedSolAccount.publicKey,\n                destination: owner.publicKey,\n                owner: owner.publicKey\n              }));\n            }\n          }\n        }\n\n        transactionsAndSigners.push(transactionAndSigners);\n      }\n\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer: owner\n      });\n\n      if (signedTransactions) {\n        for (const signedTransaction of signedTransactions) {\n          if (signedTransaction.instructions.length == 0) {\n            continue;\n          }\n\n          const txid = yield this.sendSignedTransaction({\n            signedTransaction\n          });\n          console.log(txid);\n        }\n      } else {\n        throw new Error('Unable to sign Settle All transaction');\n      }\n    });\n  } // Keeper functions\n\n  /**\n   * Called by the Keeper to cache interest rates from the RootBanks\n   */\n\n\n  cacheRootBanks(mangoGroup, mangoCache, rootBanks, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cacheRootBanksInstruction = instruction_1.makeCacheRootBankInstruction(this.programId, mangoGroup, mangoCache, rootBanks);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(cacheRootBanksInstruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n  /**\n   * Called by the Keeper to cache prices from the Oracles\n   */\n\n\n  cachePrices(mangoGroup, mangoCache, oracles, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cachePricesInstruction = instruction_1.makeCachePricesInstruction(this.programId, mangoGroup, mangoCache, oracles);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(cachePricesInstruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n  /**\n   * Called by the Keeper to cache perp market funding\n   */\n\n\n  cachePerpMarkets(mangoGroup, mangoCache, perpMarkets, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cachePerpMarketsInstruction = instruction_1.makeCachePerpMarketsInstruction(this.programId, mangoGroup, mangoCache, perpMarkets);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(cachePerpMarketsInstruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n  /**\n   * Called by the Keeper to update interest rates on the RootBanks\n   */\n\n\n  updateRootBank(mangoGroup, rootBank, nodeBanks, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const updateRootBanksInstruction = instruction_1.makeUpdateRootBankInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, rootBank, nodeBanks);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(updateRootBanksInstruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n  /**\n   * Called by the Keeper to process events on the Perp order book\n   */\n\n\n  consumeEvents(mangoGroup, perpMarket, mangoAccounts, payer, limit) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const consumeEventsInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, mangoAccounts, limit);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(consumeEventsInstruction);\n      return yield this.sendTransaction(transaction, payer, [], null);\n    });\n  }\n  /**\n   * Called by the Keeper to update funding on the perp markets\n   */\n\n\n  updateFunding(mangoGroup, mangoCache, perpMarket, bids, asks, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const updateFundingInstruction = instruction_1.makeUpdateFundingInstruction(this.programId, mangoGroup, mangoCache, perpMarket, bids, asks);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(updateFundingInstruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n  /**\n   * Retrieve information about a perp market\n   */\n\n\n  getPerpMarket(perpMarketPk, baseDecimal, quoteDecimal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const acc = yield this.connection.getAccountInfo(perpMarketPk);\n      const perpMarket = new PerpMarket_1.default(perpMarketPk, baseDecimal, quoteDecimal, layout_1.PerpMarketLayout.decode(acc === null || acc === void 0 ? void 0 : acc.data));\n      return perpMarket;\n    });\n  }\n  /**\n   * Place an order on a perp market\n   *\n   * @param clientOrderId An optional id that can be used to correlate events related to your order\n   * @param bookSideInfo Account info for asks if side === bid, bids if side === ask. If this is given, crank instruction is added\n   */\n\n\n  placePerpOrder(mangoGroup, mangoAccount, mangoCache, // TODO - remove; already in MangoGroup\n  perpMarket, owner, side, price, quantity, orderType) {\n    let clientOrderId = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let bookSideInfo = arguments.length > 10 ? arguments[10] : undefined;\n    let reduceOnly = arguments.length > 11 ? arguments[11] : undefined;\n    let referrerMangoAccountPk = arguments.length > 12 ? arguments[12] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      const instruction = instruction_1.makePlacePerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.spotOpenOrders, nativePrice, nativeQuantity, new bn_js_1.default(clientOrderId), side, orderType, reduceOnly, referrerMangoAccountPk);\n      transaction.add(instruction);\n\n      if (bookSideInfo) {\n        // If this data is already parsed as BookSide, use that instead of decoding again\n        let bookSide = bookSideInfo['parsed'];\n\n        if (bookSide === undefined) {\n          bookSide = bookSideInfo.data ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data)) : [];\n        }\n\n        const accounts = new Set();\n        accounts.add(mangoAccount.publicKey.toBase58());\n\n        for (const order of bookSide) {\n          accounts.add(order.owner.toBase58());\n\n          if (accounts.size >= 10) {\n            break;\n          }\n        }\n\n        const consumeInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts).map(s => new web3_js_1.PublicKey(s)).sort(), new bn_js_1.default(4));\n        transaction.add(consumeInstruction);\n      }\n\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n  /**\n   * Place an order on a perp market\n   *\n   * @param clientOrderId An optional id that can be used to correlate events related to your order\n   * @param bookSideInfo Account info for asks if side === bid, bids if side === ask. If this is given, crank instruction is added\n   */\n\n\n  placePerpOrder2(mangoGroup, mangoAccount, perpMarket, owner, side, price, quantity, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      options = options ? options : {};\n      let {\n        maxQuoteQuantity,\n        limit,\n        orderType,\n        clientOrderId,\n        bookSideInfo,\n        reduceOnly,\n        referrerMangoAccountPk,\n        expiryTimestamp\n      } = options;\n      limit = limit || 20;\n      clientOrderId = clientOrderId === undefined ? 0 : clientOrderId;\n      orderType = orderType || 'limit';\n      const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);\n      const maxQuoteQuantityLots = maxQuoteQuantity ? perpMarket.uiQuoteToLots(maxQuoteQuantity) : utils_1.I64_MAX_BN;\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      const instruction = instruction_1.makePlacePerpOrder2Instruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.getOpenOrdersKeysInBasketPacked(), nativePrice, nativeQuantity, maxQuoteQuantityLots, new bn_js_1.default(clientOrderId), side, new bn_js_1.default(limit), orderType, reduceOnly, referrerMangoAccountPk, expiryTimestamp ? new bn_js_1.default(Math.floor(expiryTimestamp)) : utils_1.ZERO_BN);\n      transaction.add(instruction);\n\n      if (bookSideInfo) {\n        // If this data is already parsed as BookSide, use that instead of decoding again\n        let bookSide = bookSideInfo['parsed'];\n\n        if (bookSide === undefined) {\n          bookSide = bookSideInfo.data ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data)) : [];\n        }\n\n        const accounts = new Set();\n        accounts.add(mangoAccount.publicKey.toBase58());\n\n        for (const order of bookSide) {\n          accounts.add(order.owner.toBase58());\n\n          if (accounts.size >= 10) {\n            break;\n          }\n        }\n\n        const consumeInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts).map(s => new web3_js_1.PublicKey(s)).sort(), new bn_js_1.default(4));\n        transaction.add(consumeInstruction);\n      }\n\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n  /**\n   * Cancel an order on a perp market\n   *\n   * @param invalidIdOk Don't throw error if order is invalid\n   */\n\n\n  cancelPerpOrder(mangoGroup, mangoAccount, owner, perpMarket, order) {\n    let invalidIdOk = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeCancelPerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, order, invalidIdOk);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n  /**\n   * Cancel all perp orders across all markets\n   */\n\n\n  cancelAllPerpOrders(group, perpMarkets, mangoAccount, owner) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      let tx = new web3_js_1.Transaction();\n      const transactions = []; // Determine which market indexes have open orders\n\n      const hasOrders = new Array(group.perpMarkets.length).fill(false);\n\n      for (let i = 0; i < mangoAccount.orderMarket.length; i++) {\n        if (mangoAccount.orderMarket[i] !== layout_1.FREE_ORDER_SLOT) {\n          hasOrders[mangoAccount.orderMarket[i]] = true;\n        }\n      }\n\n      for (let i = 0; i < group.perpMarkets.length; i++) {\n        if (!hasOrders[i]) continue;\n        const pmi = group.perpMarkets[i];\n        if (pmi.isEmpty()) continue;\n        const perpMarket = perpMarkets.find(pm => pm.publicKey.equals(pmi.perpMarket));\n        if (perpMarket === undefined) continue;\n        const cancelAllInstr = instruction_1.makeCancelAllPerpOrdersInstruction(this.programId, group.publicKey, mangoAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, new bn_js_1.default(20));\n        tx.add(cancelAllInstr);\n\n        if (tx.instructions.length === 2) {\n          transactions.push(tx);\n          tx = new web3_js_1.Transaction();\n        }\n      }\n\n      if (tx.instructions.length > 0) {\n        transactions.push(tx);\n      }\n\n      const transactionsAndSigners = transactions.map(tx => ({\n        transaction: tx,\n        signers: []\n      }));\n\n      if (transactionsAndSigners.length === 0) {\n        throw new Error('No orders to cancel');\n      } // Sign multiple transactions at once for better UX\n\n\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer: owner\n      });\n\n      if (signedTransactions) {\n        return yield Promise.all(signedTransactions.map(signedTransaction => this.sendSignedTransaction({\n          signedTransaction\n        })));\n      } else {\n        throw new Error('Unable to sign all CancelAllPerpOrders transactions');\n      }\n    });\n  }\n  /*\n  async loadPerpMarkets(perpMarkets: PublicKey[]): Promise<PerpMarket[]> {\n    const accounts = await Promise.all(\n      perpMarkets.map((pk) => this.connection.getAccountInfo(pk)),\n    );\n       const parsedPerpMarkets: PerpMarket[] = [];\n       for (let i = 0; i < accounts.length; i++) {\n      const acc = accounts[i];\n      if (acc) {\n        const decoded = PerpMarketLayout.decode(acc.data);\n        parsedPerpMarkets.push(new PerpMarket(perpMarkets[i], decoded));\n      }\n    }\n       return parsedPerpMarkets;\n  }\n  */\n\n  /**\n   * Add a new oracle to a group\n   */\n\n\n  addOracle(mangoGroup, oracle, admin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeAddOracleInstruction(this.programId, mangoGroup.publicKey, oracle, admin.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n  /**\n   * Set the price of a 'stub' type oracle\n   */\n\n\n  setOracle(mangoGroup, oracle, admin, price) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeSetOracleInstruction(this.programId, mangoGroup.publicKey, oracle, admin.publicKey, price);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  addSpotMarket(mangoGroup, oracle, spotMarket, mint, admin, maintLeverage, initLeverage, liquidationFee, optimalUtil, optimalRate, maxRate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const vaultAccount = new web3_js_1.Keypair();\n      const vaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, admin.publicKey, vaultAccount.publicKey, mint, mangoGroup.signerKey);\n      const nodeBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.NodeBankLayout.span, this.programId);\n      const rootBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.RootBankLayout.span, this.programId);\n      const instruction = instruction_1.makeAddSpotMarketInstruction(this.programId, mangoGroup.publicKey, oracle, spotMarket, mangoGroup.dexProgramId, mint, nodeBankAccountInstruction.account.publicKey, vaultAccount.publicKey, rootBankAccountInstruction.account.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(optimalUtil), fixednum_1.I80F48.fromNumber(optimalRate), fixednum_1.I80F48.fromNumber(maxRate));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(...vaultAccountInstructions);\n      transaction.add(nodeBankAccountInstruction.instruction);\n      transaction.add(rootBankAccountInstruction.instruction);\n      transaction.add(instruction);\n      const additionalSigners = [vaultAccount, nodeBankAccountInstruction.account, rootBankAccountInstruction.account];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n  /**\n   * Make sure mangoAccount has recent and valid inMarginBasket and spotOpenOrders\n   */\n\n\n  placeSpotOrder(mangoGroup, mangoAccount, mangoCache, spotMarket, owner, side, price, size, orderType, clientId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const limitPrice = spotMarket.priceNumberToLots(price);\n      const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size); // TODO implement srm vault fee discount\n      // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));\n\n      const feeTier = serum_1.getFeeTier(0, utils_1.nativeToUi(0, 0));\n      const rates = serum_1.getFeeRates(feeTier);\n      const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket.baseSizeNumberToLots(size).mul(spotMarket.priceNumberToLots(price)));\n\n      if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {\n        throw new Error('size too small');\n      }\n\n      if (limitPrice.lte(utils_1.ZERO_BN)) {\n        throw new Error('invalid price');\n      }\n\n      const selfTradeBehavior = 'decrementTake';\n      clientId = clientId !== null && clientId !== void 0 ? clientId : new bn_js_1.default(Date.now());\n      const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n\n      if (!mangoGroup.rootBankAccounts.filter(a => !!a).length) {\n        yield mangoGroup.loadRootBanks(this.connection);\n      }\n\n      const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];\n      const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n      const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n      const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n\n      if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {\n        throw new Error('Invalid or missing banks');\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      const openOrdersKeys = []; // Only pass in open orders if in margin basket or current market index, and\n      // the only writable account should be OpenOrders for current market index\n\n      for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n        let pubkey = utils_1.zeroKey;\n        let isWritable = false;\n\n        if (i === spotMarketIndex) {\n          isWritable = true;\n\n          if (mangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n            // open orders missing for this market; create a new one now\n            const openOrdersSpace = serum_1.OpenOrders.getLayout(mangoGroup.dexProgramId).span;\n            const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'processed');\n            const accInstr = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, openOrdersSpace, mangoGroup.dexProgramId, openOrdersLamports);\n            const initOpenOrders = instruction_1.makeInitSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, mangoGroup.signerKey);\n            const initTx = new web3_js_1.Transaction();\n            initTx.add(accInstr.instruction);\n            initTx.add(initOpenOrders);\n            yield this.sendTransaction(initTx, owner, [accInstr.account]);\n            pubkey = accInstr.account.publicKey;\n          } else {\n            pubkey = mangoAccount.spotOpenOrders[i];\n          }\n        } else if (mangoAccount.inMarginBasket[i]) {\n          pubkey = mangoAccount.spotOpenOrders[i];\n        }\n\n        openOrdersKeys.push({\n          pubkey,\n          isWritable\n        });\n      }\n\n      const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n      const placeOrderInstruction = instruction_1.makePlaceSpotOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, mangoGroup.srmVault, // TODO: choose msrm vault if it has any deposits\n      openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientId);\n      transaction.add(placeOrderInstruction);\n\n      if (spotMarketIndex > 0) {\n        console.log(spotMarketIndex - 1, mangoAccount.spotOpenOrders[spotMarketIndex - 1].toBase58(), openOrdersKeys[spotMarketIndex - 1].pubkey.toBase58());\n      }\n\n      const txid = yield this.sendTransaction(transaction, owner, additionalSigners); // update MangoAccount to have new OpenOrders pubkey\n\n      mangoAccount.spotOpenOrders[spotMarketIndex] = openOrdersKeys[spotMarketIndex].pubkey;\n      mangoAccount.inMarginBasket[spotMarketIndex] = true;\n      console.log(spotMarketIndex, mangoAccount.spotOpenOrders[spotMarketIndex].toBase58(), openOrdersKeys[spotMarketIndex].pubkey.toBase58());\n      return txid;\n    });\n  }\n  /**\n   * Make sure mangoAccount has recent and valid inMarginBasket and spotOpenOrders\n   */\n\n\n  placeSpotOrder2(mangoGroup, mangoAccount, spotMarket, owner, side, price, size, orderType, clientOrderId, useMsrmVault) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const limitPrice = spotMarket.priceNumberToLots(price);\n      const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);\n      const allTransactions = []; // TODO implement srm vault fee discount\n      // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));\n\n      const feeTier = serum_1.getFeeTier(0, utils_1.nativeToUi(0, 0));\n      const rates = serum_1.getFeeRates(feeTier);\n      const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket.baseSizeNumberToLots(size).mul(spotMarket.priceNumberToLots(price)));\n\n      if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {\n        throw new Error('size too small');\n      }\n\n      if (limitPrice.lte(utils_1.ZERO_BN)) {\n        throw new Error('invalid price');\n      }\n\n      const selfTradeBehavior = 'decrementTake';\n      const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n\n      if (!mangoGroup.rootBankAccounts.filter(a => !!a).length) {\n        yield mangoGroup.loadRootBanks(this.connection);\n      }\n\n      let feeVault;\n\n      if (useMsrmVault) {\n        feeVault = mangoGroup.msrmVault;\n      } else if (useMsrmVault === false) {\n        feeVault = mangoGroup.srmVault;\n      } else {\n        const totalMsrm = yield this.connection.getTokenAccountBalance(mangoGroup.msrmVault);\n        feeVault = ((_a = totalMsrm === null || totalMsrm === void 0 ? void 0 : totalMsrm.value) === null || _a === void 0 ? void 0 : _a.uiAmount) && totalMsrm.value.uiAmount > 0 ? mangoGroup.msrmVault : mangoGroup.srmVault;\n      }\n\n      const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];\n      const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n      const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n      const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n\n      if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {\n        throw new Error('Invalid or missing banks');\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const openOrdersKeys = []; // Only pass in open orders if in margin basket or current market index, and\n      // the only writable account should be OpenOrders for current market index\n\n      let marketOpenOrdersKey = utils_1.zeroKey;\n      const initTx = new web3_js_1.Transaction();\n\n      for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n        let pubkey = utils_1.zeroKey;\n        let isWritable = false;\n\n        if (i === spotMarketIndex) {\n          isWritable = true;\n\n          if (mangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n            const spotMarketIndexBN = new bn_js_1.default(spotMarketIndex);\n            const [openOrdersPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccount.publicKey.toBytes(), spotMarketIndexBN.toArrayLike(Buffer, 'le', 8), new Buffer('OpenOrders', 'utf-8')], this.programId);\n\n            const initOpenOrders = _1.makeCreateSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.dexProgramId, openOrdersPk, spotMarket.publicKey, mangoGroup.signerKey);\n\n            initTx.add(initOpenOrders);\n            allTransactions.push(initTx);\n            pubkey = openOrdersPk;\n          } else {\n            pubkey = mangoAccount.spotOpenOrders[i];\n          }\n\n          marketOpenOrdersKey = pubkey;\n        } else if (mangoAccount.inMarginBasket[i]) {\n          pubkey = mangoAccount.spotOpenOrders[i];\n        } // new design does not require zero keys to be passed in\n\n\n        if (!pubkey.equals(utils_1.zeroKey)) {\n          openOrdersKeys.push({\n            pubkey,\n            isWritable\n          });\n        }\n      }\n\n      const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n      const placeOrderInstruction = instruction_1.makePlaceSpotOrder2Instruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, feeVault, openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : new bn_js_1.default(Date.now()));\n      transaction.add(placeOrderInstruction);\n      allTransactions.push(transaction);\n      const signers = [];\n      const transactionsAndSigners = allTransactions.map(tx => ({\n        transaction: tx,\n        signers\n      }));\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer: owner\n      });\n      const txids = [];\n\n      if (signedTransactions) {\n        for (const signedTransaction of signedTransactions) {\n          if (signedTransaction.instructions.length == 0) {\n            continue;\n          }\n\n          const txid = yield this.sendSignedTransaction({\n            signedTransaction\n          });\n          txids.push(txid);\n        } // update MangoAccount to have new OpenOrders pubkey\n        // We know this new key is in margin basket because if it was a full taker trade\n        // there is some leftover from fee rebate. If maker trade there's the order.\n        // and if it failed then we already exited before this line\n\n\n        mangoAccount.spotOpenOrders[spotMarketIndex] = marketOpenOrdersKey;\n        mangoAccount.inMarginBasket[spotMarketIndex] = true;\n        console.log(spotMarketIndex, mangoAccount.spotOpenOrders[spotMarketIndex].toBase58(), marketOpenOrdersKey.toBase58());\n      } else {\n        throw new Error('Unable to sign Settle All transaction');\n      }\n\n      return txids;\n    });\n  }\n\n  cancelSpotOrder(mangoGroup, mangoAccount, owner, spotMarket, order) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const instruction = instruction_1.makeCancelSpotOrderInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, order.openOrdersAddress, mangoGroup.signerKey, spotMarket['_decoded'].eventQueue, order);\n      transaction.add(instruction);\n      const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n      const marketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n\n      if (!mangoGroup.rootBankAccounts.length) {\n        yield mangoGroup.loadRootBanks(this.connection);\n      }\n\n      const baseRootBank = mangoGroup.rootBankAccounts[marketIndex];\n      const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n      const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n      const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n\n      if (!baseNodeBank || !quoteNodeBank) {\n        throw new Error('Invalid or missing node banks');\n      }\n\n      const settleFundsInstruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[marketIndex], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[marketIndex].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n      transaction.add(settleFundsInstruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  settleFunds(mangoGroup, mangoAccount, owner, spotMarket) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const marketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n      const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n\n      if (!mangoGroup.rootBankAccounts.length) {\n        yield mangoGroup.loadRootBanks(this.connection);\n      }\n\n      const baseRootBank = mangoGroup.rootBankAccounts[marketIndex];\n      const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n      const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n      const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n\n      if (!baseNodeBank || !quoteNodeBank) {\n        throw new Error('Invalid or missing node banks');\n      }\n\n      const instruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[marketIndex], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[marketIndex].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n  /**\n   * Assumes spotMarkets contains all Markets in MangoGroup in order\n   */\n\n\n  settleAll(mangoGroup, mangoAccount, spotMarkets, owner) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transactions = [];\n      let j = 0;\n\n      for (let i = 0; i < mangoGroup.spotMarkets.length; i++) {\n        if (mangoGroup.spotMarkets[i].isEmpty()) continue;\n        const spotMarket = spotMarkets[j];\n        j++;\n        const transaction = new web3_js_1.Transaction();\n        const openOrdersAccount = mangoAccount.spotOpenOrdersAccounts[i];\n        if (openOrdersAccount === undefined) continue;\n\n        if (openOrdersAccount.quoteTokenFree.toNumber() + openOrdersAccount['referrerRebatesAccrued'].toNumber() === 0 && openOrdersAccount.baseTokenFree.toNumber() === 0) {\n          continue;\n        }\n\n        const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n\n        if (!mangoGroup.rootBankAccounts.length) {\n          yield mangoGroup.loadRootBanks(this.connection);\n        }\n\n        const baseRootBank = mangoGroup.rootBankAccounts[i];\n        const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n        const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n        const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n\n        if (!baseNodeBank || !quoteNodeBank) {\n          throw new Error('Invalid or missing node banks');\n        }\n\n        const instruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[i], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[i].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n        transaction.add(instruction);\n        transactions.push(transaction);\n      }\n\n      const signers = [];\n      const transactionsAndSigners = transactions.map(tx => ({\n        transaction: tx,\n        signers\n      }));\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer: owner\n      });\n      const txids = [];\n\n      if (signedTransactions) {\n        for (const signedTransaction of signedTransactions) {\n          if (signedTransaction.instructions.length == 0) {\n            continue;\n          }\n\n          const txid = yield this.sendSignedTransaction({\n            signedTransaction\n          });\n          txids.push(txid);\n        }\n      } else {\n        throw new Error('Unable to sign Settle All transaction');\n      }\n\n      return txids;\n    });\n  }\n\n  fetchTopPnlAccountsFromRPC(mangoGroup, mangoCache, perpMarket, price, // should be the MangoCache price\n  sign, mangoAccounts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n      const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n\n      if (mangoAccounts === undefined) {\n        mangoAccounts = yield this.getAllMangoAccounts(mangoGroup, [], false);\n      }\n\n      return mangoAccounts.map(m => ({\n        publicKey: m.publicKey,\n        pnl: m.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price)\n      })).sort((a, b) => sign * a.pnl.cmp(b.pnl));\n    });\n  }\n\n  fetchTopPnlAccountsFromDB(mangoGroup, perpMarket, sign) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n      const order = sign === 1 ? 'ASC' : 'DESC';\n      const response = yield cross_fetch_1.default(`https://mango-transaction-log.herokuapp.com/v3/stats/ranked-pnl?market-index=${marketIndex}&order=${order}&limit=20`);\n      const data = yield response.json();\n      return data.map(m => ({\n        publicKey: new web3_js_1.PublicKey(m.pubkey),\n        pnl: fixednum_1.I80F48.fromNumber(m.pnl)\n      }));\n    });\n  }\n  /**\n   * Automatically fetch MangoAccounts for this PerpMarket\n   * Pick enough MangoAccounts that have opposite sign and send them in to get settled\n   */\n\n\n  settlePnl(mangoGroup, mangoCache, mangoAccount, perpMarket, quoteRootBank, price, // should be the MangoCache price\n  owner, mangoAccounts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // fetch all MangoAccounts filtered for having this perp market in basket\n      const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n      const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n      let pnl = mangoAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price);\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      let sign;\n\n      if (pnl.eq(fixednum_1.ZERO_I80F48)) {\n        // Can't settle pnl if there is no pnl\n        return null;\n      } else if (pnl.gt(fixednum_1.ZERO_I80F48)) {\n        sign = 1;\n      } else {\n        // Can settle fees first against perpmarket\n        sign = -1;\n\n        if (!quoteRootBank.nodeBankAccounts) {\n          yield quoteRootBank.loadNodeBanks(this.connection);\n        }\n\n        const settleFeesInstr = instruction_1.makeSettleFeesInstruction(this.programId, mangoGroup.publicKey, mangoCache.publicKey, perpMarket.publicKey, mangoAccount.publicKey, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], quoteRootBank.nodeBankAccounts[0].vault, mangoGroup.feesVault, mangoGroup.signerKey);\n        transaction.add(settleFeesInstr);\n        pnl = pnl.add(perpMarket.feesAccrued).min(fixednum_1.I80F48.fromString('-0.000001'));\n        const remSign = pnl.gt(fixednum_1.ZERO_I80F48) ? 1 : -1;\n\n        if (remSign !== sign) {\n          // if pnl has changed sign, then we're done\n          return yield this.sendTransaction(transaction, owner, additionalSigners);\n        }\n      } // we don't maintain an off chain service for finding accounts for\n      // devnet, so use fetchTopPnlAccountsFromDB only for mainnet\n\n\n      let accountsWithPnl; // note: simplistic way of checking if we are on mainnet\n\n      const isMainnet = this.connection['_rpcEndpoint'] && !this.connection['_rpcEndpoint'].toLowerCase() // usually devnet rpc endpoints have devnet in them, mainnet ones don't\n      .includes('devnet');\n\n      if (isMainnet) {\n        try {\n          accountsWithPnl = yield this.fetchTopPnlAccountsFromDB(mangoGroup, perpMarket, sign);\n        } catch (e) {\n          console.error(`fetchTopPnlAccountsFromDB failed, ${e}`);\n        }\n      } // if not set, then always fallback\n\n\n      if (!accountsWithPnl) {\n        accountsWithPnl = yield this.fetchTopPnlAccountsFromRPC(mangoGroup, mangoCache, perpMarket, price, sign, mangoAccounts);\n      }\n\n      for (const account of accountsWithPnl) {\n        // ignore own account explicitly\n        if (account.publicKey.equals(mangoAccount.publicKey)) {\n          continue;\n        }\n\n        if ((pnl.isPos() && account.pnl.isNeg() || pnl.isNeg() && account.pnl.isPos()) && transaction.instructions.length < 10) {\n          // Account pnl must have opposite signs\n          const instr = instruction_1.makeSettlePnlInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, account.publicKey, mangoGroup.mangoCache, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], new bn_js_1.default(marketIndex));\n          transaction.add(instr);\n          pnl = pnl.add(account.pnl); // if pnl has changed sign, then we're done\n\n          const remSign = pnl.gt(fixednum_1.ZERO_I80F48) ? 1 : -1;\n\n          if (remSign !== sign) {\n            break;\n          }\n        } else {\n          // means we ran out of accounts to settle against (shouldn't happen) OR transaction too big\n          // TODO - create a multi tx to be signed by user\n          continue;\n        }\n      }\n\n      return yield this.sendTransaction(transaction, owner, additionalSigners); // Calculate the profit or loss per market\n    });\n  }\n  /**\n   * Settle all perp accounts with positive pnl\n   */\n\n\n  settlePosPnl(mangoGroup, mangoCache, mangoAccount, perpMarkets, quoteRootBank, owner, mangoAccounts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // fetch all MangoAccounts filtered for having this perp market in basket\n      if (mangoAccounts === undefined) {\n        mangoAccounts = yield this.getAllMangoAccounts(mangoGroup, [], false);\n      }\n\n      const signatures = yield Promise.all(perpMarkets.map(pm => {\n        const marketIndex = mangoGroup.getPerpMarketIndex(pm.publicKey);\n        const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n        const price = mangoCache.getPrice(marketIndex);\n        const pnl = mangoAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price);\n        return pnl.isPos() ? this.settlePnl(mangoGroup, mangoCache, mangoAccount, pm, quoteRootBank, mangoCache.getPrice(marketIndex), owner, mangoAccounts) : utils_1.promiseNull();\n      }));\n\n      function filterNulls(value) {\n        if (value === null) return false;\n        return true;\n      }\n\n      const filtered = signatures === null || signatures === void 0 ? void 0 : signatures.filter(filterNulls);\n      return (filtered === null || filtered === void 0 ? void 0 : filtered.length) ? filtered : undefined;\n    });\n  }\n  /**\n   * Settle all perp accounts with any pnl\n   */\n\n\n  settleAllPerpPnl(mangoGroup, mangoCache, mangoAccount, perpMarkets, quoteRootBank, owner, mangoAccounts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // fetch all MangoAccounts filtered for having this perp market in basket\n      if (mangoAccounts === undefined) {\n        mangoAccounts = yield this.getAllMangoAccounts(mangoGroup, [], false);\n      }\n\n      return yield Promise.all(perpMarkets.map(pm => {\n        const marketIndex = mangoGroup.getPerpMarketIndex(pm.publicKey);\n        const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n        const price = mangoCache.getPrice(marketIndex);\n        const pnl = mangoAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price);\n        return !pnl.isZero() ? this.settlePnl(mangoGroup, mangoCache, mangoAccount, pm, quoteRootBank, mangoCache.getPrice(marketIndex), owner, mangoAccounts) : utils_1.promiseNull();\n      }));\n    });\n  }\n\n  getMangoAccountsForOwner(mangoGroup, owner) {\n    let includeOpenOrders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const filters = [{\n      memcmp: {\n        offset: layout_1.MangoAccountLayout.offsetOf('owner'),\n        bytes: owner.toBase58()\n      }\n    }];\n    return this.getAllMangoAccounts(mangoGroup, filters, includeOpenOrders);\n  }\n  /**\n   * Get all MangoAccounts where `delegate` pubkey has authority\n   */\n\n\n  getMangoAccountsForDelegate(mangoGroup, delegate) {\n    let includeOpenOrders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const filters = [{\n      memcmp: {\n        offset: layout_1.MangoAccountLayout.offsetOf('delegate'),\n        bytes: delegate.toBase58()\n      }\n    }];\n    return this.getAllMangoAccounts(mangoGroup, filters, includeOpenOrders);\n  }\n\n  getAllMangoAccounts(mangoGroup, filters) {\n    let includeOpenOrders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      const accountFilters = [{\n        memcmp: {\n          offset: layout_1.MangoAccountLayout.offsetOf('mangoGroup'),\n          bytes: mangoGroup.publicKey.toBase58()\n        }\n      }, {\n        dataSize: layout_1.MangoAccountLayout.span\n      }];\n\n      if (filters && filters.length) {\n        accountFilters.push(...filters);\n      }\n\n      const mangoAccounts = yield utils_1.getFilteredProgramAccounts(this.connection, this.programId, accountFilters).then(accounts => accounts.map(_ref7 => {\n        let {\n          publicKey,\n          accountInfo\n        } = _ref7;\n        return new MangoAccount_1.default(publicKey, layout_1.MangoAccountLayout.decode(accountInfo == null ? undefined : accountInfo.data));\n      }));\n\n      if (includeOpenOrders) {\n        const openOrderPks = mangoAccounts.map(ma => ma.spotOpenOrders.filter(pk => !pk.equals(utils_1.zeroKey))).flat();\n        const openOrderAccountInfos = yield utils_1.getMultipleAccounts(this.connection, openOrderPks);\n        const openOrders = openOrderAccountInfos.map(_ref8 => {\n          let {\n            publicKey,\n            accountInfo\n          } = _ref8;\n          return serum_1.OpenOrders.fromAccountInfo(publicKey, accountInfo, mangoGroup.dexProgramId);\n        });\n        const pkToOpenOrdersAccount = {};\n        openOrders.forEach(openOrdersAccount => {\n          pkToOpenOrdersAccount[openOrdersAccount.publicKey.toBase58()] = openOrdersAccount;\n        });\n\n        for (const ma of mangoAccounts) {\n          for (let i = 0; i < ma.spotOpenOrders.length; i++) {\n            if (ma.spotOpenOrders[i].toBase58() in pkToOpenOrdersAccount) {\n              ma.spotOpenOrdersAccounts[i] = pkToOpenOrdersAccount[ma.spotOpenOrders[i].toBase58()];\n            }\n          }\n        }\n      }\n\n      return mangoAccounts;\n    });\n  }\n\n  addStubOracle(mangoGroupPk, admin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const createOracleAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.StubOracleLayout.span, this.programId);\n      const instruction = instruction_1.makeAddOracleInstruction(this.programId, mangoGroupPk, createOracleAccountInstruction.account.publicKey, admin.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(createOracleAccountInstruction.instruction);\n      transaction.add(instruction);\n      const additionalSigners = [createOracleAccountInstruction.account];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  setStubOracle(mangoGroupPk, oraclePk, admin, price) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeSetOracleInstruction(this.programId, mangoGroupPk, oraclePk, admin.publicKey, fixednum_1.I80F48.fromNumber(price));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  addPerpMarket(mangoGroup, oraclePk, mngoMintPk, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, baseLotSize, quoteLotSize, maxNumEvents, rate, // liquidity mining params; set rate == 0 if no liq mining\n  maxDepthBps, targetPeriodLength, mngoPerPeriod, exp) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const makePerpMarketAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.PerpMarketLayout.span, this.programId);\n      const makeEventQueueAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.PerpEventQueueHeaderLayout.span + maxNumEvents * layout_1.PerpEventLayout.span, this.programId);\n      const makeBidAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n      const makeAskAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n      const mngoVaultAccount = new web3_js_1.Keypair();\n      const mngoVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, admin.publicKey, mngoVaultAccount.publicKey, mngoMintPk, mangoGroup.signerKey);\n      const instruction = yield instruction_1.makeAddPerpMarketInstruction(this.programId, mangoGroup.publicKey, oraclePk, makePerpMarketAccountInstruction.account.publicKey, makeEventQueueAccountInstruction.account.publicKey, makeBidAccountInstruction.account.publicKey, makeAskAccountInstruction.account.publicKey, mngoVaultAccount.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(makerFee), fixednum_1.I80F48.fromNumber(takerFee), new bn_js_1.default(baseLotSize), new bn_js_1.default(quoteLotSize), fixednum_1.I80F48.fromNumber(rate), fixednum_1.I80F48.fromNumber(maxDepthBps), new bn_js_1.default(targetPeriodLength), new bn_js_1.default(mngoPerPeriod), new bn_js_1.default(exp));\n      const createMngoVaultTransaction = new web3_js_1.Transaction();\n      createMngoVaultTransaction.add(...mngoVaultAccountInstructions);\n      yield this.sendTransaction(createMngoVaultTransaction, admin, [mngoVaultAccount]);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(makePerpMarketAccountInstruction.instruction);\n      transaction.add(makeEventQueueAccountInstruction.instruction);\n      transaction.add(makeBidAccountInstruction.instruction);\n      transaction.add(makeAskAccountInstruction.instruction);\n      transaction.add(instruction);\n      const additionalSigners = [makePerpMarketAccountInstruction.account, makeEventQueueAccountInstruction.account, makeBidAccountInstruction.account, makeAskAccountInstruction.account];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  createPerpMarket(mangoGroup, oraclePk, mngoMintPk, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, baseLotSize, quoteLotSize, maxNumEvents, rate, // liquidity mining params; set rate == 0 if no liq mining\n  maxDepthBps, targetPeriodLength, mngoPerPeriod, exp, version, lmSizeShift, baseDecimals) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!admin.publicKey) {\n        return;\n      }\n\n      const [perpMarketPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('PerpMarket', 'utf-8'), oraclePk.toBytes()], this.programId);\n      const makeEventQueueAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.PerpEventQueueHeaderLayout.span + maxNumEvents * layout_1.PerpEventLayout.span, this.programId);\n      const makeBidAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n      const makeAskAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n      const [mngoVaultPk] = yield web3_js_1.PublicKey.findProgramAddress([perpMarketPk.toBytes(), spl_token_1.TOKEN_PROGRAM_ID.toBytes(), mngoMintPk.toBytes()], this.programId);\n      const instruction = yield instruction_1.makeCreatePerpMarketInstruction(this.programId, mangoGroup.publicKey, oraclePk, perpMarketPk, makeEventQueueAccountInstruction.account.publicKey, makeBidAccountInstruction.account.publicKey, makeAskAccountInstruction.account.publicKey, mngoMintPk, mngoVaultPk, admin.publicKey, mangoGroup.signerKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(makerFee), fixednum_1.I80F48.fromNumber(takerFee), new bn_js_1.default(baseLotSize), new bn_js_1.default(quoteLotSize), fixednum_1.I80F48.fromNumber(rate), fixednum_1.I80F48.fromNumber(maxDepthBps), new bn_js_1.default(targetPeriodLength), new bn_js_1.default(mngoPerPeriod), new bn_js_1.default(exp), new bn_js_1.default(version), new bn_js_1.default(lmSizeShift), new bn_js_1.default(baseDecimals));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(makeEventQueueAccountInstruction.instruction);\n      transaction.add(makeBidAccountInstruction.instruction);\n      transaction.add(makeAskAccountInstruction.instruction);\n      transaction.add(instruction);\n      const additionalSigners = [makeEventQueueAccountInstruction.account, makeBidAccountInstruction.account, makeAskAccountInstruction.account];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  } // Liquidator Functions\n\n\n  forceCancelSpotOrders(mangoGroup, liqeeMangoAccount, spotMarket, baseRootBank, quoteRootBank, payer, limit) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const baseNodeBanks = yield baseRootBank.loadNodeBanks(this.connection);\n      const quoteNodeBanks = yield quoteRootBank.loadNodeBanks(this.connection);\n      const openOrdersKeys = [];\n      const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey); // Only pass in open orders if in margin basket or current market index, and\n      // the only writable account should be OpenOrders for current market index\n\n      for (let i = 0; i < liqeeMangoAccount.spotOpenOrders.length; i++) {\n        let pubkey = utils_1.zeroKey;\n        let isWritable = false;\n\n        if (i === spotMarketIndex) {\n          isWritable = true;\n\n          if (liqeeMangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n            console.log('missing oo for ', spotMarketIndex); // open orders missing for this market; create a new one now\n            // const openOrdersSpace = OpenOrders.getLayout(\n            //   mangoGroup.dexProgramId,\n            // ).span;\n            // const openOrdersLamports =\n            //   await this.connection.getMinimumBalanceForRentExemption(\n            //     openOrdersSpace,\n            //     'singleGossip',\n            //   );\n            // const accInstr = await createAccountInstruction(\n            //   this.connection,\n            //   owner.publicKey,\n            //   openOrdersSpace,\n            //   mangoGroup.dexProgramId,\n            //   openOrdersLamports,\n            // );\n            // transaction.add(accInstr.instruction);\n            // additionalSigners.push(accInstr.account);\n            // pubkey = accInstr.account.publicKey;\n          } else {\n            pubkey = liqeeMangoAccount.spotOpenOrders[i];\n          }\n        } else if (liqeeMangoAccount.inMarginBasket[i]) {\n          pubkey = liqeeMangoAccount.spotOpenOrders[i];\n        }\n\n        openOrdersKeys.push({\n          pubkey,\n          isWritable\n        });\n      }\n\n      const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n      const instruction = instruction_1.makeForceCancelSpotOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, baseRootBank.publicKey, baseNodeBanks[0].publicKey, baseNodeBanks[0].vault, quoteRootBank.publicKey, quoteNodeBanks[0].publicKey, quoteNodeBanks[0].vault, spotMarket.publicKey, spotMarket.bidsAddress, spotMarket.asksAddress, mangoGroup.signerKey, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, dexSigner, mangoGroup.dexProgramId, openOrdersKeys, limit);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n  /**\n   * Send multiple instructions to cancel all perp orders in this market\n   */\n\n\n  forceCancelAllPerpOrdersInMarket(mangoGroup, liqee, perpMarket, payer, limitPerInstruction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const transaction = new web3_js_1.Transaction();\n      const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n      const instruction = instruction_1.makeForceCancelPerpOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqee.publicKey, liqee.spotOpenOrders, new bn_js_1.default(limitPerInstruction));\n      transaction.add(instruction);\n      let orderCount = 0;\n\n      for (let i = 0; i < liqee.orderMarket.length; i++) {\n        if (liqee.orderMarket[i] !== marketIndex) {\n          continue;\n        }\n\n        orderCount++;\n\n        if (orderCount === limitPerInstruction) {\n          orderCount = 0;\n          const instruction = instruction_1.makeForceCancelPerpOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqee.publicKey, liqee.spotOpenOrders, new bn_js_1.default(limitPerInstruction));\n          transaction.add(instruction); // TODO - verify how many such instructions can go into one tx\n          // right now 10 seems reasonable considering size of 800ish bytes if all spot open orders present\n\n          if (transaction.instructions.length === 10) {\n            break;\n          }\n        }\n      }\n\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  forceCancelPerpOrders(mangoGroup, liqeeMangoAccount, perpMarket, payer, limit) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeForceCancelPerpOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqeeMangoAccount.publicKey, liqeeMangoAccount.spotOpenOrders, limit);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  liquidateTokenAndToken(mangoGroup, liqeeMangoAccount, liqorMangoAccount, assetRootBank, liabRootBank, payer, maxLiabTransfer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeLiquidateTokenAndTokenInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, assetRootBank.publicKey, assetRootBank.nodeBanks[0], liabRootBank.publicKey, liabRootBank.nodeBanks[0], liqeeMangoAccount.spotOpenOrders, liqorMangoAccount.spotOpenOrders, maxLiabTransfer);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  liquidateTokenAndPerp(mangoGroup, liqeeMangoAccount, liqorMangoAccount, rootBank, payer, assetType, assetIndex, liabType, liabIndex, maxLiabTransfer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeLiquidateTokenAndPerpInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, rootBank.publicKey, rootBank.nodeBanks[0], liqeeMangoAccount.spotOpenOrders, liqorMangoAccount.spotOpenOrders, assetType, new bn_js_1.default(assetIndex), liabType, new bn_js_1.default(liabIndex), maxLiabTransfer);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  liquidatePerpMarket(mangoGroup, liqeeMangoAccount, liqorMangoAccount, perpMarket, payer, baseTransferRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeLiquidatePerpMarketInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, liqeeMangoAccount.spotOpenOrders, liqorMangoAccount.spotOpenOrders, baseTransferRequest);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  settleFees(mangoGroup, mangoAccount, perpMarket, rootBank, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const nodeBanks = yield rootBank.loadNodeBanks(this.connection);\n      const instruction = instruction_1.makeSettleFeesInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, mangoAccount.publicKey, rootBank.publicKey, nodeBanks[0].publicKey, nodeBanks[0].vault, mangoGroup.feesVault, mangoGroup.signerKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  resolvePerpBankruptcy(mangoGroup, liqeeMangoAccount, liqorMangoAccount, perpMarket, rootBank, payer, liabIndex, maxLiabTransfer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const nodeBanks = yield rootBank.loadNodeBanks(this.connection);\n      const instruction = instruction_1.makeResolvePerpBankruptcyInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, rootBank.publicKey, nodeBanks[0].publicKey, nodeBanks[0].vault, mangoGroup.insuranceVault, mangoGroup.signerKey, perpMarket.publicKey, liqorMangoAccount.spotOpenOrders, new bn_js_1.default(liabIndex), maxLiabTransfer);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  resolveTokenBankruptcy(mangoGroup, liqeeMangoAccount, liqorMangoAccount, quoteRootBank, liabRootBank, payer, maxLiabTransfer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const quoteNodeBanks = yield quoteRootBank.loadNodeBanks(this.connection);\n      const instruction = instruction_1.makeResolveTokenBankruptcyInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], quoteNodeBanks[0].vault, mangoGroup.insuranceVault, mangoGroup.signerKey, liabRootBank.publicKey, liabRootBank.nodeBanks[0], liqorMangoAccount.spotOpenOrders, liabRootBank.nodeBanks, maxLiabTransfer);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  redeemMngo(mangoGroup, mangoAccount, perpMarket, payer, mngoRootBank, mngoNodeBank, mngoVault) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeRedeemMngoInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank, mngoNodeBank, mngoVault, mangoGroup.signerKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      return yield this.sendTransaction(transaction, payer, []);\n    });\n  }\n\n  redeemAllMngo(mangoGroup, mangoAccount, payer, mngoRootBank, mngoNodeBank, mngoVault) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const transactions = [];\n      let transaction = new web3_js_1.Transaction();\n      const perpMarkets = yield Promise.all(mangoAccount.perpAccounts.map((perpAccount, i) => {\n        if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {\n          return utils_1.promiseUndef();\n        } else {\n          return this.getPerpMarket(mangoGroup.perpMarkets[i].perpMarket, mangoGroup.tokens[i].decimals, mangoGroup.tokens[layout_1.QUOTE_INDEX].decimals);\n        }\n      }));\n\n      for (let i = 0; i < mangoAccount.perpAccounts.length; i++) {\n        const perpMarket = perpMarkets[i];\n        if (perpMarket === undefined) continue;\n        const instruction = instruction_1.makeRedeemMngoInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank, mngoNodeBank, mngoVault, mangoGroup.signerKey);\n        transaction.add(instruction);\n\n        if (transaction.instructions.length === 9) {\n          transactions.push(transaction);\n          transaction = new web3_js_1.Transaction();\n        }\n      }\n\n      if (transaction.instructions.length > 0) {\n        transactions.push(transaction); // txProms.push(this.sendTransaction(transaction, payer, []));\n      }\n\n      const transactionsAndSigners = transactions.map(tx => ({\n        transaction: tx,\n        signers: []\n      }));\n\n      if (transactionsAndSigners.length === 0) {\n        throw new Error('No MNGO rewards to redeem');\n      } // Sign multiple transactions at once for better UX\n\n\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer\n      });\n\n      if (signedTransactions) {\n        const txSigs = yield Promise.all(signedTransactions.map(signedTransaction => this.sendSignedTransaction({\n          signedTransaction\n        })));\n        return txSigs;\n      } else {\n        throw new Error('Unable to sign all RedeemMngo transactions');\n      }\n    });\n  }\n\n  addMangoAccountInfo(mangoGroup, mangoAccount, owner, info) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeAddMangoAccountInfoInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, info);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  depositMsrm(mangoGroup, mangoAccount, owner, msrmAccount, quantity) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeDepositMsrmInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, msrmAccount, mangoGroup.msrmVault, new bn_js_1.default(Math.floor(quantity)));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  withdrawMsrm(mangoGroup, mangoAccount, owner, msrmAccount, quantity) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeWithdrawMsrmInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, msrmAccount, mangoGroup.msrmVault, mangoGroup.signerKey, new bn_js_1.default(Math.floor(quantity)));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  changePerpMarketParams(mangoGroup, perpMarket, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, rate, maxDepthBps, targetPeriodLength, mngoPerPeriod, exp) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!admin.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeChangePerpMarketParamsInstruction(this.programId, mangoGroup.publicKey, perpMarket.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(makerFee), fixednum_1.I80F48.fromNumberOrUndef(takerFee), fixednum_1.I80F48.fromNumberOrUndef(rate), fixednum_1.I80F48.fromNumberOrUndef(maxDepthBps), targetPeriodLength !== undefined ? new bn_js_1.default(targetPeriodLength) : undefined, mngoPerPeriod !== undefined ? new bn_js_1.default(mngoPerPeriod) : undefined, exp !== undefined ? new bn_js_1.default(exp) : undefined);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  changePerpMarketParams2(mangoGroup, perpMarket, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, rate, maxDepthBps, targetPeriodLength, mngoPerPeriod, exp, version, lmSizeShift) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!admin.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeChangePerpMarketParams2Instruction(this.programId, mangoGroup.publicKey, perpMarket.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(makerFee), fixednum_1.I80F48.fromNumberOrUndef(takerFee), fixednum_1.I80F48.fromNumberOrUndef(rate), fixednum_1.I80F48.fromNumberOrUndef(maxDepthBps), targetPeriodLength !== undefined ? new bn_js_1.default(targetPeriodLength) : undefined, mngoPerPeriod !== undefined ? new bn_js_1.default(mngoPerPeriod) : undefined, exp !== undefined ? new bn_js_1.default(exp) : undefined, version !== undefined ? new bn_js_1.default(version) : undefined, lmSizeShift !== undefined ? new bn_js_1.default(lmSizeShift) : undefined);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  setGroupAdmin(mangoGroup, newAdmin, admin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!admin.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeSetGroupAdminInstruction(this.programId, mangoGroup.publicKey, newAdmin, admin.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n  /**\n   * Add allowance for orders to be cancelled and replaced in a single transaction\n   */\n\n\n  modifySpotOrder(mangoGroup, mangoAccount, mangoCache, spotMarket, owner, order, side, price, size, orderType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const instruction = instruction_1.makeCancelSpotOrderInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, order.openOrdersAddress, mangoGroup.signerKey, spotMarket['_decoded'].eventQueue, order);\n      transaction.add(instruction);\n      const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([spotMarket.publicKey.toBuffer(), spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8)], spotMarket.programId);\n      const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n\n      if (!mangoGroup.rootBankAccounts.length) {\n        yield mangoGroup.loadRootBanks(this.connection);\n      }\n\n      const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];\n      const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n      const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n      const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n\n      if (!baseNodeBank || !quoteNodeBank) {\n        throw new Error('Invalid or missing node banks');\n      }\n\n      const settleFundsInstruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[spotMarketIndex], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[spotMarketIndex].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n      transaction.add(settleFundsInstruction);\n      const additionalSigners = [];\n      const limitPrice = spotMarket.priceNumberToLots(price);\n      const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size); // TODO implement srm vault fee discount\n      // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));\n\n      const feeTier = serum_1.getFeeTier(0, utils_1.nativeToUi(0, 0));\n      const rates = serum_1.getFeeRates(feeTier);\n      const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket.baseSizeNumberToLots(size).mul(spotMarket.priceNumberToLots(price))); // Checks already completed as only price modified\n\n      if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {\n        throw new Error('size too small');\n      }\n\n      if (limitPrice.lte(utils_1.ZERO_BN)) {\n        throw new Error('invalid price');\n      }\n\n      const selfTradeBehavior = 'decrementTake';\n\n      if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {\n        throw new Error('Invalid or missing banks');\n      }\n\n      const openOrdersKeys = []; // Only pass in open orders if in margin basket or current market index, and\n      // the only writable account should be OpenOrders for current market index\n\n      for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n        let pubkey = utils_1.zeroKey;\n        let isWritable = false;\n\n        if (i === spotMarketIndex) {\n          isWritable = true;\n\n          if (mangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n            // open orders missing for this market; create a new one now\n            const openOrdersSpace = serum_1.OpenOrders.getLayout(mangoGroup.dexProgramId).span;\n            const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'processed');\n            const accInstr = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, openOrdersSpace, mangoGroup.dexProgramId, openOrdersLamports);\n            const initOpenOrders = instruction_1.makeInitSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, mangoGroup.signerKey);\n            const initTx = new web3_js_1.Transaction();\n            initTx.add(accInstr.instruction);\n            initTx.add(initOpenOrders);\n            yield this.sendTransaction(initTx, owner, [accInstr.account]);\n            pubkey = accInstr.account.publicKey;\n          } else {\n            pubkey = mangoAccount.spotOpenOrders[i];\n          }\n        } else if (mangoAccount.inMarginBasket[i]) {\n          pubkey = mangoAccount.spotOpenOrders[i];\n        }\n\n        openOrdersKeys.push({\n          pubkey,\n          isWritable\n        });\n      }\n\n      const placeOrderInstruction = instruction_1.makePlaceSpotOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, mangoGroup.srmVault, // TODO: choose msrm vault if it has any deposits\n      openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, order.clientId);\n      transaction.add(placeOrderInstruction);\n\n      if (spotMarketIndex > 0) {\n        console.log(spotMarketIndex - 1, mangoAccount.spotOpenOrders[spotMarketIndex - 1].toBase58(), openOrdersKeys[spotMarketIndex - 1].pubkey.toBase58());\n      }\n\n      const txid = yield this.sendTransaction(transaction, owner, additionalSigners); // update MangoAccount to have new OpenOrders pubkey\n\n      mangoAccount.spotOpenOrders[spotMarketIndex] = openOrdersKeys[spotMarketIndex].pubkey;\n      mangoAccount.inMarginBasket[spotMarketIndex] = true;\n      console.log(spotMarketIndex, mangoAccount.spotOpenOrders[spotMarketIndex].toBase58(), openOrdersKeys[spotMarketIndex].pubkey.toBase58());\n      return txid;\n    });\n  }\n\n  modifyPerpOrder(mangoGroup, mangoAccount, mangoCache, perpMarket, owner, order, side, price, quantity, orderType, clientOrderId, bookSideInfo) {\n    let invalidIdOk = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;\n    let // Don't throw error if order is invalid\n    referrerMangoAccountPk = arguments.length > 13 ? arguments[13] : undefined;\n\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      const cancelInstruction = instruction_1.makeCancelPerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, order, invalidIdOk);\n      transaction.add(cancelInstruction);\n      const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);\n      const placeInstruction = instruction_1.makePlacePerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.spotOpenOrders, nativePrice, nativeQuantity, clientOrderId ? new bn_js_1.default(clientOrderId) : (_a = order.clientId) !== null && _a !== void 0 ? _a : new bn_js_1.default(Date.now()), side, orderType, false, referrerMangoAccountPk);\n      transaction.add(placeInstruction);\n\n      if (bookSideInfo) {\n        const bookSide = bookSideInfo.data ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data)) : [];\n        const accounts = new Set();\n        accounts.add(mangoAccount.publicKey.toBase58());\n\n        for (const order of bookSide) {\n          accounts.add(order.owner.toBase58());\n\n          if (accounts.size >= 10) {\n            break;\n          }\n        }\n\n        const consumeInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts).map(s => new web3_js_1.PublicKey(s)).sort(), new bn_js_1.default(4));\n        transaction.add(consumeInstruction);\n      }\n\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  addPerpTriggerOrder(mangoGroup, mangoAccount, perpMarket, owner, orderType, side, price, quantity, triggerCondition, triggerPrice, reduceOnly, clientOrderId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const transaction = new web3_js_1.Transaction();\n      const additionalSigners = [];\n      let advancedOrders = mangoAccount.advancedOrdersKey;\n\n      if (mangoAccount.advancedOrdersKey.equals(utils_1.zeroKey)) {\n        [advancedOrders] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccount.publicKey.toBytes()], this.programId);\n        console.log('AdvancedOrders PDA:', advancedOrders.toBase58());\n        transaction.add(instruction_1.makeInitAdvancedOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, advancedOrders));\n      }\n\n      const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n      const baseTokenInfo = mangoGroup.tokens[marketIndex];\n      const quoteTokenInfo = mangoGroup.tokens[layout_1.QUOTE_INDEX];\n      const baseUnit = Math.pow(10, baseTokenInfo.decimals);\n      const quoteUnit = Math.pow(10, quoteTokenInfo.decimals);\n      const nativePrice = new bn_js_1.default(price * quoteUnit).mul(perpMarket.baseLotSize).div(perpMarket.quoteLotSize.mul(new bn_js_1.default(baseUnit)));\n      const nativeQuantity = new bn_js_1.default(quantity * baseUnit).div(perpMarket.baseLotSize);\n      const nativeTriggerPrice = fixednum_1.I80F48.fromNumber(triggerPrice * Math.pow(10, perpMarket.quoteDecimals - perpMarket.baseDecimals));\n      const openOrders = mangoAccount.spotOpenOrders.filter((pk, i) => mangoAccount.inMarginBasket[i]);\n      transaction.add(instruction_1.makeAddPerpTriggerOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, advancedOrders, mangoGroup.mangoCache, perpMarket.publicKey, openOrders, orderType, side, nativePrice, nativeQuantity, triggerCondition, nativeTriggerPrice, reduceOnly, new bn_js_1.default(clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : Date.now())));\n      const txid = yield this.sendTransaction(transaction, owner, additionalSigners);\n      mangoAccount.advancedOrdersKey = advancedOrders;\n      return txid;\n    });\n  }\n\n  removeAdvancedOrder(mangoGroup, mangoAccount, owner, orderIndex) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!owner.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeRemoveAdvancedOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoAccount.advancedOrdersKey, orderIndex);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, owner, additionalSigners);\n    });\n  }\n\n  executePerpTriggerOrder(mangoGroup, mangoAccount, mangoCache, perpMarket, payer, orderIndex) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const openOrders = mangoAccount.spotOpenOrders.filter((pk, i) => mangoAccount.inMarginBasket[i]);\n      const instruction = instruction_1.makeExecutePerpTriggerOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, mangoAccount.advancedOrdersKey, payer.publicKey, mangoCache.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, openOrders, new bn_js_1.default(orderIndex));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  closeAdvancedOrders(mangoGroup, mangoAccount, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeCloseAdvancedOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoAccount.advancedOrdersKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  closeSpotOpenOrders(mangoGroup, mangoAccount, payer, marketIndex) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeCloseSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.dexProgramId, mangoAccount.spotOpenOrders[marketIndex], mangoGroup.spotMarkets[marketIndex].spotMarket, mangoGroup.signerKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  closeMangoAccount(mangoGroup, mangoAccount, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeCloseMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  createDustAccount(mangoGroup, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n      const instruction = instruction_1.makeCreateDustAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, payer.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  resolveDust(mangoGroup, mangoAccount, rootBank, mangoCache, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const [dustAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n      const instruction = instruction_1.makeResolveDustInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, dustAccountPk, rootBank.publicKey, rootBank.nodeBanks[0], mangoCache.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  updateMarginBasket(mangoGroup, mangoAccount, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const instruction = instruction_1.makeUpdateMarginBasketInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, mangoAccount.spotOpenOrders);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  resolveAllDust(mangoGroup, mangoAccount, mangoCache, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const transactionsAndSigners = [];\n      const [dustAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n\n      for (const rootBank of mangoGroup.rootBankAccounts) {\n        const transactionAndSigners = {\n          transaction: new web3_js_1.Transaction(),\n          signers: []\n        };\n\n        if (rootBank) {\n          const tokenIndex = mangoGroup.getRootBankIndex(rootBank === null || rootBank === void 0 ? void 0 : rootBank.publicKey);\n          const nativeDeposit = mangoAccount.getNativeDeposit(rootBank, tokenIndex);\n          const nativeBorrow = mangoAccount.getNativeBorrow(rootBank, tokenIndex);\n          console.log('nativeDeposit', nativeDeposit.toString());\n          console.log('nativeBorrow', nativeBorrow.toString());\n          console.log('tokenIndex', tokenIndex.toString());\n\n          if (nativeDeposit.gt(fixednum_1.ZERO_I80F48) && nativeDeposit.lt(fixednum_1.ONE_I80F48) || nativeBorrow.gt(fixednum_1.ZERO_I80F48) && nativeBorrow.lt(fixednum_1.ONE_I80F48)) {\n            const instruction = instruction_1.makeResolveDustInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, dustAccountPk, rootBank.publicKey, rootBank.nodeBanks[0], mangoCache.publicKey);\n            transactionAndSigners.transaction.add(instruction);\n          }\n        }\n\n        transactionsAndSigners.push(transactionAndSigners);\n      }\n\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer: payer\n      });\n\n      if (signedTransactions) {\n        for (const signedTransaction of signedTransactions) {\n          if (signedTransaction.instructions.length == 0) {\n            continue;\n          }\n\n          const txid = yield this.sendSignedTransaction({\n            signedTransaction\n          });\n          console.log(txid);\n        }\n      } else {\n        throw new Error('Unable to sign ResolveDust transactions');\n      }\n    });\n  }\n\n  emptyAndCloseMangoAccount(mangoGroup, mangoAccount, mangoCache, mngoIndex, payer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const transactionsAndSigners = [];\n      const redeemMngoTransaction = {\n        transaction: new web3_js_1.Transaction(),\n        signers: []\n      };\n      const mngoRootBank = mangoGroup.rootBankAccounts[mngoIndex];\n      const perpMarkets = yield Promise.all(mangoAccount.perpAccounts.map((perpAccount, i) => {\n        if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {\n          return utils_1.promiseUndef();\n        } else {\n          return this.getPerpMarket(mangoGroup.perpMarkets[i].perpMarket, mangoGroup.tokens[i].decimals, mangoGroup.tokens[layout_1.QUOTE_INDEX].decimals);\n        }\n      }));\n      let redeemedMngo = false;\n\n      for (let i = 0; i < mangoAccount.perpAccounts.length; i++) {\n        const perpAccount = mangoAccount.perpAccounts[i];\n\n        if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {\n          continue;\n        }\n\n        redeemedMngo = true;\n        const perpMarket = perpMarkets[i]; // this is actually an error state; Means there is mngo accrued but PerpMarket doesn't exist\n\n        if (perpMarket === undefined) continue;\n        const instruction = instruction_1.makeRedeemMngoInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank.publicKey, mngoRootBank.nodeBanks[0], mngoRootBank.nodeBankAccounts[0].vault, mangoGroup.signerKey);\n        redeemMngoTransaction.transaction.add(instruction);\n      }\n\n      transactionsAndSigners.push(redeemMngoTransaction);\n      const resolveAllDustTransaction = {\n        transaction: new web3_js_1.Transaction(),\n        signers: []\n      };\n      const [dustAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n\n      for (const rootBank of mangoGroup.rootBankAccounts) {\n        if (rootBank) {\n          const tokenIndex = mangoGroup.getRootBankIndex(rootBank === null || rootBank === void 0 ? void 0 : rootBank.publicKey);\n          const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n          const shouldWithdrawMngo = redeemedMngo && tokenIndex === mngoIndex;\n\n          if (mangoAccount.deposits[tokenIndex].isPos() || shouldWithdrawMngo) {\n            const withdrawTransaction = {\n              transaction: new web3_js_1.Transaction(),\n              signers: []\n            };\n            let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, payer.publicKey);\n            let wrappedSolAccount = null;\n\n            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n              wrappedSolAccount = new web3_js_1.Keypair();\n              tokenAcc = wrappedSolAccount.publicKey;\n              const space = 165;\n              const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'processed');\n              withdrawTransaction.transaction.add(web3_js_1.SystemProgram.createAccount({\n                fromPubkey: payer.publicKey,\n                newAccountPubkey: tokenAcc,\n                lamports,\n                space,\n                programId: spl_token_1.TOKEN_PROGRAM_ID\n              }));\n              withdrawTransaction.transaction.add(token_instructions_1.initializeAccount({\n                account: tokenAcc,\n                mint: token_instructions_1.WRAPPED_SOL_MINT,\n                owner: payer.publicKey\n              }));\n              withdrawTransaction.signers.push(wrappedSolAccount);\n            } else {\n              const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc, 'processed');\n\n              if (!tokenAccExists) {\n                withdrawTransaction.transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, payer.publicKey, payer.publicKey));\n              }\n            }\n\n            const instruction = instruction_1.makeWithdrawInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.mangoCache, rootBank.publicKey, rootBank.nodeBanks[0], rootBank.nodeBankAccounts[0].vault, tokenAcc, mangoGroup.signerKey, mangoAccount.spotOpenOrders, _1.U64_MAX_BN, false);\n            withdrawTransaction.transaction.add(instruction);\n\n            if (wrappedSolAccount) {\n              withdrawTransaction.transaction.add(token_instructions_1.closeAccount({\n                source: wrappedSolAccount.publicKey,\n                destination: payer.publicKey,\n                owner: payer.publicKey\n              }));\n            }\n\n            transactionsAndSigners.push(withdrawTransaction);\n          }\n\n          const nativeBorrow = mangoAccount.getNativeBorrow(mangoCache.rootBankCache[tokenIndex], tokenIndex);\n\n          if (shouldWithdrawMngo || mangoAccount.deposits[tokenIndex].isPos() || nativeBorrow.gt(fixednum_1.ZERO_I80F48) && nativeBorrow.lt(fixednum_1.ONE_I80F48)) {\n            const instruction = instruction_1.makeResolveDustInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, dustAccountPk, rootBank.publicKey, rootBank.nodeBanks[0], mangoCache.publicKey);\n            resolveAllDustTransaction.transaction.add(instruction);\n          }\n        }\n      }\n\n      transactionsAndSigners.push(resolveAllDustTransaction);\n      const closeAccountsTransaction = {\n        transaction: new web3_js_1.Transaction(),\n        signers: []\n      };\n\n      for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n        const openOrders = mangoAccount.spotOpenOrders[i];\n        const spotMarket = mangoGroup.spotMarkets[i].spotMarket;\n\n        if (!openOrders.equals(utils_1.zeroKey)) {\n          closeAccountsTransaction.transaction.add(instruction_1.makeCloseSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.dexProgramId, openOrders, spotMarket, mangoGroup.signerKey));\n        }\n      }\n\n      if (!mangoAccount.advancedOrdersKey.equals(utils_1.zeroKey)) {\n        closeAccountsTransaction.transaction.add(instruction_1.makeCloseAdvancedOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoAccount.advancedOrdersKey));\n      }\n\n      if (mangoAccount.metaData.version == 0) {\n        closeAccountsTransaction.transaction.add(instruction_1.makeUpgradeMangoAccountV0V1Instruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey));\n      }\n\n      closeAccountsTransaction.transaction.add(instruction_1.makeCloseMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey));\n      transactionsAndSigners.push(closeAccountsTransaction);\n      const signedTransactions = yield this.signTransactions({\n        transactionsAndSigners,\n        payer: payer\n      });\n      const txids = [];\n\n      if (signedTransactions) {\n        for (const signedTransaction of signedTransactions) {\n          if (signedTransaction.instructions.length == 0) {\n            continue;\n          }\n\n          const txid = yield this.sendSignedTransaction({\n            signedTransaction\n          });\n          txids.push(txid);\n          console.log(txid);\n        }\n      } else {\n        throw new Error('Unable to sign emptyAndCloseMangoAccount transactions');\n      }\n\n      return txids;\n    });\n  }\n\n  cancelPerpOrderSide(mangoGroup, mangoAccount, perpMarket, payer, side, limit) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeCancelPerpOrdersSideInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, side, new bn_js_1.default(limit));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  setDelegate(mangoGroup, mangoAccount, payer, delegate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeSetDelegateInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, delegate);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  changeSpotMarketParams(mangoGroup, spotMarket, rootBank, admin, maintLeverage, initLeverage, liquidationFee, optimalUtil, optimalRate, maxRate, version) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!admin.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeChangeSpotMarketParamsInstruction(this.programId, mangoGroup.publicKey, spotMarket.publicKey, rootBank.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(optimalUtil), fixednum_1.I80F48.fromNumberOrUndef(optimalRate), fixednum_1.I80F48.fromNumberOrUndef(maxRate), version !== undefined ? new bn_js_1.default(version) : undefined);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n  /**\n   * Change the referral fee params\n   * @param mangoGroup\n   * @param admin\n   * @param refSurcharge normal units 0.0001 -> 1 basis point\n   * @param refShare\n   * @param refMngoRequired ui units -> 1 -> 1_000_000 MNGO\n   */\n\n\n  changeReferralFeeParams(mangoGroup, admin, refSurcharge, refShare, refMngoRequired) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!admin.publicKey) {\n        return;\n      }\n\n      const instruction = instruction_1.makeChangeReferralFeeParamsInstruction(this.programId, mangoGroup.publicKey, admin.publicKey, new bn_js_1.default(refSurcharge * layout_1.CENTIBPS_PER_UNIT), new bn_js_1.default(refShare * layout_1.CENTIBPS_PER_UNIT), new bn_js_1.default(refMngoRequired * 1000000));\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, admin, additionalSigners);\n    });\n  }\n\n  setReferrerMemory(mangoGroup, mangoAccount, payer, // must be also owner of mangoAccount\n  referrerMangoAccountPk) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      } // Generate the PDA pubkey\n\n\n      const [referrerMemoryPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccount.publicKey.toBytes(), new Buffer('ReferrerMemory', 'utf-8')], this.programId);\n      const instruction = instruction_1.makeSetReferrerMemoryInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, referrerMemoryPk, referrerMangoAccountPk, payer.publicKey);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  getReferrerPda(mangoGroup, referrerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const encoded = Buffer.from(referrerId, 'utf8');\n\n      if (encoded.length > layout_1.INFO_LEN) {\n        throw new Error(`info string too long. Must be less than or equal to ${layout_1.INFO_LEN} bytes`);\n      }\n\n      const encodedReferrerId = Buffer.concat([encoded, Buffer.alloc(layout_1.INFO_LEN - encoded.length, 0)]); // Generate the PDA pubkey\n\n      const [referrerIdRecordPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('ReferrerIdRecord', 'utf-8'), encodedReferrerId], this.programId);\n      return {\n        referrerPda: referrerIdRecordPk,\n        encodedReferrerId\n      };\n    });\n  }\n\n  registerReferrerId(mangoGroup, referrerMangoAccount, payer, // will also owner of referrerMangoAccount\n  referrerId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!payer.publicKey) {\n        return;\n      }\n\n      const {\n        referrerPda,\n        encodedReferrerId\n      } = yield this.getReferrerPda(mangoGroup, referrerId);\n      const instruction = instruction_1.makeRegisterReferrerIdInstruction(this.programId, mangoGroup.publicKey, referrerMangoAccount.publicKey, referrerPda, payer.publicKey, encodedReferrerId);\n      const transaction = new web3_js_1.Transaction();\n      transaction.add(instruction);\n      const additionalSigners = [];\n      return yield this.sendTransaction(transaction, payer, additionalSigners);\n    });\n  }\n\n  getReferrerIdsForMangoAccount(mangoAccount) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const filters = [{\n        memcmp: {\n          offset: _1.ReferrerIdRecordLayout.offsetOf('referrerMangoAccount'),\n          bytes: mangoAccount.publicKey.toBase58()\n        }\n      }, {\n        dataSize: _1.ReferrerIdRecordLayout.span\n      }];\n      const referrerIds = yield utils_1.getFilteredProgramAccounts(this.connection, this.programId, filters).then(referrerIds => {\n        return referrerIds.map(_ref9 => {\n          let {\n            accountInfo\n          } = _ref9;\n          return new _1.ReferrerIdRecord(_1.ReferrerIdRecordLayout.decode(accountInfo == null ? undefined : accountInfo.data));\n        });\n      });\n      return referrerIds;\n    });\n  }\n\n}\n\nexports.MangoClient = MangoClient;","map":{"version":3,"sources":["../../src/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MangoClient = exports.getUnixTs = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nconst utils_1 = require(\"./utils/utils\");\nconst layout_1 = require(\"./layout\");\nconst MangoAccount_1 = __importDefault(require(\"./MangoAccount\"));\nconst PerpMarket_1 = __importDefault(require(\"./PerpMarket\"));\nconst instruction_1 = require(\"./instruction\");\nconst serum_1 = require(\"@project-serum/serum\");\nconst fixednum_1 = require(\"./utils/fixednum\");\nconst adapterTypes_1 = require(\"./utils/adapterTypes\");\nconst book_1 = require(\"./book\");\nconst token_instructions_1 = require(\"@project-serum/serum/lib/token-instructions\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst MangoGroup_1 = __importDefault(require(\"./MangoGroup\"));\nconst _1 = require(\".\");\nconst bs58 = __importStar(require(\"bs58\"));\n/**\n * Get the current epoch timestamp in seconds with microsecond precision\n */\nconst getUnixTs = () => {\n    return new Date().getTime() / 1000;\n};\nexports.getUnixTs = getUnixTs;\n/**\n * A class for interacting with the Mango V3 Program\n *\n * @param connection A solana web.js Connection object\n * @param programId The PublicKey of the Mango V3 Program\n * @param opts An object used to configure the MangoClient. Accepts a postSendTxCallback\n */\nclass MangoClient {\n    constructor(connection, programId, opts = {}) {\n        this.connection = connection;\n        this.programId = programId;\n        this.lastSlot = 0;\n        this.recentBlockhash = '';\n        this.recentBlockhashTime = 0;\n        this.maxStoredBlockhashes = (opts === null || opts === void 0 ? void 0 : opts.maxStoredBlockhashes) || 7;\n        this.blockhashCommitment = (opts === null || opts === void 0 ? void 0 : opts.blockhashCommitment) || 'confirmed';\n        this.timeout = (opts === null || opts === void 0 ? void 0 : opts.timeout) || 60000;\n        this.sendConnection = opts.sendConnection;\n        if (opts.postSendTxCallback) {\n            this.postSendTxCallback = opts.postSendTxCallback;\n        }\n    }\n    sendTransactions(transactions, payer, additionalSigners, timeout = this.timeout, confirmLevel = 'confirmed') {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield Promise.all(transactions.map((tx) => this.sendTransaction(tx, payer, additionalSigners, timeout, confirmLevel)));\n        });\n    }\n    signTransaction({ transaction, payer, signers }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = exports.getUnixTs();\n            let blockhash;\n            // Get new blockhash if stored blockhash more than 70 seconds old\n            if (this.recentBlockhashTime && now < this.recentBlockhashTime + 70) {\n                blockhash = this.recentBlockhash;\n            }\n            else {\n                blockhash = (yield this.connection.getRecentBlockhash(this.blockhashCommitment)).blockhash;\n            }\n            transaction.recentBlockhash = blockhash;\n            transaction.setSigners(payer.publicKey, ...signers.map((s) => s.publicKey));\n            if (signers.length > 0) {\n                transaction.partialSign(...signers);\n            }\n            if (payer === null || payer === void 0 ? void 0 : payer.connected) {\n                console.log('signing as wallet', payer.publicKey);\n                return yield payer.signTransaction(transaction);\n            }\n            else {\n                transaction.sign(...[payer].concat(signers));\n            }\n        });\n    }\n    signTransactions({ transactionsAndSigners, payer, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const now = exports.getUnixTs();\n            let blockhash;\n            // Get new blockhash if stored blockhash more than 70 seconds old\n            if (this.recentBlockhashTime && now < this.recentBlockhashTime + 70) {\n                blockhash = this.recentBlockhash;\n            }\n            else {\n                blockhash = (yield this.connection.getRecentBlockhash(this.blockhashCommitment)).blockhash;\n            }\n            transactionsAndSigners.forEach(({ transaction, signers = [] }) => {\n                transaction.recentBlockhash = blockhash;\n                if (payer.publicKey) {\n                    transaction.setSigners(payer.publicKey, ...signers.map((s) => s.publicKey));\n                }\n                if ((signers === null || signers === void 0 ? void 0 : signers.length) > 0) {\n                    transaction.partialSign(...signers);\n                }\n            });\n            if (adapterTypes_1.adapterHasSignAllTransactions(payer)) {\n                return yield payer.signAllTransactions(transactionsAndSigners.map(({ transaction }) => transaction));\n            }\n            else {\n                transactionsAndSigners.forEach(({ transaction, signers }) => {\n                    // @ts-ignore\n                    transaction.sign(...[payer].concat(signers));\n                });\n                return transactionsAndSigners.map((t) => t.transaction);\n            }\n        });\n    }\n    /**\n     * Send a transaction using the Solana Web3.js connection on the mango client\n     *\n     * @param transaction\n     * @param payer\n     * @param additionalSigners\n     * @param timeout Retries sending the transaction and trying to confirm it until the given timeout. Passing null will disable the transaction confirmation check and always return success.\n     */\n    sendTransaction(transaction, payer, additionalSigners, timeout = this.timeout, confirmLevel = 'processed') {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.signTransaction({\n                transaction,\n                payer,\n                signers: additionalSigners,\n            });\n            const rawTransaction = transaction.serialize();\n            let txid = bs58.encode(transaction.signatures[0].signature);\n            const startTime = exports.getUnixTs();\n            if (this.sendConnection) {\n                const promise = this.sendConnection.sendRawTransaction(rawTransaction);\n                if (this.postSendTxCallback) {\n                    try {\n                        this.postSendTxCallback({ txid });\n                    }\n                    catch (e) {\n                        console.warn(`postSendTxCallback error ${e}`);\n                    }\n                }\n                try {\n                    return yield promise;\n                }\n                catch (e) {\n                    console.error(e);\n                    throw new _1.MangoError({ message: 'Transaction failed', txid });\n                }\n            }\n            else {\n                txid = yield this.connection.sendRawTransaction(rawTransaction, {\n                    skipPreflight: true,\n                });\n                if (this.postSendTxCallback) {\n                    try {\n                        this.postSendTxCallback({ txid });\n                    }\n                    catch (e) {\n                        console.warn(`postSendTxCallback error ${e}`);\n                    }\n                }\n                if (this.timeout) {\n                    timeout = this.timeout < 0 ? timeout : this.timeout * 1000;\n                }\n                if (!timeout)\n                    return txid;\n                console.log('Started awaiting confirmation for', txid, 'size:', rawTransaction.length);\n                let done = false;\n                let retrySleep = 1000;\n                (() => __awaiter(this, void 0, void 0, function* () {\n                    // TODO - make sure this works well on mainnet\n                    while (!done && exports.getUnixTs() - startTime < timeout / 1000) {\n                        yield utils_1.sleep(retrySleep);\n                        // console.log(new Date().toUTCString(), ' sending tx ', txid);\n                        this.connection.sendRawTransaction(rawTransaction, {\n                            skipPreflight: true,\n                        });\n                    }\n                    if (retrySleep <= 8000) {\n                        retrySleep = retrySleep * 2;\n                    }\n                }))();\n                try {\n                    yield this.awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel);\n                }\n                catch (err) {\n                    if (err.timeout) {\n                        throw new _1.TimeoutError({ txid });\n                    }\n                    let simulateResult = null;\n                    try {\n                        simulateResult = (yield utils_1.simulateTransaction(this.connection, transaction, 'processed')).value;\n                    }\n                    catch (e) {\n                        console.warn('Simulate transaction failed');\n                    }\n                    if (simulateResult && simulateResult.err) {\n                        if (simulateResult.logs) {\n                            for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n                                const line = simulateResult.logs[i];\n                                if (line.startsWith('Program log: ')) {\n                                    throw new _1.MangoError({\n                                        message: 'Transaction failed: ' + line.slice('Program log: '.length),\n                                        txid,\n                                    });\n                                }\n                            }\n                        }\n                        throw new _1.MangoError({\n                            message: JSON.stringify(simulateResult.err),\n                            txid,\n                        });\n                    }\n                    throw new _1.MangoError({ message: 'Transaction failed', txid });\n                }\n                finally {\n                    done = true;\n                }\n            }\n            console.log('Latency', txid, exports.getUnixTs() - startTime);\n            return txid;\n        });\n    }\n    sendSignedTransaction({ signedTransaction, timeout = this.timeout, confirmLevel = 'processed', }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const rawTransaction = signedTransaction.serialize();\n            let txid = bs58.encode(signedTransaction.signatures[0].signature);\n            const startTime = exports.getUnixTs();\n            if (this.sendConnection) {\n                const promise = this.sendConnection.sendRawTransaction(rawTransaction);\n                if (this.postSendTxCallback) {\n                    try {\n                        this.postSendTxCallback({ txid });\n                    }\n                    catch (e) {\n                        console.warn(`postSendTxCallback error ${e}`);\n                    }\n                }\n                try {\n                    return yield promise;\n                }\n                catch (e) {\n                    console.error(e);\n                    throw new _1.MangoError({ message: 'Transaction failed', txid });\n                }\n            }\n            else {\n                txid = yield this.connection.sendRawTransaction(rawTransaction, {\n                    skipPreflight: true,\n                });\n                if (this.postSendTxCallback) {\n                    try {\n                        this.postSendTxCallback({ txid });\n                    }\n                    catch (e) {\n                        console.log(`postSendTxCallback error ${e}`);\n                    }\n                }\n                if (!timeout)\n                    return txid;\n                // console.log('Started awaiting confirmation for', txid);\n                let done = false;\n                (() => __awaiter(this, void 0, void 0, function* () {\n                    yield utils_1.sleep(500);\n                    while (!done && exports.getUnixTs() - startTime < timeout) {\n                        this.connection.sendRawTransaction(rawTransaction, {\n                            skipPreflight: true,\n                        });\n                        yield utils_1.sleep(1000);\n                    }\n                }))();\n                try {\n                    yield this.awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel);\n                }\n                catch (err) {\n                    if (err.timeout) {\n                        throw new _1.TimeoutError({ txid });\n                    }\n                    let simulateResult = null;\n                    try {\n                        simulateResult = (yield utils_1.simulateTransaction(this.connection, signedTransaction, 'single')).value;\n                    }\n                    catch (e) {\n                        console.log('Simulate tx failed');\n                    }\n                    if (simulateResult && simulateResult.err) {\n                        if (simulateResult.logs) {\n                            for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n                                const line = simulateResult.logs[i];\n                                if (line.startsWith('Program log: ')) {\n                                    throw new _1.MangoError({\n                                        message: 'Transaction failed: ' + line.slice('Program log: '.length),\n                                        txid,\n                                    });\n                                }\n                            }\n                        }\n                        throw new _1.MangoError({\n                            message: JSON.stringify(simulateResult.err),\n                            txid,\n                        });\n                    }\n                    throw new _1.MangoError({ message: 'Transaction failed', txid });\n                }\n                finally {\n                    done = true;\n                }\n                // console.log('Latency', txid, getUnixTs() - startTime);\n                return txid;\n            }\n        });\n    }\n    awaitTransactionSignatureConfirmation(txid, timeout, confirmLevel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let done = false;\n            const confirmLevels = ['finalized'];\n            if (confirmLevel === 'confirmed') {\n                confirmLevels.push('confirmed');\n            }\n            else if (confirmLevel === 'processed') {\n                confirmLevels.push('confirmed');\n                confirmLevels.push('processed');\n            }\n            let subscriptionId;\n            const result = yield new Promise((resolve, reject) => {\n                (() => __awaiter(this, void 0, void 0, function* () {\n                    setTimeout(() => {\n                        if (done) {\n                            return;\n                        }\n                        done = true;\n                        console.log('Timed out for txid: ', txid);\n                        reject({ timeout: true });\n                    }, timeout);\n                    try {\n                        subscriptionId = this.connection.onSignature(txid, (result, context) => {\n                            subscriptionId = undefined;\n                            done = true;\n                            if (result.err) {\n                                reject(result.err);\n                            }\n                            else {\n                                this.lastSlot = context === null || context === void 0 ? void 0 : context.slot;\n                                resolve(result);\n                            }\n                        }, 'processed');\n                    }\n                    catch (e) {\n                        done = true;\n                        console.log('WS error in setup', txid, e);\n                    }\n                    let retrySleep = 400;\n                    while (!done) {\n                        // eslint-disable-next-line no-loop-func\n                        yield utils_1.sleep(retrySleep);\n                        (() => __awaiter(this, void 0, void 0, function* () {\n                            var _a;\n                            try {\n                                const response = yield this.connection.getSignatureStatuses([\n                                    txid,\n                                ]);\n                                const result = response && response.value[0];\n                                if (!done) {\n                                    if (!result) {\n                                        // console.log('REST null result for', txid, result);\n                                    }\n                                    else if (result.err) {\n                                        console.log('REST error for', txid, result);\n                                        done = true;\n                                        reject(result.err);\n                                    }\n                                    else if (!(result.confirmations ||\n                                        confirmLevels.includes(result.confirmationStatus))) {\n                                        console.log('REST not confirmed', txid, result);\n                                    }\n                                    else {\n                                        this.lastSlot = (_a = response === null || response === void 0 ? void 0 : response.context) === null || _a === void 0 ? void 0 : _a.slot;\n                                        console.log('REST confirmed', txid, result);\n                                        done = true;\n                                        resolve(result);\n                                    }\n                                }\n                            }\n                            catch (e) {\n                                if (!done) {\n                                    console.log('REST connection error: txid', txid, e);\n                                }\n                            }\n                        }))();\n                        if (retrySleep <= 1600) {\n                            retrySleep = retrySleep * 2;\n                        }\n                    }\n                }))();\n            });\n            if (subscriptionId) {\n                this.connection.removeSignatureListener(subscriptionId).catch((e) => {\n                    console.log('WS error in cleanup', e);\n                });\n            }\n            done = true;\n            return result;\n        });\n    }\n    updateRecentBlockhash(blockhashTimes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = exports.getUnixTs();\n            const blockhash = (yield this.connection.getRecentBlockhash(this.blockhashCommitment)).blockhash;\n            blockhashTimes.push({ blockhash, timestamp: now });\n            const blockhashTime = (blockhashTimes.length >= this.maxStoredBlockhashes\n                ? blockhashTimes.shift()\n                : blockhashTimes[0]);\n            this.timeout = 90 - (now - blockhashTime.timestamp);\n            this.recentBlockhash = blockhashTime.blockhash;\n            this.recentBlockhashTime = blockhashTime.timestamp;\n        });\n    }\n    /**\n     * Maintain a timeout of 30 seconds\n     * @param client\n     */\n    maintainTimeouts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const blockhashTimes = [];\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                yield this.updateRecentBlockhash(blockhashTimes);\n                yield utils_1.sleep(10);\n            }\n        });\n    }\n    /**\n     * Create a new Mango group\n     */\n    initMangoGroup(quoteMint, msrmMint, dexProgram, feesVault, // owned by Mango DAO token governance\n    validInterval, quoteOptimalUtil, quoteOptimalRate, quoteMaxRate, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const accountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.MangoGroupLayout.span, this.programId);\n            const { signerKey, signerNonce } = yield utils_1.createSignerKeyAndNonce(this.programId, accountInstruction.account.publicKey);\n            const quoteVaultAccount = new web3_js_1.Keypair();\n            const quoteVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, payer.publicKey, quoteVaultAccount.publicKey, quoteMint, signerKey);\n            const insuranceVaultAccount = new web3_js_1.Keypair();\n            const insuranceVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, payer.publicKey, insuranceVaultAccount.publicKey, quoteMint, signerKey);\n            const quoteNodeBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.NodeBankLayout.span, this.programId);\n            const quoteRootBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.RootBankLayout.span, this.programId);\n            const cacheAccountInstruction = yield utils_1.createAccountInstruction(this.connection, payer.publicKey, layout_1.MangoCacheLayout.span, this.programId);\n            const createAccountsTransaction = new web3_js_1.Transaction();\n            createAccountsTransaction.add(accountInstruction.instruction);\n            createAccountsTransaction.add(...quoteVaultAccountInstructions);\n            createAccountsTransaction.add(quoteNodeBankAccountInstruction.instruction);\n            createAccountsTransaction.add(quoteRootBankAccountInstruction.instruction);\n            createAccountsTransaction.add(cacheAccountInstruction.instruction);\n            createAccountsTransaction.add(...insuranceVaultAccountInstructions);\n            const signers = [\n                accountInstruction.account,\n                quoteVaultAccount,\n                quoteNodeBankAccountInstruction.account,\n                quoteRootBankAccountInstruction.account,\n                cacheAccountInstruction.account,\n                insuranceVaultAccount,\n            ];\n            yield this.sendTransaction(createAccountsTransaction, payer, signers);\n            // If valid msrmMint passed in, then create new msrmVault\n            let msrmVaultPk;\n            if (!msrmMint.equals(utils_1.zeroKey)) {\n                const msrmVaultAccount = new web3_js_1.Keypair();\n                const msrmVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, payer.publicKey, msrmVaultAccount.publicKey, msrmMint, signerKey);\n                const createMsrmVaultTransaction = new web3_js_1.Transaction();\n                createMsrmVaultTransaction.add(...msrmVaultAccountInstructions);\n                msrmVaultPk = msrmVaultAccount.publicKey;\n                yield this.sendTransaction(createMsrmVaultTransaction, payer, [\n                    msrmVaultAccount,\n                ]);\n            }\n            else {\n                msrmVaultPk = utils_1.zeroKey;\n            }\n            const initMangoGroupInstruction = instruction_1.makeInitMangoGroupInstruction(this.programId, accountInstruction.account.publicKey, signerKey, payer.publicKey, quoteMint, quoteVaultAccount.publicKey, quoteNodeBankAccountInstruction.account.publicKey, quoteRootBankAccountInstruction.account.publicKey, insuranceVaultAccount.publicKey, msrmVaultPk, feesVault, cacheAccountInstruction.account.publicKey, dexProgram, new bn_js_1.default(signerNonce), new bn_js_1.default(validInterval), fixednum_1.I80F48.fromNumber(quoteOptimalUtil), fixednum_1.I80F48.fromNumber(quoteOptimalRate), fixednum_1.I80F48.fromNumber(quoteMaxRate));\n            const initMangoGroupTransaction = new web3_js_1.Transaction();\n            initMangoGroupTransaction.add(initMangoGroupInstruction);\n            yield this.sendTransaction(initMangoGroupTransaction, payer, []);\n            return accountInstruction.account.publicKey;\n        });\n    }\n    /**\n     * Retrieve information about a Mango Group\n     */\n    getMangoGroup(mangoGroup) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accountInfo = yield this.connection.getAccountInfo(mangoGroup);\n            const decoded = layout_1.MangoGroupLayout.decode(accountInfo == null ? undefined : accountInfo.data);\n            return new MangoGroup_1.default(mangoGroup, decoded);\n        });\n    }\n    /**\n     * DEPRECATED - Create a new Mango Account on a given group\n     */\n    initMangoAccount(mangoGroup, owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const accountInstruction = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, layout_1.MangoAccountLayout.span, this.programId);\n            const initMangoAccountInstruction = instruction_1.makeInitMangoAccountInstruction(this.programId, mangoGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey);\n            // Add all instructions to one atomic transaction\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(accountInstruction.instruction);\n            transaction.add(initMangoAccountInstruction);\n            const additionalSigners = [accountInstruction.account];\n            yield this.sendTransaction(transaction, owner, additionalSigners);\n            return accountInstruction.account.publicKey;\n        });\n    }\n    /**\n     * Create a new Mango Account (PDA) on a given group\n     */\n    createMangoAccount(mangoGroup, owner, accountNum, payerPk) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const payer = payerPk !== null && payerPk !== void 0 ? payerPk : owner.publicKey;\n            const accountNumBN = new bn_js_1.default(accountNum);\n            const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                mangoGroup.publicKey.toBytes(),\n                owner.publicKey.toBytes(),\n                accountNumBN.toBuffer('le', 8),\n            ], this.programId);\n            const createMangoAccountInstruction = instruction_1.makeCreateMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, accountNumBN, payer);\n            // Add all instructions to one atomic transaction\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(createMangoAccountInstruction);\n            yield this.sendTransaction(transaction, owner, []);\n            return mangoAccountPk;\n        });\n    }\n    /**\n     * Upgrade a Mango Account from V0 (not deletable) to V1 (deletable)\n     */\n    upgradeMangoAccountV0V1(mangoGroup, owner, accountNum) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const accountNumBN = new bn_js_1.default(accountNum);\n            const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                mangoGroup.publicKey.toBytes(),\n                owner.publicKey.toBytes(),\n                accountNumBN.toBuffer(),\n            ], this.programId);\n            const upgradeMangoAccountInstruction = instruction_1.makeUpgradeMangoAccountV0V1Instruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(upgradeMangoAccountInstruction);\n            yield this.sendTransaction(transaction, owner, []);\n            return mangoAccountPk;\n        });\n    }\n    /**\n     * Retrieve information about a Mango Account\n     */\n    getMangoAccount(mangoAccountPk, dexProgramId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const acc = yield this.connection.getAccountInfo(mangoAccountPk, 'processed');\n            const mangoAccount = new MangoAccount_1.default(mangoAccountPk, layout_1.MangoAccountLayout.decode(acc == null ? undefined : acc.data));\n            yield mangoAccount.loadOpenOrders(this.connection, dexProgramId);\n            return mangoAccount;\n        });\n    }\n    /**\n     * Create a new Mango Account and deposit some tokens in a single transaction\n     *\n     * @param rootBank The RootBank for the deposit currency\n     * @param nodeBank The NodeBank asociated with the RootBank\n     * @param vault The token account asociated with the NodeBank\n     * @param tokenAcc The token account to transfer from\n     * @param info An optional UI name for the account\n     */\n    initMangoAccountAndDeposit(mangoGroup, owner, rootBank, nodeBank, vault, tokenAcc, quantity, info) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const accountInstruction = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, layout_1.MangoAccountLayout.span, this.programId);\n            const initMangoAccountInstruction = instruction_1.makeInitMangoAccountInstruction(this.programId, mangoGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey);\n            transaction.add(accountInstruction.instruction);\n            transaction.add(initMangoAccountInstruction);\n            const additionalSigners = [accountInstruction.account];\n            const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n            const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n            let wrappedSolAccount = null;\n            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) &&\n                tokenAcc.toBase58() === owner.publicKey.toBase58()) {\n                wrappedSolAccount = new web3_js_1.Keypair();\n                const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                    fromPubkey: owner.publicKey,\n                    newAccountPubkey: wrappedSolAccount.publicKey,\n                    lamports,\n                    space: 165,\n                    programId: spl_token_1.TOKEN_PROGRAM_ID,\n                }));\n                transaction.add(token_instructions_1.initializeAccount({\n                    account: wrappedSolAccount.publicKey,\n                    mint: token_instructions_1.WRAPPED_SOL_MINT,\n                    owner: owner.publicKey,\n                }));\n                additionalSigners.push(wrappedSolAccount);\n            }\n            const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n            const instruction = instruction_1.makeDepositInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoGroup.mangoCache, accountInstruction.account.publicKey, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);\n            transaction.add(instruction);\n            if (info) {\n                const addAccountNameinstruction = instruction_1.makeAddMangoAccountInfoInstruction(this.programId, mangoGroup.publicKey, accountInstruction.account.publicKey, owner.publicKey, info);\n                transaction.add(addAccountNameinstruction);\n            }\n            if (wrappedSolAccount) {\n                transaction.add(token_instructions_1.closeAccount({\n                    source: wrappedSolAccount.publicKey,\n                    destination: owner.publicKey,\n                    owner: owner.publicKey,\n                }));\n            }\n            yield this.sendTransaction(transaction, owner, additionalSigners);\n            return accountInstruction.account.publicKey.toString();\n        });\n    }\n    /**\n     * Create a new Mango Account (PDA) and deposit some tokens in a single transaction\n     *\n     * @param rootBank The RootBank for the deposit currency\n     * @param nodeBank The NodeBank asociated with the RootBank\n     * @param vault The token account asociated with the NodeBank\n     * @param tokenAcc The token account to transfer from\n     * @param info An optional UI name for the account\n     */\n    createMangoAccountAndDeposit(mangoGroup, owner, rootBank, nodeBank, vault, tokenAcc, quantity, accountNum, info, referrerPk, payerPk) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const payer = payerPk !== null && payerPk !== void 0 ? payerPk : owner.publicKey;\n            const accountNumBN = new bn_js_1.default(accountNum);\n            const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                mangoGroup.publicKey.toBytes(),\n                owner.publicKey.toBytes(),\n                accountNumBN.toArrayLike(Buffer, 'le', 8),\n            ], this.programId);\n            const createMangoAccountInstruction = instruction_1.makeCreateMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, accountNumBN, payer);\n            transaction.add(createMangoAccountInstruction);\n            if (referrerPk) {\n                const [referrerMemoryPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccountPk.toBytes(), new Buffer('ReferrerMemory', 'utf-8')], this.programId);\n                const setReferrerInstruction = instruction_1.makeSetReferrerMemoryInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, referrerMemoryPk, referrerPk, owner.publicKey);\n                transaction.add(setReferrerInstruction);\n            }\n            const additionalSigners = [];\n            const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n            const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n            let wrappedSolAccount = null;\n            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) &&\n                tokenAcc.toBase58() === owner.publicKey.toBase58()) {\n                wrappedSolAccount = new web3_js_1.Keypair();\n                const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                    fromPubkey: owner.publicKey,\n                    newAccountPubkey: wrappedSolAccount.publicKey,\n                    lamports,\n                    space: 165,\n                    programId: spl_token_1.TOKEN_PROGRAM_ID,\n                }));\n                transaction.add(token_instructions_1.initializeAccount({\n                    account: wrappedSolAccount.publicKey,\n                    mint: token_instructions_1.WRAPPED_SOL_MINT,\n                    owner: owner.publicKey,\n                }));\n                additionalSigners.push(wrappedSolAccount);\n            }\n            const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n            const instruction = instruction_1.makeDepositInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoGroup.mangoCache, mangoAccountPk, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);\n            transaction.add(instruction);\n            if (info) {\n                const addAccountNameinstruction = instruction_1.makeAddMangoAccountInfoInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, owner.publicKey, info);\n                transaction.add(addAccountNameinstruction);\n            }\n            if (wrappedSolAccount) {\n                transaction.add(token_instructions_1.closeAccount({\n                    source: wrappedSolAccount.publicKey,\n                    destination: owner.publicKey,\n                    owner: owner.publicKey,\n                }));\n            }\n            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);\n            return [mangoAccountPk.toString(), txid];\n        });\n    }\n    /**\n     * Deposit tokens in a Mango Account\n     *\n     * @param rootBank The RootBank for the deposit currency\n     * @param nodeBank The NodeBank asociated with the RootBank\n     * @param vault The token account asociated with the NodeBank\n     * @param tokenAcc The token account to transfer from\n     */\n    deposit(mangoGroup, mangoAccount, owner, rootBank, nodeBank, vault, tokenAcc, quantity) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n            const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n            let wrappedSolAccount = null;\n            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT) &&\n                tokenAcc.toBase58() === owner.publicKey.toBase58()) {\n                wrappedSolAccount = new web3_js_1.Keypair();\n                const lamports = Math.round(quantity * web3_js_1.LAMPORTS_PER_SOL) + 1e7;\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                    fromPubkey: owner.publicKey,\n                    newAccountPubkey: wrappedSolAccount.publicKey,\n                    lamports,\n                    space: 165,\n                    programId: spl_token_1.TOKEN_PROGRAM_ID,\n                }));\n                transaction.add(token_instructions_1.initializeAccount({\n                    account: wrappedSolAccount.publicKey,\n                    mint: token_instructions_1.WRAPPED_SOL_MINT,\n                    owner: owner.publicKey,\n                }));\n                additionalSigners.push(wrappedSolAccount);\n            }\n            const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n            const instruction = instruction_1.makeDepositInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, rootBank, nodeBank, vault, (_a = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _a !== void 0 ? _a : tokenAcc, nativeQuantity);\n            transaction.add(instruction);\n            if (wrappedSolAccount) {\n                transaction.add(token_instructions_1.closeAccount({\n                    source: wrappedSolAccount.publicKey,\n                    destination: owner.publicKey,\n                    owner: owner.publicKey,\n                }));\n            }\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    /**\n     * Withdraw tokens from a Mango Account\n     *\n     * @param rootBank The RootBank for the withdrawn currency\n     * @param nodeBank The NodeBank asociated with the RootBank\n     * @param vault The token account asociated with the NodeBank\n     * @param allowBorrow Whether to borrow tokens if there are not enough deposits for the withdrawal\n     */\n    withdraw(mangoGroup, mangoAccount, owner, rootBank, nodeBank, vault, quantity, allowBorrow) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            const tokenIndex = mangoGroup.getRootBankIndex(rootBank);\n            const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n            let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner.publicKey);\n            let wrappedSolAccount = null;\n            if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n                wrappedSolAccount = new web3_js_1.Keypair();\n                tokenAcc = wrappedSolAccount.publicKey;\n                const space = 165;\n                const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'processed');\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                    fromPubkey: owner.publicKey,\n                    newAccountPubkey: tokenAcc,\n                    lamports,\n                    space,\n                    programId: spl_token_1.TOKEN_PROGRAM_ID,\n                }));\n                transaction.add(token_instructions_1.initializeAccount({\n                    account: tokenAcc,\n                    mint: token_instructions_1.WRAPPED_SOL_MINT,\n                    owner: owner.publicKey,\n                }));\n                additionalSigners.push(wrappedSolAccount);\n            }\n            else {\n                const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc);\n                if (!tokenAccExists) {\n                    transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, owner.publicKey, owner.publicKey));\n                }\n            }\n            const nativeQuantity = utils_1.uiToNative(quantity, mangoGroup.tokens[tokenIndex].decimals);\n            const instruction = instruction_1.makeWithdrawInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, rootBank, nodeBank, vault, tokenAcc, mangoGroup.signerKey, mangoAccount.spotOpenOrders, nativeQuantity, allowBorrow);\n            transaction.add(instruction);\n            if (wrappedSolAccount) {\n                transaction.add(token_instructions_1.closeAccount({\n                    source: wrappedSolAccount.publicKey,\n                    destination: owner.publicKey,\n                    owner: owner.publicKey,\n                }));\n            }\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    withdrawAll(mangoGroup, mangoAccount, owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transactionsAndSigners = [];\n            for (const rootBank of mangoGroup.rootBankAccounts) {\n                const transactionAndSigners = {\n                    transaction: new web3_js_1.Transaction(),\n                    signers: [],\n                };\n                if (rootBank) {\n                    const tokenIndex = mangoGroup.getRootBankIndex(rootBank === null || rootBank === void 0 ? void 0 : rootBank.publicKey);\n                    const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n                    // const decimals = mangoGroup.tokens[tokenIndex].decimals;\n                    if (mangoAccount.deposits[tokenIndex].isPos()) {\n                        let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, owner.publicKey);\n                        let wrappedSolAccount = null;\n                        if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n                            wrappedSolAccount = new web3_js_1.Keypair();\n                            tokenAcc = wrappedSolAccount.publicKey;\n                            const space = 165;\n                            const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'processed');\n                            transactionAndSigners.transaction.add(web3_js_1.SystemProgram.createAccount({\n                                fromPubkey: owner.publicKey,\n                                newAccountPubkey: tokenAcc,\n                                lamports,\n                                space,\n                                programId: spl_token_1.TOKEN_PROGRAM_ID,\n                            }));\n                            transactionAndSigners.transaction.add(token_instructions_1.initializeAccount({\n                                account: tokenAcc,\n                                mint: token_instructions_1.WRAPPED_SOL_MINT,\n                                owner: owner.publicKey,\n                            }));\n                            transactionAndSigners.signers.push(wrappedSolAccount);\n                        }\n                        else {\n                            const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc, 'recent');\n                            if (!tokenAccExists) {\n                                transactionAndSigners.transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, owner.publicKey, owner.publicKey));\n                            }\n                        }\n                        const instruction = instruction_1.makeWithdrawInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, rootBank.publicKey, rootBank.nodeBanks[0], rootBank.nodeBankAccounts[0].vault, tokenAcc, mangoGroup.signerKey, mangoAccount.spotOpenOrders, new bn_js_1.default('18446744073709551615'), // u64::MAX to withdraw errything\n                        false);\n                        transactionAndSigners.transaction.add(instruction);\n                        if (wrappedSolAccount) {\n                            transactionAndSigners.transaction.add(token_instructions_1.closeAccount({\n                                source: wrappedSolAccount.publicKey,\n                                destination: owner.publicKey,\n                                owner: owner.publicKey,\n                            }));\n                        }\n                    }\n                }\n                transactionsAndSigners.push(transactionAndSigners);\n            }\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer: owner,\n            });\n            if (signedTransactions) {\n                for (const signedTransaction of signedTransactions) {\n                    if (signedTransaction.instructions.length == 0) {\n                        continue;\n                    }\n                    const txid = yield this.sendSignedTransaction({\n                        signedTransaction,\n                    });\n                    console.log(txid);\n                }\n            }\n            else {\n                throw new Error('Unable to sign Settle All transaction');\n            }\n        });\n    }\n    // Keeper functions\n    /**\n     * Called by the Keeper to cache interest rates from the RootBanks\n     */\n    cacheRootBanks(mangoGroup, mangoCache, rootBanks, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cacheRootBanksInstruction = instruction_1.makeCacheRootBankInstruction(this.programId, mangoGroup, mangoCache, rootBanks);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(cacheRootBanksInstruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    /**\n     * Called by the Keeper to cache prices from the Oracles\n     */\n    cachePrices(mangoGroup, mangoCache, oracles, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cachePricesInstruction = instruction_1.makeCachePricesInstruction(this.programId, mangoGroup, mangoCache, oracles);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(cachePricesInstruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    /**\n     * Called by the Keeper to cache perp market funding\n     */\n    cachePerpMarkets(mangoGroup, mangoCache, perpMarkets, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cachePerpMarketsInstruction = instruction_1.makeCachePerpMarketsInstruction(this.programId, mangoGroup, mangoCache, perpMarkets);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(cachePerpMarketsInstruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    /**\n     * Called by the Keeper to update interest rates on the RootBanks\n     */\n    updateRootBank(mangoGroup, rootBank, nodeBanks, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const updateRootBanksInstruction = instruction_1.makeUpdateRootBankInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, rootBank, nodeBanks);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(updateRootBanksInstruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    /**\n     * Called by the Keeper to process events on the Perp order book\n     */\n    consumeEvents(mangoGroup, perpMarket, mangoAccounts, payer, limit) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const consumeEventsInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, mangoAccounts, limit);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(consumeEventsInstruction);\n            return yield this.sendTransaction(transaction, payer, [], null);\n        });\n    }\n    /**\n     * Called by the Keeper to update funding on the perp markets\n     */\n    updateFunding(mangoGroup, mangoCache, perpMarket, bids, asks, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const updateFundingInstruction = instruction_1.makeUpdateFundingInstruction(this.programId, mangoGroup, mangoCache, perpMarket, bids, asks);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(updateFundingInstruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    /**\n     * Retrieve information about a perp market\n     */\n    getPerpMarket(perpMarketPk, baseDecimal, quoteDecimal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const acc = yield this.connection.getAccountInfo(perpMarketPk);\n            const perpMarket = new PerpMarket_1.default(perpMarketPk, baseDecimal, quoteDecimal, layout_1.PerpMarketLayout.decode(acc === null || acc === void 0 ? void 0 : acc.data));\n            return perpMarket;\n        });\n    }\n    /**\n     * Place an order on a perp market\n     *\n     * @param clientOrderId An optional id that can be used to correlate events related to your order\n     * @param bookSideInfo Account info for asks if side === bid, bids if side === ask. If this is given, crank instruction is added\n     */\n    placePerpOrder(mangoGroup, mangoAccount, mangoCache, // TODO - remove; already in MangoGroup\n    perpMarket, owner, side, price, quantity, orderType, clientOrderId = 0, bookSideInfo, reduceOnly, referrerMangoAccountPk) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            const instruction = instruction_1.makePlacePerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.spotOpenOrders, nativePrice, nativeQuantity, new bn_js_1.default(clientOrderId), side, orderType, reduceOnly, referrerMangoAccountPk);\n            transaction.add(instruction);\n            if (bookSideInfo) {\n                // If this data is already parsed as BookSide, use that instead of decoding again\n                let bookSide = bookSideInfo['parsed'];\n                if (bookSide === undefined) {\n                    bookSide = bookSideInfo.data\n                        ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data))\n                        : [];\n                }\n                const accounts = new Set();\n                accounts.add(mangoAccount.publicKey.toBase58());\n                for (const order of bookSide) {\n                    accounts.add(order.owner.toBase58());\n                    if (accounts.size >= 10) {\n                        break;\n                    }\n                }\n                const consumeInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts)\n                    .map((s) => new web3_js_1.PublicKey(s))\n                    .sort(), new bn_js_1.default(4));\n                transaction.add(consumeInstruction);\n            }\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    /**\n     * Place an order on a perp market\n     *\n     * @param clientOrderId An optional id that can be used to correlate events related to your order\n     * @param bookSideInfo Account info for asks if side === bid, bids if side === ask. If this is given, crank instruction is added\n     */\n    placePerpOrder2(mangoGroup, mangoAccount, perpMarket, owner, side, price, quantity, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            options = options ? options : {};\n            let { maxQuoteQuantity, limit, orderType, clientOrderId, bookSideInfo, reduceOnly, referrerMangoAccountPk, expiryTimestamp, } = options;\n            limit = limit || 20;\n            clientOrderId = clientOrderId === undefined ? 0 : clientOrderId;\n            orderType = orderType || 'limit';\n            const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);\n            const maxQuoteQuantityLots = maxQuoteQuantity\n                ? perpMarket.uiQuoteToLots(maxQuoteQuantity)\n                : utils_1.I64_MAX_BN;\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            const instruction = instruction_1.makePlacePerpOrder2Instruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.getOpenOrdersKeysInBasketPacked(), nativePrice, nativeQuantity, maxQuoteQuantityLots, new bn_js_1.default(clientOrderId), side, new bn_js_1.default(limit), orderType, reduceOnly, referrerMangoAccountPk, expiryTimestamp ? new bn_js_1.default(Math.floor(expiryTimestamp)) : utils_1.ZERO_BN);\n            transaction.add(instruction);\n            if (bookSideInfo) {\n                // If this data is already parsed as BookSide, use that instead of decoding again\n                let bookSide = bookSideInfo['parsed'];\n                if (bookSide === undefined) {\n                    bookSide = bookSideInfo.data\n                        ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data))\n                        : [];\n                }\n                const accounts = new Set();\n                accounts.add(mangoAccount.publicKey.toBase58());\n                for (const order of bookSide) {\n                    accounts.add(order.owner.toBase58());\n                    if (accounts.size >= 10) {\n                        break;\n                    }\n                }\n                const consumeInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts)\n                    .map((s) => new web3_js_1.PublicKey(s))\n                    .sort(), new bn_js_1.default(4));\n                transaction.add(consumeInstruction);\n            }\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    /**\n     * Cancel an order on a perp market\n     *\n     * @param invalidIdOk Don't throw error if order is invalid\n     */\n    cancelPerpOrder(mangoGroup, mangoAccount, owner, perpMarket, order, invalidIdOk = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeCancelPerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, order, invalidIdOk);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    /**\n     * Cancel all perp orders across all markets\n     */\n    cancelAllPerpOrders(group, perpMarkets, mangoAccount, owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            let tx = new web3_js_1.Transaction();\n            const transactions = [];\n            // Determine which market indexes have open orders\n            const hasOrders = new Array(group.perpMarkets.length).fill(false);\n            for (let i = 0; i < mangoAccount.orderMarket.length; i++) {\n                if (mangoAccount.orderMarket[i] !== layout_1.FREE_ORDER_SLOT) {\n                    hasOrders[mangoAccount.orderMarket[i]] = true;\n                }\n            }\n            for (let i = 0; i < group.perpMarkets.length; i++) {\n                if (!hasOrders[i])\n                    continue;\n                const pmi = group.perpMarkets[i];\n                if (pmi.isEmpty())\n                    continue;\n                const perpMarket = perpMarkets.find((pm) => pm.publicKey.equals(pmi.perpMarket));\n                if (perpMarket === undefined)\n                    continue;\n                const cancelAllInstr = instruction_1.makeCancelAllPerpOrdersInstruction(this.programId, group.publicKey, mangoAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, new bn_js_1.default(20));\n                tx.add(cancelAllInstr);\n                if (tx.instructions.length === 2) {\n                    transactions.push(tx);\n                    tx = new web3_js_1.Transaction();\n                }\n            }\n            if (tx.instructions.length > 0) {\n                transactions.push(tx);\n            }\n            const transactionsAndSigners = transactions.map((tx) => ({\n                transaction: tx,\n                signers: [],\n            }));\n            if (transactionsAndSigners.length === 0) {\n                throw new Error('No orders to cancel');\n            }\n            // Sign multiple transactions at once for better UX\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer: owner,\n            });\n            if (signedTransactions) {\n                return yield Promise.all(signedTransactions.map((signedTransaction) => this.sendSignedTransaction({ signedTransaction })));\n            }\n            else {\n                throw new Error('Unable to sign all CancelAllPerpOrders transactions');\n            }\n        });\n    }\n    /*\n    async loadPerpMarkets(perpMarkets: PublicKey[]): Promise<PerpMarket[]> {\n      const accounts = await Promise.all(\n        perpMarkets.map((pk) => this.connection.getAccountInfo(pk)),\n      );\n  \n      const parsedPerpMarkets: PerpMarket[] = [];\n  \n      for (let i = 0; i < accounts.length; i++) {\n        const acc = accounts[i];\n        if (acc) {\n          const decoded = PerpMarketLayout.decode(acc.data);\n          parsedPerpMarkets.push(new PerpMarket(perpMarkets[i], decoded));\n        }\n      }\n  \n      return parsedPerpMarkets;\n    }\n    */\n    /**\n     * Add a new oracle to a group\n     */\n    addOracle(mangoGroup, oracle, admin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeAddOracleInstruction(this.programId, mangoGroup.publicKey, oracle, admin.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    /**\n     * Set the price of a 'stub' type oracle\n     */\n    setOracle(mangoGroup, oracle, admin, price) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeSetOracleInstruction(this.programId, mangoGroup.publicKey, oracle, admin.publicKey, price);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    addSpotMarket(mangoGroup, oracle, spotMarket, mint, admin, maintLeverage, initLeverage, liquidationFee, optimalUtil, optimalRate, maxRate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vaultAccount = new web3_js_1.Keypair();\n            const vaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, admin.publicKey, vaultAccount.publicKey, mint, mangoGroup.signerKey);\n            const nodeBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.NodeBankLayout.span, this.programId);\n            const rootBankAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.RootBankLayout.span, this.programId);\n            const instruction = instruction_1.makeAddSpotMarketInstruction(this.programId, mangoGroup.publicKey, oracle, spotMarket, mangoGroup.dexProgramId, mint, nodeBankAccountInstruction.account.publicKey, vaultAccount.publicKey, rootBankAccountInstruction.account.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(optimalUtil), fixednum_1.I80F48.fromNumber(optimalRate), fixednum_1.I80F48.fromNumber(maxRate));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(...vaultAccountInstructions);\n            transaction.add(nodeBankAccountInstruction.instruction);\n            transaction.add(rootBankAccountInstruction.instruction);\n            transaction.add(instruction);\n            const additionalSigners = [\n                vaultAccount,\n                nodeBankAccountInstruction.account,\n                rootBankAccountInstruction.account,\n            ];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    /**\n     * Make sure mangoAccount has recent and valid inMarginBasket and spotOpenOrders\n     */\n    placeSpotOrder(mangoGroup, mangoAccount, mangoCache, spotMarket, owner, side, price, size, orderType, clientId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const limitPrice = spotMarket.priceNumberToLots(price);\n            const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);\n            // TODO implement srm vault fee discount\n            // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));\n            const feeTier = serum_1.getFeeTier(0, utils_1.nativeToUi(0, 0));\n            const rates = serum_1.getFeeRates(feeTier);\n            const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket\n                .baseSizeNumberToLots(size)\n                .mul(spotMarket.priceNumberToLots(price)));\n            if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {\n                throw new Error('size too small');\n            }\n            if (limitPrice.lte(utils_1.ZERO_BN)) {\n                throw new Error('invalid price');\n            }\n            const selfTradeBehavior = 'decrementTake';\n            clientId = clientId !== null && clientId !== void 0 ? clientId : new bn_js_1.default(Date.now());\n            const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n            if (!mangoGroup.rootBankAccounts.filter((a) => !!a).length) {\n                yield mangoGroup.loadRootBanks(this.connection);\n            }\n            const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];\n            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n            const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n            if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {\n                throw new Error('Invalid or missing banks');\n            }\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            const openOrdersKeys = [];\n            // Only pass in open orders if in margin basket or current market index, and\n            // the only writable account should be OpenOrders for current market index\n            for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n                let pubkey = utils_1.zeroKey;\n                let isWritable = false;\n                if (i === spotMarketIndex) {\n                    isWritable = true;\n                    if (mangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n                        // open orders missing for this market; create a new one now\n                        const openOrdersSpace = serum_1.OpenOrders.getLayout(mangoGroup.dexProgramId).span;\n                        const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'processed');\n                        const accInstr = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, openOrdersSpace, mangoGroup.dexProgramId, openOrdersLamports);\n                        const initOpenOrders = instruction_1.makeInitSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, mangoGroup.signerKey);\n                        const initTx = new web3_js_1.Transaction();\n                        initTx.add(accInstr.instruction);\n                        initTx.add(initOpenOrders);\n                        yield this.sendTransaction(initTx, owner, [accInstr.account]);\n                        pubkey = accInstr.account.publicKey;\n                    }\n                    else {\n                        pubkey = mangoAccount.spotOpenOrders[i];\n                    }\n                }\n                else if (mangoAccount.inMarginBasket[i]) {\n                    pubkey = mangoAccount.spotOpenOrders[i];\n                }\n                openOrdersKeys.push({ pubkey, isWritable });\n            }\n            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                spotMarket.publicKey.toBuffer(),\n                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], spotMarket.programId);\n            const placeOrderInstruction = instruction_1.makePlaceSpotOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, mangoGroup.srmVault, // TODO: choose msrm vault if it has any deposits\n            openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientId);\n            transaction.add(placeOrderInstruction);\n            if (spotMarketIndex > 0) {\n                console.log(spotMarketIndex - 1, mangoAccount.spotOpenOrders[spotMarketIndex - 1].toBase58(), openOrdersKeys[spotMarketIndex - 1].pubkey.toBase58());\n            }\n            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);\n            // update MangoAccount to have new OpenOrders pubkey\n            mangoAccount.spotOpenOrders[spotMarketIndex] =\n                openOrdersKeys[spotMarketIndex].pubkey;\n            mangoAccount.inMarginBasket[spotMarketIndex] = true;\n            console.log(spotMarketIndex, mangoAccount.spotOpenOrders[spotMarketIndex].toBase58(), openOrdersKeys[spotMarketIndex].pubkey.toBase58());\n            return txid;\n        });\n    }\n    /**\n     * Make sure mangoAccount has recent and valid inMarginBasket and spotOpenOrders\n     */\n    placeSpotOrder2(mangoGroup, mangoAccount, spotMarket, owner, side, price, size, orderType, clientOrderId, useMsrmVault) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const limitPrice = spotMarket.priceNumberToLots(price);\n            const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);\n            const allTransactions = [];\n            // TODO implement srm vault fee discount\n            // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));\n            const feeTier = serum_1.getFeeTier(0, utils_1.nativeToUi(0, 0));\n            const rates = serum_1.getFeeRates(feeTier);\n            const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket\n                .baseSizeNumberToLots(size)\n                .mul(spotMarket.priceNumberToLots(price)));\n            if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {\n                throw new Error('size too small');\n            }\n            if (limitPrice.lte(utils_1.ZERO_BN)) {\n                throw new Error('invalid price');\n            }\n            const selfTradeBehavior = 'decrementTake';\n            const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n            if (!mangoGroup.rootBankAccounts.filter((a) => !!a).length) {\n                yield mangoGroup.loadRootBanks(this.connection);\n            }\n            let feeVault;\n            if (useMsrmVault) {\n                feeVault = mangoGroup.msrmVault;\n            }\n            else if (useMsrmVault === false) {\n                feeVault = mangoGroup.srmVault;\n            }\n            else {\n                const totalMsrm = yield this.connection.getTokenAccountBalance(mangoGroup.msrmVault);\n                feeVault =\n                    ((_a = totalMsrm === null || totalMsrm === void 0 ? void 0 : totalMsrm.value) === null || _a === void 0 ? void 0 : _a.uiAmount) && totalMsrm.value.uiAmount > 0\n                        ? mangoGroup.msrmVault\n                        : mangoGroup.srmVault;\n            }\n            const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];\n            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n            const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n            if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {\n                throw new Error('Invalid or missing banks');\n            }\n            const transaction = new web3_js_1.Transaction();\n            const openOrdersKeys = [];\n            // Only pass in open orders if in margin basket or current market index, and\n            // the only writable account should be OpenOrders for current market index\n            let marketOpenOrdersKey = utils_1.zeroKey;\n            const initTx = new web3_js_1.Transaction();\n            for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n                let pubkey = utils_1.zeroKey;\n                let isWritable = false;\n                if (i === spotMarketIndex) {\n                    isWritable = true;\n                    if (mangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n                        const spotMarketIndexBN = new bn_js_1.default(spotMarketIndex);\n                        const [openOrdersPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                            mangoAccount.publicKey.toBytes(),\n                            spotMarketIndexBN.toArrayLike(Buffer, 'le', 8),\n                            new Buffer('OpenOrders', 'utf-8'),\n                        ], this.programId);\n                        const initOpenOrders = _1.makeCreateSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.dexProgramId, openOrdersPk, spotMarket.publicKey, mangoGroup.signerKey);\n                        initTx.add(initOpenOrders);\n                        allTransactions.push(initTx);\n                        pubkey = openOrdersPk;\n                    }\n                    else {\n                        pubkey = mangoAccount.spotOpenOrders[i];\n                    }\n                    marketOpenOrdersKey = pubkey;\n                }\n                else if (mangoAccount.inMarginBasket[i]) {\n                    pubkey = mangoAccount.spotOpenOrders[i];\n                }\n                // new design does not require zero keys to be passed in\n                if (!pubkey.equals(utils_1.zeroKey)) {\n                    openOrdersKeys.push({ pubkey, isWritable });\n                }\n            }\n            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                spotMarket.publicKey.toBuffer(),\n                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], spotMarket.programId);\n            const placeOrderInstruction = instruction_1.makePlaceSpotOrder2Instruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, feeVault, openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : new bn_js_1.default(Date.now()));\n            transaction.add(placeOrderInstruction);\n            allTransactions.push(transaction);\n            const signers = [];\n            const transactionsAndSigners = allTransactions.map((tx) => ({\n                transaction: tx,\n                signers,\n            }));\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer: owner,\n            });\n            const txids = [];\n            if (signedTransactions) {\n                for (const signedTransaction of signedTransactions) {\n                    if (signedTransaction.instructions.length == 0) {\n                        continue;\n                    }\n                    const txid = yield this.sendSignedTransaction({\n                        signedTransaction,\n                    });\n                    txids.push(txid);\n                }\n                // update MangoAccount to have new OpenOrders pubkey\n                // We know this new key is in margin basket because if it was a full taker trade\n                // there is some leftover from fee rebate. If maker trade there's the order.\n                // and if it failed then we already exited before this line\n                mangoAccount.spotOpenOrders[spotMarketIndex] = marketOpenOrdersKey;\n                mangoAccount.inMarginBasket[spotMarketIndex] = true;\n                console.log(spotMarketIndex, mangoAccount.spotOpenOrders[spotMarketIndex].toBase58(), marketOpenOrdersKey.toBase58());\n            }\n            else {\n                throw new Error('Unable to sign Settle All transaction');\n            }\n            return txids;\n        });\n    }\n    cancelSpotOrder(mangoGroup, mangoAccount, owner, spotMarket, order) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const instruction = instruction_1.makeCancelSpotOrderInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, order.openOrdersAddress, mangoGroup.signerKey, spotMarket['_decoded'].eventQueue, order);\n            transaction.add(instruction);\n            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                spotMarket.publicKey.toBuffer(),\n                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], spotMarket.programId);\n            const marketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n            if (!mangoGroup.rootBankAccounts.length) {\n                yield mangoGroup.loadRootBanks(this.connection);\n            }\n            const baseRootBank = mangoGroup.rootBankAccounts[marketIndex];\n            const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n            if (!baseNodeBank || !quoteNodeBank) {\n                throw new Error('Invalid or missing node banks');\n            }\n            const settleFundsInstruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[marketIndex], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[marketIndex].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n            transaction.add(settleFundsInstruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    settleFunds(mangoGroup, mangoAccount, owner, spotMarket) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const marketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                spotMarket.publicKey.toBuffer(),\n                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], spotMarket.programId);\n            if (!mangoGroup.rootBankAccounts.length) {\n                yield mangoGroup.loadRootBanks(this.connection);\n            }\n            const baseRootBank = mangoGroup.rootBankAccounts[marketIndex];\n            const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n            if (!baseNodeBank || !quoteNodeBank) {\n                throw new Error('Invalid or missing node banks');\n            }\n            const instruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[marketIndex], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[marketIndex].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    /**\n     * Assumes spotMarkets contains all Markets in MangoGroup in order\n     */\n    settleAll(mangoGroup, mangoAccount, spotMarkets, owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transactions = [];\n            let j = 0;\n            for (let i = 0; i < mangoGroup.spotMarkets.length; i++) {\n                if (mangoGroup.spotMarkets[i].isEmpty())\n                    continue;\n                const spotMarket = spotMarkets[j];\n                j++;\n                const transaction = new web3_js_1.Transaction();\n                const openOrdersAccount = mangoAccount.spotOpenOrdersAccounts[i];\n                if (openOrdersAccount === undefined)\n                    continue;\n                if (openOrdersAccount.quoteTokenFree.toNumber() +\n                    openOrdersAccount['referrerRebatesAccrued'].toNumber() ===\n                    0 &&\n                    openOrdersAccount.baseTokenFree.toNumber() === 0) {\n                    continue;\n                }\n                const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                    spotMarket.publicKey.toBuffer(),\n                    spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n                ], spotMarket.programId);\n                if (!mangoGroup.rootBankAccounts.length) {\n                    yield mangoGroup.loadRootBanks(this.connection);\n                }\n                const baseRootBank = mangoGroup.rootBankAccounts[i];\n                const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n                const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n                const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n                if (!baseNodeBank || !quoteNodeBank) {\n                    throw new Error('Invalid or missing node banks');\n                }\n                const instruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[i], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[i].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n                transaction.add(instruction);\n                transactions.push(transaction);\n            }\n            const signers = [];\n            const transactionsAndSigners = transactions.map((tx) => ({\n                transaction: tx,\n                signers,\n            }));\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer: owner,\n            });\n            const txids = [];\n            if (signedTransactions) {\n                for (const signedTransaction of signedTransactions) {\n                    if (signedTransaction.instructions.length == 0) {\n                        continue;\n                    }\n                    const txid = yield this.sendSignedTransaction({\n                        signedTransaction,\n                    });\n                    txids.push(txid);\n                }\n            }\n            else {\n                throw new Error('Unable to sign Settle All transaction');\n            }\n            return txids;\n        });\n    }\n    fetchTopPnlAccountsFromRPC(mangoGroup, mangoCache, perpMarket, price, // should be the MangoCache price\n    sign, mangoAccounts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n            const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n            if (mangoAccounts === undefined) {\n                mangoAccounts = yield this.getAllMangoAccounts(mangoGroup, [], false);\n            }\n            return mangoAccounts\n                .map((m) => ({\n                publicKey: m.publicKey,\n                pnl: m.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price),\n            }))\n                .sort((a, b) => sign * a.pnl.cmp(b.pnl));\n        });\n    }\n    fetchTopPnlAccountsFromDB(mangoGroup, perpMarket, sign) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n            const order = sign === 1 ? 'ASC' : 'DESC';\n            const response = yield cross_fetch_1.default(`https://mango-transaction-log.herokuapp.com/v3/stats/ranked-pnl?market-index=${marketIndex}&order=${order}&limit=20`);\n            const data = yield response.json();\n            return data.map((m) => ({\n                publicKey: new web3_js_1.PublicKey(m.pubkey),\n                pnl: fixednum_1.I80F48.fromNumber(m.pnl),\n            }));\n        });\n    }\n    /**\n     * Automatically fetch MangoAccounts for this PerpMarket\n     * Pick enough MangoAccounts that have opposite sign and send them in to get settled\n     */\n    settlePnl(mangoGroup, mangoCache, mangoAccount, perpMarket, quoteRootBank, price, // should be the MangoCache price\n    owner, mangoAccounts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // fetch all MangoAccounts filtered for having this perp market in basket\n            const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n            const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n            let pnl = mangoAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price);\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            let sign;\n            if (pnl.eq(fixednum_1.ZERO_I80F48)) {\n                // Can't settle pnl if there is no pnl\n                return null;\n            }\n            else if (pnl.gt(fixednum_1.ZERO_I80F48)) {\n                sign = 1;\n            }\n            else {\n                // Can settle fees first against perpmarket\n                sign = -1;\n                if (!quoteRootBank.nodeBankAccounts) {\n                    yield quoteRootBank.loadNodeBanks(this.connection);\n                }\n                const settleFeesInstr = instruction_1.makeSettleFeesInstruction(this.programId, mangoGroup.publicKey, mangoCache.publicKey, perpMarket.publicKey, mangoAccount.publicKey, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], quoteRootBank.nodeBankAccounts[0].vault, mangoGroup.feesVault, mangoGroup.signerKey);\n                transaction.add(settleFeesInstr);\n                pnl = pnl.add(perpMarket.feesAccrued).min(fixednum_1.I80F48.fromString('-0.000001'));\n                const remSign = pnl.gt(fixednum_1.ZERO_I80F48) ? 1 : -1;\n                if (remSign !== sign) {\n                    // if pnl has changed sign, then we're done\n                    return yield this.sendTransaction(transaction, owner, additionalSigners);\n                }\n            }\n            // we don't maintain an off chain service for finding accounts for\n            // devnet, so use fetchTopPnlAccountsFromDB only for mainnet\n            let accountsWithPnl;\n            // note: simplistic way of checking if we are on mainnet\n            const isMainnet = this.connection['_rpcEndpoint'] &&\n                !this.connection['_rpcEndpoint']\n                    .toLowerCase()\n                    // usually devnet rpc endpoints have devnet in them, mainnet ones don't\n                    .includes('devnet');\n            if (isMainnet) {\n                try {\n                    accountsWithPnl = yield this.fetchTopPnlAccountsFromDB(mangoGroup, perpMarket, sign);\n                }\n                catch (e) {\n                    console.error(`fetchTopPnlAccountsFromDB failed, ${e}`);\n                }\n            }\n            // if not set, then always fallback\n            if (!accountsWithPnl) {\n                accountsWithPnl = yield this.fetchTopPnlAccountsFromRPC(mangoGroup, mangoCache, perpMarket, price, sign, mangoAccounts);\n            }\n            for (const account of accountsWithPnl) {\n                // ignore own account explicitly\n                if (account.publicKey.equals(mangoAccount.publicKey)) {\n                    continue;\n                }\n                if (((pnl.isPos() && account.pnl.isNeg()) ||\n                    (pnl.isNeg() && account.pnl.isPos())) &&\n                    transaction.instructions.length < 10) {\n                    // Account pnl must have opposite signs\n                    const instr = instruction_1.makeSettlePnlInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, account.publicKey, mangoGroup.mangoCache, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], new bn_js_1.default(marketIndex));\n                    transaction.add(instr);\n                    pnl = pnl.add(account.pnl);\n                    // if pnl has changed sign, then we're done\n                    const remSign = pnl.gt(fixednum_1.ZERO_I80F48) ? 1 : -1;\n                    if (remSign !== sign) {\n                        break;\n                    }\n                }\n                else {\n                    // means we ran out of accounts to settle against (shouldn't happen) OR transaction too big\n                    // TODO - create a multi tx to be signed by user\n                    continue;\n                }\n            }\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n            // Calculate the profit or loss per market\n        });\n    }\n    /**\n     * Settle all perp accounts with positive pnl\n     */\n    settlePosPnl(mangoGroup, mangoCache, mangoAccount, perpMarkets, quoteRootBank, owner, mangoAccounts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // fetch all MangoAccounts filtered for having this perp market in basket\n            if (mangoAccounts === undefined) {\n                mangoAccounts = yield this.getAllMangoAccounts(mangoGroup, [], false);\n            }\n            const signatures = yield Promise.all(perpMarkets.map((pm) => {\n                const marketIndex = mangoGroup.getPerpMarketIndex(pm.publicKey);\n                const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n                const price = mangoCache.getPrice(marketIndex);\n                const pnl = mangoAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price);\n                return pnl.isPos()\n                    ? this.settlePnl(mangoGroup, mangoCache, mangoAccount, pm, quoteRootBank, mangoCache.getPrice(marketIndex), owner, mangoAccounts)\n                    : utils_1.promiseNull();\n            }));\n            function filterNulls(value) {\n                if (value === null)\n                    return false;\n                return true;\n            }\n            const filtered = signatures === null || signatures === void 0 ? void 0 : signatures.filter(filterNulls);\n            return (filtered === null || filtered === void 0 ? void 0 : filtered.length) ? filtered : undefined;\n        });\n    }\n    /**\n     * Settle all perp accounts with any pnl\n     */\n    settleAllPerpPnl(mangoGroup, mangoCache, mangoAccount, perpMarkets, quoteRootBank, owner, mangoAccounts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // fetch all MangoAccounts filtered for having this perp market in basket\n            if (mangoAccounts === undefined) {\n                mangoAccounts = yield this.getAllMangoAccounts(mangoGroup, [], false);\n            }\n            return yield Promise.all(perpMarkets.map((pm) => {\n                const marketIndex = mangoGroup.getPerpMarketIndex(pm.publicKey);\n                const perpMarketInfo = mangoGroup.perpMarkets[marketIndex];\n                const price = mangoCache.getPrice(marketIndex);\n                const pnl = mangoAccount.perpAccounts[marketIndex].getPnl(perpMarketInfo, mangoCache.perpMarketCache[marketIndex], price);\n                return !pnl.isZero()\n                    ? this.settlePnl(mangoGroup, mangoCache, mangoAccount, pm, quoteRootBank, mangoCache.getPrice(marketIndex), owner, mangoAccounts)\n                    : utils_1.promiseNull();\n            }));\n        });\n    }\n    getMangoAccountsForOwner(mangoGroup, owner, includeOpenOrders = false) {\n        const filters = [\n            {\n                memcmp: {\n                    offset: layout_1.MangoAccountLayout.offsetOf('owner'),\n                    bytes: owner.toBase58(),\n                },\n            },\n        ];\n        return this.getAllMangoAccounts(mangoGroup, filters, includeOpenOrders);\n    }\n    /**\n     * Get all MangoAccounts where `delegate` pubkey has authority\n     */\n    getMangoAccountsForDelegate(mangoGroup, delegate, includeOpenOrders = false) {\n        const filters = [\n            {\n                memcmp: {\n                    offset: layout_1.MangoAccountLayout.offsetOf('delegate'),\n                    bytes: delegate.toBase58(),\n                },\n            },\n        ];\n        return this.getAllMangoAccounts(mangoGroup, filters, includeOpenOrders);\n    }\n    getAllMangoAccounts(mangoGroup, filters, includeOpenOrders = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accountFilters = [\n                {\n                    memcmp: {\n                        offset: layout_1.MangoAccountLayout.offsetOf('mangoGroup'),\n                        bytes: mangoGroup.publicKey.toBase58(),\n                    },\n                },\n                {\n                    dataSize: layout_1.MangoAccountLayout.span,\n                },\n            ];\n            if (filters && filters.length) {\n                accountFilters.push(...filters);\n            }\n            const mangoAccounts = yield utils_1.getFilteredProgramAccounts(this.connection, this.programId, accountFilters).then((accounts) => accounts.map(({ publicKey, accountInfo }) => {\n                return new MangoAccount_1.default(publicKey, layout_1.MangoAccountLayout.decode(accountInfo == null ? undefined : accountInfo.data));\n            }));\n            if (includeOpenOrders) {\n                const openOrderPks = mangoAccounts\n                    .map((ma) => ma.spotOpenOrders.filter((pk) => !pk.equals(utils_1.zeroKey)))\n                    .flat();\n                const openOrderAccountInfos = yield utils_1.getMultipleAccounts(this.connection, openOrderPks);\n                const openOrders = openOrderAccountInfos.map(({ publicKey, accountInfo }) => serum_1.OpenOrders.fromAccountInfo(publicKey, accountInfo, mangoGroup.dexProgramId));\n                const pkToOpenOrdersAccount = {};\n                openOrders.forEach((openOrdersAccount) => {\n                    pkToOpenOrdersAccount[openOrdersAccount.publicKey.toBase58()] =\n                        openOrdersAccount;\n                });\n                for (const ma of mangoAccounts) {\n                    for (let i = 0; i < ma.spotOpenOrders.length; i++) {\n                        if (ma.spotOpenOrders[i].toBase58() in pkToOpenOrdersAccount) {\n                            ma.spotOpenOrdersAccounts[i] =\n                                pkToOpenOrdersAccount[ma.spotOpenOrders[i].toBase58()];\n                        }\n                    }\n                }\n            }\n            return mangoAccounts;\n        });\n    }\n    addStubOracle(mangoGroupPk, admin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const createOracleAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.StubOracleLayout.span, this.programId);\n            const instruction = instruction_1.makeAddOracleInstruction(this.programId, mangoGroupPk, createOracleAccountInstruction.account.publicKey, admin.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(createOracleAccountInstruction.instruction);\n            transaction.add(instruction);\n            const additionalSigners = [createOracleAccountInstruction.account];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    setStubOracle(mangoGroupPk, oraclePk, admin, price) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeSetOracleInstruction(this.programId, mangoGroupPk, oraclePk, admin.publicKey, fixednum_1.I80F48.fromNumber(price));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    addPerpMarket(mangoGroup, oraclePk, mngoMintPk, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, baseLotSize, quoteLotSize, maxNumEvents, rate, // liquidity mining params; set rate == 0 if no liq mining\n    maxDepthBps, targetPeriodLength, mngoPerPeriod, exp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const makePerpMarketAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.PerpMarketLayout.span, this.programId);\n            const makeEventQueueAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.PerpEventQueueHeaderLayout.span + maxNumEvents * layout_1.PerpEventLayout.span, this.programId);\n            const makeBidAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n            const makeAskAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n            const mngoVaultAccount = new web3_js_1.Keypair();\n            const mngoVaultAccountInstructions = yield utils_1.createTokenAccountInstructions(this.connection, admin.publicKey, mngoVaultAccount.publicKey, mngoMintPk, mangoGroup.signerKey);\n            const instruction = yield instruction_1.makeAddPerpMarketInstruction(this.programId, mangoGroup.publicKey, oraclePk, makePerpMarketAccountInstruction.account.publicKey, makeEventQueueAccountInstruction.account.publicKey, makeBidAccountInstruction.account.publicKey, makeAskAccountInstruction.account.publicKey, mngoVaultAccount.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(makerFee), fixednum_1.I80F48.fromNumber(takerFee), new bn_js_1.default(baseLotSize), new bn_js_1.default(quoteLotSize), fixednum_1.I80F48.fromNumber(rate), fixednum_1.I80F48.fromNumber(maxDepthBps), new bn_js_1.default(targetPeriodLength), new bn_js_1.default(mngoPerPeriod), new bn_js_1.default(exp));\n            const createMngoVaultTransaction = new web3_js_1.Transaction();\n            createMngoVaultTransaction.add(...mngoVaultAccountInstructions);\n            yield this.sendTransaction(createMngoVaultTransaction, admin, [\n                mngoVaultAccount,\n            ]);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(makePerpMarketAccountInstruction.instruction);\n            transaction.add(makeEventQueueAccountInstruction.instruction);\n            transaction.add(makeBidAccountInstruction.instruction);\n            transaction.add(makeAskAccountInstruction.instruction);\n            transaction.add(instruction);\n            const additionalSigners = [\n                makePerpMarketAccountInstruction.account,\n                makeEventQueueAccountInstruction.account,\n                makeBidAccountInstruction.account,\n                makeAskAccountInstruction.account,\n            ];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    createPerpMarket(mangoGroup, oraclePk, mngoMintPk, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, baseLotSize, quoteLotSize, maxNumEvents, rate, // liquidity mining params; set rate == 0 if no liq mining\n    maxDepthBps, targetPeriodLength, mngoPerPeriod, exp, version, lmSizeShift, baseDecimals) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!admin.publicKey) {\n                return;\n            }\n            const [perpMarketPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                mangoGroup.publicKey.toBytes(),\n                new Buffer('PerpMarket', 'utf-8'),\n                oraclePk.toBytes(),\n            ], this.programId);\n            const makeEventQueueAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.PerpEventQueueHeaderLayout.span + maxNumEvents * layout_1.PerpEventLayout.span, this.programId);\n            const makeBidAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n            const makeAskAccountInstruction = yield utils_1.createAccountInstruction(this.connection, admin.publicKey, layout_1.BookSideLayout.span, this.programId);\n            const [mngoVaultPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                perpMarketPk.toBytes(),\n                spl_token_1.TOKEN_PROGRAM_ID.toBytes(),\n                mngoMintPk.toBytes(),\n            ], this.programId);\n            const instruction = yield instruction_1.makeCreatePerpMarketInstruction(this.programId, mangoGroup.publicKey, oraclePk, perpMarketPk, makeEventQueueAccountInstruction.account.publicKey, makeBidAccountInstruction.account.publicKey, makeAskAccountInstruction.account.publicKey, mngoMintPk, mngoVaultPk, admin.publicKey, mangoGroup.signerKey, fixednum_1.I80F48.fromNumber(maintLeverage), fixednum_1.I80F48.fromNumber(initLeverage), fixednum_1.I80F48.fromNumber(liquidationFee), fixednum_1.I80F48.fromNumber(makerFee), fixednum_1.I80F48.fromNumber(takerFee), new bn_js_1.default(baseLotSize), new bn_js_1.default(quoteLotSize), fixednum_1.I80F48.fromNumber(rate), fixednum_1.I80F48.fromNumber(maxDepthBps), new bn_js_1.default(targetPeriodLength), new bn_js_1.default(mngoPerPeriod), new bn_js_1.default(exp), new bn_js_1.default(version), new bn_js_1.default(lmSizeShift), new bn_js_1.default(baseDecimals));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(makeEventQueueAccountInstruction.instruction);\n            transaction.add(makeBidAccountInstruction.instruction);\n            transaction.add(makeAskAccountInstruction.instruction);\n            transaction.add(instruction);\n            const additionalSigners = [\n                makeEventQueueAccountInstruction.account,\n                makeBidAccountInstruction.account,\n                makeAskAccountInstruction.account,\n            ];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    // Liquidator Functions\n    forceCancelSpotOrders(mangoGroup, liqeeMangoAccount, spotMarket, baseRootBank, quoteRootBank, payer, limit) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const baseNodeBanks = yield baseRootBank.loadNodeBanks(this.connection);\n            const quoteNodeBanks = yield quoteRootBank.loadNodeBanks(this.connection);\n            const openOrdersKeys = [];\n            const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n            // Only pass in open orders if in margin basket or current market index, and\n            // the only writable account should be OpenOrders for current market index\n            for (let i = 0; i < liqeeMangoAccount.spotOpenOrders.length; i++) {\n                let pubkey = utils_1.zeroKey;\n                let isWritable = false;\n                if (i === spotMarketIndex) {\n                    isWritable = true;\n                    if (liqeeMangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n                        console.log('missing oo for ', spotMarketIndex);\n                        // open orders missing for this market; create a new one now\n                        // const openOrdersSpace = OpenOrders.getLayout(\n                        //   mangoGroup.dexProgramId,\n                        // ).span;\n                        // const openOrdersLamports =\n                        //   await this.connection.getMinimumBalanceForRentExemption(\n                        //     openOrdersSpace,\n                        //     'singleGossip',\n                        //   );\n                        // const accInstr = await createAccountInstruction(\n                        //   this.connection,\n                        //   owner.publicKey,\n                        //   openOrdersSpace,\n                        //   mangoGroup.dexProgramId,\n                        //   openOrdersLamports,\n                        // );\n                        // transaction.add(accInstr.instruction);\n                        // additionalSigners.push(accInstr.account);\n                        // pubkey = accInstr.account.publicKey;\n                    }\n                    else {\n                        pubkey = liqeeMangoAccount.spotOpenOrders[i];\n                    }\n                }\n                else if (liqeeMangoAccount.inMarginBasket[i]) {\n                    pubkey = liqeeMangoAccount.spotOpenOrders[i];\n                }\n                openOrdersKeys.push({ pubkey, isWritable });\n            }\n            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                spotMarket.publicKey.toBuffer(),\n                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], spotMarket.programId);\n            const instruction = instruction_1.makeForceCancelSpotOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, baseRootBank.publicKey, baseNodeBanks[0].publicKey, baseNodeBanks[0].vault, quoteRootBank.publicKey, quoteNodeBanks[0].publicKey, quoteNodeBanks[0].vault, spotMarket.publicKey, spotMarket.bidsAddress, spotMarket.asksAddress, mangoGroup.signerKey, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, dexSigner, mangoGroup.dexProgramId, openOrdersKeys, limit);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    /**\n     * Send multiple instructions to cancel all perp orders in this market\n     */\n    forceCancelAllPerpOrdersInMarket(mangoGroup, liqee, perpMarket, payer, limitPerInstruction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transaction = new web3_js_1.Transaction();\n            const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n            const instruction = instruction_1.makeForceCancelPerpOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqee.publicKey, liqee.spotOpenOrders, new bn_js_1.default(limitPerInstruction));\n            transaction.add(instruction);\n            let orderCount = 0;\n            for (let i = 0; i < liqee.orderMarket.length; i++) {\n                if (liqee.orderMarket[i] !== marketIndex) {\n                    continue;\n                }\n                orderCount++;\n                if (orderCount === limitPerInstruction) {\n                    orderCount = 0;\n                    const instruction = instruction_1.makeForceCancelPerpOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqee.publicKey, liqee.spotOpenOrders, new bn_js_1.default(limitPerInstruction));\n                    transaction.add(instruction);\n                    // TODO - verify how many such instructions can go into one tx\n                    // right now 10 seems reasonable considering size of 800ish bytes if all spot open orders present\n                    if (transaction.instructions.length === 10) {\n                        break;\n                    }\n                }\n            }\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    forceCancelPerpOrders(mangoGroup, liqeeMangoAccount, perpMarket, payer, limit) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeForceCancelPerpOrdersInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, liqeeMangoAccount.publicKey, liqeeMangoAccount.spotOpenOrders, limit);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    liquidateTokenAndToken(mangoGroup, liqeeMangoAccount, liqorMangoAccount, assetRootBank, liabRootBank, payer, maxLiabTransfer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeLiquidateTokenAndTokenInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, assetRootBank.publicKey, assetRootBank.nodeBanks[0], liabRootBank.publicKey, liabRootBank.nodeBanks[0], liqeeMangoAccount.spotOpenOrders, liqorMangoAccount.spotOpenOrders, maxLiabTransfer);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    liquidateTokenAndPerp(mangoGroup, liqeeMangoAccount, liqorMangoAccount, rootBank, payer, assetType, assetIndex, liabType, liabIndex, maxLiabTransfer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeLiquidateTokenAndPerpInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, rootBank.publicKey, rootBank.nodeBanks[0], liqeeMangoAccount.spotOpenOrders, liqorMangoAccount.spotOpenOrders, assetType, new bn_js_1.default(assetIndex), liabType, new bn_js_1.default(liabIndex), maxLiabTransfer);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    liquidatePerpMarket(mangoGroup, liqeeMangoAccount, liqorMangoAccount, perpMarket, payer, baseTransferRequest) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeLiquidatePerpMarketInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, liqeeMangoAccount.spotOpenOrders, liqorMangoAccount.spotOpenOrders, baseTransferRequest);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    settleFees(mangoGroup, mangoAccount, perpMarket, rootBank, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const nodeBanks = yield rootBank.loadNodeBanks(this.connection);\n            const instruction = instruction_1.makeSettleFeesInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, mangoAccount.publicKey, rootBank.publicKey, nodeBanks[0].publicKey, nodeBanks[0].vault, mangoGroup.feesVault, mangoGroup.signerKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    resolvePerpBankruptcy(mangoGroup, liqeeMangoAccount, liqorMangoAccount, perpMarket, rootBank, payer, liabIndex, maxLiabTransfer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const nodeBanks = yield rootBank.loadNodeBanks(this.connection);\n            const instruction = instruction_1.makeResolvePerpBankruptcyInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, rootBank.publicKey, nodeBanks[0].publicKey, nodeBanks[0].vault, mangoGroup.insuranceVault, mangoGroup.signerKey, perpMarket.publicKey, liqorMangoAccount.spotOpenOrders, new bn_js_1.default(liabIndex), maxLiabTransfer);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    resolveTokenBankruptcy(mangoGroup, liqeeMangoAccount, liqorMangoAccount, quoteRootBank, liabRootBank, payer, maxLiabTransfer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const quoteNodeBanks = yield quoteRootBank.loadNodeBanks(this.connection);\n            const instruction = instruction_1.makeResolveTokenBankruptcyInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, liqeeMangoAccount.publicKey, liqorMangoAccount.publicKey, payer.publicKey, quoteRootBank.publicKey, quoteRootBank.nodeBanks[0], quoteNodeBanks[0].vault, mangoGroup.insuranceVault, mangoGroup.signerKey, liabRootBank.publicKey, liabRootBank.nodeBanks[0], liqorMangoAccount.spotOpenOrders, liabRootBank.nodeBanks, maxLiabTransfer);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    redeemMngo(mangoGroup, mangoAccount, perpMarket, payer, mngoRootBank, mngoNodeBank, mngoVault) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeRedeemMngoInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank, mngoNodeBank, mngoVault, mangoGroup.signerKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            return yield this.sendTransaction(transaction, payer, []);\n        });\n    }\n    redeemAllMngo(mangoGroup, mangoAccount, payer, mngoRootBank, mngoNodeBank, mngoVault) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const transactions = [];\n            let transaction = new web3_js_1.Transaction();\n            const perpMarkets = yield Promise.all(mangoAccount.perpAccounts.map((perpAccount, i) => {\n                if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {\n                    return utils_1.promiseUndef();\n                }\n                else {\n                    return this.getPerpMarket(mangoGroup.perpMarkets[i].perpMarket, mangoGroup.tokens[i].decimals, mangoGroup.tokens[layout_1.QUOTE_INDEX].decimals);\n                }\n            }));\n            for (let i = 0; i < mangoAccount.perpAccounts.length; i++) {\n                const perpMarket = perpMarkets[i];\n                if (perpMarket === undefined)\n                    continue;\n                const instruction = instruction_1.makeRedeemMngoInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank, mngoNodeBank, mngoVault, mangoGroup.signerKey);\n                transaction.add(instruction);\n                if (transaction.instructions.length === 9) {\n                    transactions.push(transaction);\n                    transaction = new web3_js_1.Transaction();\n                }\n            }\n            if (transaction.instructions.length > 0) {\n                transactions.push(transaction);\n                // txProms.push(this.sendTransaction(transaction, payer, []));\n            }\n            const transactionsAndSigners = transactions.map((tx) => ({\n                transaction: tx,\n                signers: [],\n            }));\n            if (transactionsAndSigners.length === 0) {\n                throw new Error('No MNGO rewards to redeem');\n            }\n            // Sign multiple transactions at once for better UX\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer,\n            });\n            if (signedTransactions) {\n                const txSigs = yield Promise.all(signedTransactions.map((signedTransaction) => this.sendSignedTransaction({ signedTransaction })));\n                return txSigs;\n            }\n            else {\n                throw new Error('Unable to sign all RedeemMngo transactions');\n            }\n        });\n    }\n    addMangoAccountInfo(mangoGroup, mangoAccount, owner, info) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeAddMangoAccountInfoInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, info);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    depositMsrm(mangoGroup, mangoAccount, owner, msrmAccount, quantity) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeDepositMsrmInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, msrmAccount, mangoGroup.msrmVault, new bn_js_1.default(Math.floor(quantity)));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    withdrawMsrm(mangoGroup, mangoAccount, owner, msrmAccount, quantity) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeWithdrawMsrmInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, msrmAccount, mangoGroup.msrmVault, mangoGroup.signerKey, new bn_js_1.default(Math.floor(quantity)));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    changePerpMarketParams(mangoGroup, perpMarket, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, rate, maxDepthBps, targetPeriodLength, mngoPerPeriod, exp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!admin.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeChangePerpMarketParamsInstruction(this.programId, mangoGroup.publicKey, perpMarket.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(makerFee), fixednum_1.I80F48.fromNumberOrUndef(takerFee), fixednum_1.I80F48.fromNumberOrUndef(rate), fixednum_1.I80F48.fromNumberOrUndef(maxDepthBps), targetPeriodLength !== undefined ? new bn_js_1.default(targetPeriodLength) : undefined, mngoPerPeriod !== undefined ? new bn_js_1.default(mngoPerPeriod) : undefined, exp !== undefined ? new bn_js_1.default(exp) : undefined);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    changePerpMarketParams2(mangoGroup, perpMarket, admin, maintLeverage, initLeverage, liquidationFee, makerFee, takerFee, rate, maxDepthBps, targetPeriodLength, mngoPerPeriod, exp, version, lmSizeShift) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!admin.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeChangePerpMarketParams2Instruction(this.programId, mangoGroup.publicKey, perpMarket.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(makerFee), fixednum_1.I80F48.fromNumberOrUndef(takerFee), fixednum_1.I80F48.fromNumberOrUndef(rate), fixednum_1.I80F48.fromNumberOrUndef(maxDepthBps), targetPeriodLength !== undefined ? new bn_js_1.default(targetPeriodLength) : undefined, mngoPerPeriod !== undefined ? new bn_js_1.default(mngoPerPeriod) : undefined, exp !== undefined ? new bn_js_1.default(exp) : undefined, version !== undefined ? new bn_js_1.default(version) : undefined, lmSizeShift !== undefined ? new bn_js_1.default(lmSizeShift) : undefined);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    setGroupAdmin(mangoGroup, newAdmin, admin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!admin.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeSetGroupAdminInstruction(this.programId, mangoGroup.publicKey, newAdmin, admin.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    /**\n     * Add allowance for orders to be cancelled and replaced in a single transaction\n     */\n    modifySpotOrder(mangoGroup, mangoAccount, mangoCache, spotMarket, owner, order, side, price, size, orderType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const instruction = instruction_1.makeCancelSpotOrderInstruction(this.programId, mangoGroup.publicKey, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, order.openOrdersAddress, mangoGroup.signerKey, spotMarket['_decoded'].eventQueue, order);\n            transaction.add(instruction);\n            const dexSigner = yield web3_js_1.PublicKey.createProgramAddress([\n                spotMarket.publicKey.toBuffer(),\n                spotMarket['_decoded'].vaultSignerNonce.toArrayLike(Buffer, 'le', 8),\n            ], spotMarket.programId);\n            const spotMarketIndex = mangoGroup.getSpotMarketIndex(spotMarket.publicKey);\n            if (!mangoGroup.rootBankAccounts.length) {\n                yield mangoGroup.loadRootBanks(this.connection);\n            }\n            const baseRootBank = mangoGroup.rootBankAccounts[spotMarketIndex];\n            const baseNodeBank = baseRootBank === null || baseRootBank === void 0 ? void 0 : baseRootBank.nodeBankAccounts[0];\n            const quoteRootBank = mangoGroup.rootBankAccounts[layout_1.QUOTE_INDEX];\n            const quoteNodeBank = quoteRootBank === null || quoteRootBank === void 0 ? void 0 : quoteRootBank.nodeBankAccounts[0];\n            if (!baseNodeBank || !quoteNodeBank) {\n                throw new Error('Invalid or missing node banks');\n            }\n            const settleFundsInstruction = instruction_1.makeSettleFundsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, owner.publicKey, mangoAccount.publicKey, spotMarket.programId, spotMarket.publicKey, mangoAccount.spotOpenOrders[spotMarketIndex], mangoGroup.signerKey, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, mangoGroup.tokens[spotMarketIndex].rootBank, baseNodeBank.publicKey, mangoGroup.tokens[layout_1.QUOTE_INDEX].rootBank, quoteNodeBank.publicKey, baseNodeBank.vault, quoteNodeBank.vault, dexSigner);\n            transaction.add(settleFundsInstruction);\n            const additionalSigners = [];\n            const limitPrice = spotMarket.priceNumberToLots(price);\n            const maxBaseQuantity = spotMarket.baseSizeNumberToLots(size);\n            // TODO implement srm vault fee discount\n            // const feeTier = getFeeTier(0, nativeToUi(mangoGroup.nativeSrm || 0, SRM_DECIMALS));\n            const feeTier = serum_1.getFeeTier(0, utils_1.nativeToUi(0, 0));\n            const rates = serum_1.getFeeRates(feeTier);\n            const maxQuoteQuantity = new bn_js_1.default(spotMarket['_decoded'].quoteLotSize.toNumber() * (1 + rates.taker)).mul(spotMarket\n                .baseSizeNumberToLots(size)\n                .mul(spotMarket.priceNumberToLots(price)));\n            // Checks already completed as only price modified\n            if (maxBaseQuantity.lte(utils_1.ZERO_BN)) {\n                throw new Error('size too small');\n            }\n            if (limitPrice.lte(utils_1.ZERO_BN)) {\n                throw new Error('invalid price');\n            }\n            const selfTradeBehavior = 'decrementTake';\n            if (!baseRootBank || !baseNodeBank || !quoteRootBank || !quoteNodeBank) {\n                throw new Error('Invalid or missing banks');\n            }\n            const openOrdersKeys = [];\n            // Only pass in open orders if in margin basket or current market index, and\n            // the only writable account should be OpenOrders for current market index\n            for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n                let pubkey = utils_1.zeroKey;\n                let isWritable = false;\n                if (i === spotMarketIndex) {\n                    isWritable = true;\n                    if (mangoAccount.spotOpenOrders[spotMarketIndex].equals(utils_1.zeroKey)) {\n                        // open orders missing for this market; create a new one now\n                        const openOrdersSpace = serum_1.OpenOrders.getLayout(mangoGroup.dexProgramId).span;\n                        const openOrdersLamports = yield this.connection.getMinimumBalanceForRentExemption(openOrdersSpace, 'processed');\n                        const accInstr = yield utils_1.createAccountInstruction(this.connection, owner.publicKey, openOrdersSpace, mangoGroup.dexProgramId, openOrdersLamports);\n                        const initOpenOrders = instruction_1.makeInitSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoGroup.dexProgramId, accInstr.account.publicKey, spotMarket.publicKey, mangoGroup.signerKey);\n                        const initTx = new web3_js_1.Transaction();\n                        initTx.add(accInstr.instruction);\n                        initTx.add(initOpenOrders);\n                        yield this.sendTransaction(initTx, owner, [accInstr.account]);\n                        pubkey = accInstr.account.publicKey;\n                    }\n                    else {\n                        pubkey = mangoAccount.spotOpenOrders[i];\n                    }\n                }\n                else if (mangoAccount.inMarginBasket[i]) {\n                    pubkey = mangoAccount.spotOpenOrders[i];\n                }\n                openOrdersKeys.push({ pubkey, isWritable });\n            }\n            const placeOrderInstruction = instruction_1.makePlaceSpotOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, spotMarket.programId, spotMarket.publicKey, spotMarket['_decoded'].bids, spotMarket['_decoded'].asks, spotMarket['_decoded'].requestQueue, spotMarket['_decoded'].eventQueue, spotMarket['_decoded'].baseVault, spotMarket['_decoded'].quoteVault, baseRootBank.publicKey, baseNodeBank.publicKey, baseNodeBank.vault, quoteRootBank.publicKey, quoteNodeBank.publicKey, quoteNodeBank.vault, mangoGroup.signerKey, dexSigner, mangoGroup.srmVault, // TODO: choose msrm vault if it has any deposits\n            openOrdersKeys, side, limitPrice, maxBaseQuantity, maxQuoteQuantity, selfTradeBehavior, orderType, order.clientId);\n            transaction.add(placeOrderInstruction);\n            if (spotMarketIndex > 0) {\n                console.log(spotMarketIndex - 1, mangoAccount.spotOpenOrders[spotMarketIndex - 1].toBase58(), openOrdersKeys[spotMarketIndex - 1].pubkey.toBase58());\n            }\n            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);\n            // update MangoAccount to have new OpenOrders pubkey\n            mangoAccount.spotOpenOrders[spotMarketIndex] =\n                openOrdersKeys[spotMarketIndex].pubkey;\n            mangoAccount.inMarginBasket[spotMarketIndex] = true;\n            console.log(spotMarketIndex, mangoAccount.spotOpenOrders[spotMarketIndex].toBase58(), openOrdersKeys[spotMarketIndex].pubkey.toBase58());\n            return txid;\n        });\n    }\n    modifyPerpOrder(mangoGroup, mangoAccount, mangoCache, perpMarket, owner, order, side, price, quantity, orderType, clientOrderId, bookSideInfo, // ask if side === bid, bids if side === ask; if this is given; crank instruction is added\n    invalidIdOk = false, // Don't throw error if order is invalid\n    referrerMangoAccountPk) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            const cancelInstruction = instruction_1.makeCancelPerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, order, invalidIdOk);\n            transaction.add(cancelInstruction);\n            const [nativePrice, nativeQuantity] = perpMarket.uiToNativePriceQuantity(price, quantity);\n            const placeInstruction = instruction_1.makePlacePerpOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoCache, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, mangoAccount.spotOpenOrders, nativePrice, nativeQuantity, clientOrderId\n                ? new bn_js_1.default(clientOrderId)\n                : (_a = order.clientId) !== null && _a !== void 0 ? _a : new bn_js_1.default(Date.now()), side, orderType, false, referrerMangoAccountPk);\n            transaction.add(placeInstruction);\n            if (bookSideInfo) {\n                const bookSide = bookSideInfo.data\n                    ? new book_1.BookSide(side === 'buy' ? perpMarket.asks : perpMarket.bids, perpMarket, layout_1.BookSideLayout.decode(bookSideInfo.data))\n                    : [];\n                const accounts = new Set();\n                accounts.add(mangoAccount.publicKey.toBase58());\n                for (const order of bookSide) {\n                    accounts.add(order.owner.toBase58());\n                    if (accounts.size >= 10) {\n                        break;\n                    }\n                }\n                const consumeInstruction = instruction_1.makeConsumeEventsInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, perpMarket.publicKey, perpMarket.eventQueue, Array.from(accounts)\n                    .map((s) => new web3_js_1.PublicKey(s))\n                    .sort(), new bn_js_1.default(4));\n                transaction.add(consumeInstruction);\n            }\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    addPerpTriggerOrder(mangoGroup, mangoAccount, perpMarket, owner, orderType, side, price, quantity, triggerCondition, triggerPrice, reduceOnly, clientOrderId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const transaction = new web3_js_1.Transaction();\n            const additionalSigners = [];\n            let advancedOrders = mangoAccount.advancedOrdersKey;\n            if (mangoAccount.advancedOrdersKey.equals(utils_1.zeroKey)) {\n                [advancedOrders] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccount.publicKey.toBytes()], this.programId);\n                console.log('AdvancedOrders PDA:', advancedOrders.toBase58());\n                transaction.add(instruction_1.makeInitAdvancedOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, advancedOrders));\n            }\n            const marketIndex = mangoGroup.getPerpMarketIndex(perpMarket.publicKey);\n            const baseTokenInfo = mangoGroup.tokens[marketIndex];\n            const quoteTokenInfo = mangoGroup.tokens[layout_1.QUOTE_INDEX];\n            const baseUnit = Math.pow(10, baseTokenInfo.decimals);\n            const quoteUnit = Math.pow(10, quoteTokenInfo.decimals);\n            const nativePrice = new bn_js_1.default(price * quoteUnit)\n                .mul(perpMarket.baseLotSize)\n                .div(perpMarket.quoteLotSize.mul(new bn_js_1.default(baseUnit)));\n            const nativeQuantity = new bn_js_1.default(quantity * baseUnit).div(perpMarket.baseLotSize);\n            const nativeTriggerPrice = fixednum_1.I80F48.fromNumber(triggerPrice *\n                Math.pow(10, perpMarket.quoteDecimals - perpMarket.baseDecimals));\n            const openOrders = mangoAccount.spotOpenOrders.filter((pk, i) => mangoAccount.inMarginBasket[i]);\n            transaction.add(instruction_1.makeAddPerpTriggerOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, advancedOrders, mangoGroup.mangoCache, perpMarket.publicKey, openOrders, orderType, side, nativePrice, nativeQuantity, triggerCondition, nativeTriggerPrice, reduceOnly, new bn_js_1.default(clientOrderId !== null && clientOrderId !== void 0 ? clientOrderId : Date.now())));\n            const txid = yield this.sendTransaction(transaction, owner, additionalSigners);\n            mangoAccount.advancedOrdersKey = advancedOrders;\n            return txid;\n        });\n    }\n    removeAdvancedOrder(mangoGroup, mangoAccount, owner, orderIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!owner.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeRemoveAdvancedOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, owner.publicKey, mangoAccount.advancedOrdersKey, orderIndex);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, owner, additionalSigners);\n        });\n    }\n    executePerpTriggerOrder(mangoGroup, mangoAccount, mangoCache, perpMarket, payer, orderIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const openOrders = mangoAccount.spotOpenOrders.filter((pk, i) => mangoAccount.inMarginBasket[i]);\n            const instruction = instruction_1.makeExecutePerpTriggerOrderInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, mangoAccount.advancedOrdersKey, payer.publicKey, mangoCache.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, perpMarket.eventQueue, openOrders, new bn_js_1.default(orderIndex));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    closeAdvancedOrders(mangoGroup, mangoAccount, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeCloseAdvancedOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoAccount.advancedOrdersKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    closeSpotOpenOrders(mangoGroup, mangoAccount, payer, marketIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeCloseSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.dexProgramId, mangoAccount.spotOpenOrders[marketIndex], mangoGroup.spotMarkets[marketIndex].spotMarket, mangoGroup.signerKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    closeMangoAccount(mangoGroup, mangoAccount, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeCloseMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    createDustAccount(mangoGroup, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const [mangoAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n            const instruction = instruction_1.makeCreateDustAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccountPk, payer.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    resolveDust(mangoGroup, mangoAccount, rootBank, mangoCache, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const [dustAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n            const instruction = instruction_1.makeResolveDustInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, dustAccountPk, rootBank.publicKey, rootBank.nodeBanks[0], mangoCache.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    updateMarginBasket(mangoGroup, mangoAccount, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instruction = instruction_1.makeUpdateMarginBasketInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, mangoAccount.spotOpenOrders);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    resolveAllDust(mangoGroup, mangoAccount, mangoCache, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const transactionsAndSigners = [];\n            const [dustAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n            for (const rootBank of mangoGroup.rootBankAccounts) {\n                const transactionAndSigners = {\n                    transaction: new web3_js_1.Transaction(),\n                    signers: [],\n                };\n                if (rootBank) {\n                    const tokenIndex = mangoGroup.getRootBankIndex(rootBank === null || rootBank === void 0 ? void 0 : rootBank.publicKey);\n                    const nativeDeposit = mangoAccount.getNativeDeposit(rootBank, tokenIndex);\n                    const nativeBorrow = mangoAccount.getNativeBorrow(rootBank, tokenIndex);\n                    console.log('nativeDeposit', nativeDeposit.toString());\n                    console.log('nativeBorrow', nativeBorrow.toString());\n                    console.log('tokenIndex', tokenIndex.toString());\n                    if ((nativeDeposit.gt(fixednum_1.ZERO_I80F48) && nativeDeposit.lt(fixednum_1.ONE_I80F48)) ||\n                        (nativeBorrow.gt(fixednum_1.ZERO_I80F48) && nativeBorrow.lt(fixednum_1.ONE_I80F48))) {\n                        const instruction = instruction_1.makeResolveDustInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, dustAccountPk, rootBank.publicKey, rootBank.nodeBanks[0], mangoCache.publicKey);\n                        transactionAndSigners.transaction.add(instruction);\n                    }\n                }\n                transactionsAndSigners.push(transactionAndSigners);\n            }\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer: payer,\n            });\n            if (signedTransactions) {\n                for (const signedTransaction of signedTransactions) {\n                    if (signedTransaction.instructions.length == 0) {\n                        continue;\n                    }\n                    const txid = yield this.sendSignedTransaction({\n                        signedTransaction,\n                    });\n                    console.log(txid);\n                }\n            }\n            else {\n                throw new Error('Unable to sign ResolveDust transactions');\n            }\n        });\n    }\n    emptyAndCloseMangoAccount(mangoGroup, mangoAccount, mangoCache, mngoIndex, payer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const transactionsAndSigners = [];\n            const redeemMngoTransaction = {\n                transaction: new web3_js_1.Transaction(),\n                signers: [],\n            };\n            const mngoRootBank = mangoGroup.rootBankAccounts[mngoIndex];\n            const perpMarkets = yield Promise.all(mangoAccount.perpAccounts.map((perpAccount, i) => {\n                if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {\n                    return utils_1.promiseUndef();\n                }\n                else {\n                    return this.getPerpMarket(mangoGroup.perpMarkets[i].perpMarket, mangoGroup.tokens[i].decimals, mangoGroup.tokens[layout_1.QUOTE_INDEX].decimals);\n                }\n            }));\n            let redeemedMngo = false;\n            for (let i = 0; i < mangoAccount.perpAccounts.length; i++) {\n                const perpAccount = mangoAccount.perpAccounts[i];\n                if (perpAccount.mngoAccrued.eq(utils_1.ZERO_BN)) {\n                    continue;\n                }\n                redeemedMngo = true;\n                const perpMarket = perpMarkets[i];\n                // this is actually an error state; Means there is mngo accrued but PerpMarket doesn't exist\n                if (perpMarket === undefined)\n                    continue;\n                const instruction = instruction_1.makeRedeemMngoInstruction(this.programId, mangoGroup.publicKey, mangoGroup.mangoCache, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.mngoVault, mngoRootBank.publicKey, mngoRootBank.nodeBanks[0], mngoRootBank.nodeBankAccounts[0].vault, mangoGroup.signerKey);\n                redeemMngoTransaction.transaction.add(instruction);\n            }\n            transactionsAndSigners.push(redeemMngoTransaction);\n            const resolveAllDustTransaction = {\n                transaction: new web3_js_1.Transaction(),\n                signers: [],\n            };\n            const [dustAccountPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoGroup.publicKey.toBytes(), new Buffer('DustAccount', 'utf-8')], this.programId);\n            for (const rootBank of mangoGroup.rootBankAccounts) {\n                if (rootBank) {\n                    const tokenIndex = mangoGroup.getRootBankIndex(rootBank === null || rootBank === void 0 ? void 0 : rootBank.publicKey);\n                    const tokenMint = mangoGroup.tokens[tokenIndex].mint;\n                    const shouldWithdrawMngo = redeemedMngo && tokenIndex === mngoIndex;\n                    if (mangoAccount.deposits[tokenIndex].isPos() || shouldWithdrawMngo) {\n                        const withdrawTransaction = {\n                            transaction: new web3_js_1.Transaction(),\n                            signers: [],\n                        };\n                        let tokenAcc = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, payer.publicKey);\n                        let wrappedSolAccount = null;\n                        if (tokenMint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n                            wrappedSolAccount = new web3_js_1.Keypair();\n                            tokenAcc = wrappedSolAccount.publicKey;\n                            const space = 165;\n                            const lamports = yield this.connection.getMinimumBalanceForRentExemption(space, 'processed');\n                            withdrawTransaction.transaction.add(web3_js_1.SystemProgram.createAccount({\n                                fromPubkey: payer.publicKey,\n                                newAccountPubkey: tokenAcc,\n                                lamports,\n                                space,\n                                programId: spl_token_1.TOKEN_PROGRAM_ID,\n                            }));\n                            withdrawTransaction.transaction.add(token_instructions_1.initializeAccount({\n                                account: tokenAcc,\n                                mint: token_instructions_1.WRAPPED_SOL_MINT,\n                                owner: payer.publicKey,\n                            }));\n                            withdrawTransaction.signers.push(wrappedSolAccount);\n                        }\n                        else {\n                            const tokenAccExists = yield this.connection.getAccountInfo(tokenAcc, 'processed');\n                            if (!tokenAccExists) {\n                                withdrawTransaction.transaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, tokenAcc, payer.publicKey, payer.publicKey));\n                            }\n                        }\n                        const instruction = instruction_1.makeWithdrawInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.mangoCache, rootBank.publicKey, rootBank.nodeBanks[0], rootBank.nodeBankAccounts[0].vault, tokenAcc, mangoGroup.signerKey, mangoAccount.spotOpenOrders, _1.U64_MAX_BN, false);\n                        withdrawTransaction.transaction.add(instruction);\n                        if (wrappedSolAccount) {\n                            withdrawTransaction.transaction.add(token_instructions_1.closeAccount({\n                                source: wrappedSolAccount.publicKey,\n                                destination: payer.publicKey,\n                                owner: payer.publicKey,\n                            }));\n                        }\n                        transactionsAndSigners.push(withdrawTransaction);\n                    }\n                    const nativeBorrow = mangoAccount.getNativeBorrow(mangoCache.rootBankCache[tokenIndex], tokenIndex);\n                    if (shouldWithdrawMngo ||\n                        mangoAccount.deposits[tokenIndex].isPos() ||\n                        (nativeBorrow.gt(fixednum_1.ZERO_I80F48) && nativeBorrow.lt(fixednum_1.ONE_I80F48))) {\n                        const instruction = instruction_1.makeResolveDustInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, dustAccountPk, rootBank.publicKey, rootBank.nodeBanks[0], mangoCache.publicKey);\n                        resolveAllDustTransaction.transaction.add(instruction);\n                    }\n                }\n            }\n            transactionsAndSigners.push(resolveAllDustTransaction);\n            const closeAccountsTransaction = {\n                transaction: new web3_js_1.Transaction(),\n                signers: [],\n            };\n            for (let i = 0; i < mangoAccount.spotOpenOrders.length; i++) {\n                const openOrders = mangoAccount.spotOpenOrders[i];\n                const spotMarket = mangoGroup.spotMarkets[i].spotMarket;\n                if (!openOrders.equals(utils_1.zeroKey)) {\n                    closeAccountsTransaction.transaction.add(instruction_1.makeCloseSpotOpenOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoGroup.dexProgramId, openOrders, spotMarket, mangoGroup.signerKey));\n                }\n            }\n            if (!mangoAccount.advancedOrdersKey.equals(utils_1.zeroKey)) {\n                closeAccountsTransaction.transaction.add(instruction_1.makeCloseAdvancedOrdersInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, mangoAccount.advancedOrdersKey));\n            }\n            if (mangoAccount.metaData.version == 0) {\n                closeAccountsTransaction.transaction.add(instruction_1.makeUpgradeMangoAccountV0V1Instruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey));\n            }\n            closeAccountsTransaction.transaction.add(instruction_1.makeCloseMangoAccountInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey));\n            transactionsAndSigners.push(closeAccountsTransaction);\n            const signedTransactions = yield this.signTransactions({\n                transactionsAndSigners,\n                payer: payer,\n            });\n            const txids = [];\n            if (signedTransactions) {\n                for (const signedTransaction of signedTransactions) {\n                    if (signedTransaction.instructions.length == 0) {\n                        continue;\n                    }\n                    const txid = yield this.sendSignedTransaction({\n                        signedTransaction,\n                    });\n                    txids.push(txid);\n                    console.log(txid);\n                }\n            }\n            else {\n                throw new Error('Unable to sign emptyAndCloseMangoAccount transactions');\n            }\n            return txids;\n        });\n    }\n    cancelPerpOrderSide(mangoGroup, mangoAccount, perpMarket, payer, side, limit) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeCancelPerpOrdersSideInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, perpMarket.publicKey, perpMarket.bids, perpMarket.asks, side, new bn_js_1.default(limit));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    setDelegate(mangoGroup, mangoAccount, payer, delegate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeSetDelegateInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, delegate);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    changeSpotMarketParams(mangoGroup, spotMarket, rootBank, admin, maintLeverage, initLeverage, liquidationFee, optimalUtil, optimalRate, maxRate, version) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!admin.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeChangeSpotMarketParamsInstruction(this.programId, mangoGroup.publicKey, spotMarket.publicKey, rootBank.publicKey, admin.publicKey, fixednum_1.I80F48.fromNumberOrUndef(maintLeverage), fixednum_1.I80F48.fromNumberOrUndef(initLeverage), fixednum_1.I80F48.fromNumberOrUndef(liquidationFee), fixednum_1.I80F48.fromNumberOrUndef(optimalUtil), fixednum_1.I80F48.fromNumberOrUndef(optimalRate), fixednum_1.I80F48.fromNumberOrUndef(maxRate), version !== undefined ? new bn_js_1.default(version) : undefined);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    /**\n     * Change the referral fee params\n     * @param mangoGroup\n     * @param admin\n     * @param refSurcharge normal units 0.0001 -> 1 basis point\n     * @param refShare\n     * @param refMngoRequired ui units -> 1 -> 1_000_000 MNGO\n     */\n    changeReferralFeeParams(mangoGroup, admin, refSurcharge, refShare, refMngoRequired) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!admin.publicKey) {\n                return;\n            }\n            const instruction = instruction_1.makeChangeReferralFeeParamsInstruction(this.programId, mangoGroup.publicKey, admin.publicKey, new bn_js_1.default(refSurcharge * layout_1.CENTIBPS_PER_UNIT), new bn_js_1.default(refShare * layout_1.CENTIBPS_PER_UNIT), new bn_js_1.default(refMngoRequired * 1000000));\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, admin, additionalSigners);\n        });\n    }\n    setReferrerMemory(mangoGroup, mangoAccount, payer, // must be also owner of mangoAccount\n    referrerMangoAccountPk) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            // Generate the PDA pubkey\n            const [referrerMemoryPk] = yield web3_js_1.PublicKey.findProgramAddress([mangoAccount.publicKey.toBytes(), new Buffer('ReferrerMemory', 'utf-8')], this.programId);\n            const instruction = instruction_1.makeSetReferrerMemoryInstruction(this.programId, mangoGroup.publicKey, mangoAccount.publicKey, payer.publicKey, referrerMemoryPk, referrerMangoAccountPk, payer.publicKey);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    getReferrerPda(mangoGroup, referrerId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const encoded = Buffer.from(referrerId, 'utf8');\n            if (encoded.length > layout_1.INFO_LEN) {\n                throw new Error(`info string too long. Must be less than or equal to ${layout_1.INFO_LEN} bytes`);\n            }\n            const encodedReferrerId = Buffer.concat([\n                encoded,\n                Buffer.alloc(layout_1.INFO_LEN - encoded.length, 0),\n            ]);\n            // Generate the PDA pubkey\n            const [referrerIdRecordPk] = yield web3_js_1.PublicKey.findProgramAddress([\n                mangoGroup.publicKey.toBytes(),\n                new Buffer('ReferrerIdRecord', 'utf-8'),\n                encodedReferrerId,\n            ], this.programId);\n            return { referrerPda: referrerIdRecordPk, encodedReferrerId };\n        });\n    }\n    registerReferrerId(mangoGroup, referrerMangoAccount, payer, // will also owner of referrerMangoAccount\n    referrerId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!payer.publicKey) {\n                return;\n            }\n            const { referrerPda, encodedReferrerId } = yield this.getReferrerPda(mangoGroup, referrerId);\n            const instruction = instruction_1.makeRegisterReferrerIdInstruction(this.programId, mangoGroup.publicKey, referrerMangoAccount.publicKey, referrerPda, payer.publicKey, encodedReferrerId);\n            const transaction = new web3_js_1.Transaction();\n            transaction.add(instruction);\n            const additionalSigners = [];\n            return yield this.sendTransaction(transaction, payer, additionalSigners);\n        });\n    }\n    getReferrerIdsForMangoAccount(mangoAccount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const filters = [\n                {\n                    memcmp: {\n                        offset: _1.ReferrerIdRecordLayout.offsetOf('referrerMangoAccount'),\n                        bytes: mangoAccount.publicKey.toBase58(),\n                    },\n                },\n                {\n                    dataSize: _1.ReferrerIdRecordLayout.span,\n                },\n            ];\n            const referrerIds = yield utils_1.getFilteredProgramAccounts(this.connection, this.programId, filters).then((referrerIds) => {\n                return referrerIds.map(({ accountInfo }) => {\n                    return new _1.ReferrerIdRecord(_1.ReferrerIdRecordLayout.decode(accountInfo == null ? undefined : accountInfo.data));\n                });\n            });\n            return referrerIds;\n        });\n    }\n}\nexports.MangoClient = MangoClient;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}