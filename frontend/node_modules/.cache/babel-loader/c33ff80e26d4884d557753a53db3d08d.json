{"ast":null,"code":"import { initializeAccount } from \"@project-serum/serum/lib/token-instructions\";\nimport { PublicKey, sendAndConfirmTransaction, SystemProgram, Transaction, sendTransaction, Account, TransactionInstruction } from \"@solana/web3.js\";\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, connection, RENT_PROGRAM_ID, SYSTEM_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"./constants\";\nconst GREETING_SIZE = 171;\nexport async function setWalletTransaction(instruction, publicKey) {\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.feePayer = publicKey;\n  let hash = await connection.getRecentBlockhash();\n  console.log(\"blockhash\", hash);\n  transaction.recentBlockhash = hash.blockhash;\n  return transaction;\n}\nexport async function signAndSendTransaction(wallet, transaction) {\n  // console.log(`wallet :::`, wallet)\n  let signedTrans = await wallet.signTransaction(transaction);\n  console.log(\"sign transaction:\", signedTrans);\n  let signature = await connection.sendRawTransaction(signedTrans.serialize(), {\n    skipPreflight: true\n  }); //skipPreflight -**Main\n\n  console.log(\"send raw transaction\");\n  return signature;\n}\nexport async function createAccountInstruction(connection, payer, space, programId, lamports, transaction, signers) {\n  const account = new Account();\n  const instruction = SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: lamports ? lamports : await connection.getMinimumBalanceForRentExemption(space),\n    space,\n    programId\n  });\n  transaction.add(instruction);\n  signers.push(account);\n  return account.publicKey;\n}\nexport const createKeyIfNotExists = async (wallet, payerAccount, programId, seed, size, transaction) => {\n  const greetedPubkey = await PublicKey.createWithSeed(wallet.publicKey, seed, programId);\n  console.log(`createWithSeed :: `, greetedPubkey); // Check if the greeting account has already been created\n\n  const greetedAccount = await connection.getAccountInfo(greetedPubkey);\n  console.log(`createWithSeed check if Accinfo NULL ::: `, greetedAccount);\n\n  if (greetedAccount === null) {\n    console.log('Creating account', greetedPubkey.toBase58(), 'to say hello to');\n    const lamports = await connection.getMinimumBalanceForRentExemption(size);\n    console.log(`lamports :::: `, lamports);\n    transaction.add(SystemProgram.createAccountWithSeed({\n      fromPubkey: wallet.publicKey,\n      basePubkey: wallet.publicKey,\n      seed: seed,\n      newAccountPubkey: greetedPubkey,\n      lamports,\n      space: size,\n      programId\n    }));\n  }\n\n  return greetedPubkey;\n};\nexport async function createProgramAccountIfNotExist(connection, account, owner, programId, lamports, size, transaction, signer) {\n  let publicKey;\n\n  if (account) {\n    publicKey = new PublicKey(account);\n  } else {\n    const newAccount = new Account();\n    publicKey = newAccount.publicKey;\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: owner,\n      newAccountPubkey: publicKey,\n      lamports: lamports !== null && lamports !== void 0 ? lamports : await connection.getMinimumBalanceForRentExemption(size),\n      space: size,\n      programId\n    }));\n    signer.push(newAccount);\n  }\n\n  return publicKey;\n}\nexport async function createTokenAccountIfNotExist(connection, account, owner, mintAddress, lamports, transaction, signer) {\n  let publicKey;\n\n  if (account) {\n    publicKey = new PublicKey(account);\n  } else {\n    publicKey = await createProgramAccountIfNotExist(connection, account, owner, TOKEN_PROGRAM_ID, lamports, 390, transaction, signer);\n    transaction.add(initializeAccount({\n      account: publicKey,\n      mint: new PublicKey(mintAddress),\n      owner\n    }));\n  }\n\n  return publicKey;\n} // associated address \n\nexport async function findProgramAddress(seeds, programId) {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return {\n    publicKey,\n    nonce\n  };\n}\nexport async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {\n  const {\n    publicKey\n  } = await findProgramAddress([walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID);\n  return publicKey;\n}\nexport async function createAssociatedTokenAccountIfNotExist(wallet, tokenMintAddress, owner, transaction) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(owner, tokenMintAddress);\n  const tokenAccount = await connection.getAccountInfo(associatedTokenAddress);\n\n  if (tokenAccount == null) {\n    const keys = [{\n      pubkey: wallet.publicKey,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: owner,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: tokenMintAddress,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSTEM_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: RENT_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }];\n    transaction.add(new TransactionInstruction({\n      keys,\n      programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n      data: Buffer.from([])\n    })); //await signAndSendTransaction(wallet, transaction)\n  }\n\n  return associatedTokenAddress;\n}\nexport const commitment = 'confirmed';\nexport async function signTransaction(connection, wallet, transaction) {\n  let signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n  transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  return await wallet.signTransaction(transaction);\n}\nexport async function sendNewTransaction(connection, wallet, transaction) {\n  let signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  const signedTransaction = await signTransaction(connection, wallet, transaction, signers);\n  return await sendSignedTransaction(connection, signedTransaction);\n}\nexport async function sendSignedTransaction(connection, signedTransaction) {\n  const rawTransaction = signedTransaction.serialize();\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true,\n    preflightCommitment: commitment\n  });\n  return txid;\n}","map":{"version":3,"sources":["/Users/zohebshahzan/code/Solana-2/frontend/src/utils/web3.js"],"names":["initializeAccount","PublicKey","sendAndConfirmTransaction","SystemProgram","Transaction","sendTransaction","Account","TransactionInstruction","ASSOCIATED_TOKEN_PROGRAM_ID","connection","RENT_PROGRAM_ID","SYSTEM_PROGRAM_ID","TOKEN_PROGRAM_ID","GREETING_SIZE","setWalletTransaction","instruction","publicKey","transaction","add","feePayer","hash","getRecentBlockhash","console","log","recentBlockhash","blockhash","signAndSendTransaction","wallet","signedTrans","signTransaction","signature","sendRawTransaction","serialize","skipPreflight","createAccountInstruction","payer","space","programId","lamports","signers","account","createAccount","fromPubkey","newAccountPubkey","getMinimumBalanceForRentExemption","push","createKeyIfNotExists","payerAccount","seed","size","greetedPubkey","createWithSeed","greetedAccount","getAccountInfo","toBase58","createAccountWithSeed","basePubkey","createProgramAccountIfNotExist","owner","signer","newAccount","createTokenAccountIfNotExist","mintAddress","mint","findProgramAddress","seeds","nonce","findAssociatedTokenAddress","walletAddress","tokenMintAddress","toBuffer","createAssociatedTokenAccountIfNotExist","associatedTokenAddress","tokenAccount","keys","pubkey","isSigner","isWritable","data","Buffer","from","commitment","setSigners","map","s","length","partialSign","sendNewTransaction","signedTransaction","sendSignedTransaction","rawTransaction","txid","preflightCommitment"],"mappings":"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","sourcesContent":["import { initializeAccount } from \"@project-serum/serum/lib/token-instructions\";\nimport { PublicKey, sendAndConfirmTransaction, SystemProgram, Transaction, sendTransaction, Account, TransactionInstruction } from \"@solana/web3.js\";\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, connection, RENT_PROGRAM_ID, SYSTEM_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"./constants\";\n\nconst GREETING_SIZE = 171;\n\nexport async function setWalletTransaction(\n  instruction,\n  publicKey\n) {\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.feePayer = publicKey;\n  let hash = await connection.getRecentBlockhash();\n  console.log(\"blockhash\", hash);\n  transaction.recentBlockhash = hash.blockhash;\n  return transaction;\n}\n\nexport async function signAndSendTransaction(\n  wallet,\n  transaction\n) {\n  // console.log(`wallet :::`, wallet)\n  let signedTrans = await wallet.signTransaction(transaction);\n  console.log(\"sign transaction:\",signedTrans);\n  let signature = await connection.sendRawTransaction(signedTrans.serialize(), { skipPreflight: true }); //skipPreflight -**Main\n  console.log(\"send raw transaction\");\n  return signature;\n}\n\nexport async function createAccountInstruction(\n  connection,\n  payer,\n  space,\n  programId,\n  lamports,\n  transaction,\n  signers\n) {\n  const account = new Account();\n  const instruction = SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: lamports ? lamports : await connection.getMinimumBalanceForRentExemption(space),\n    space,\n    programId\n  })\n\n  transaction.add(instruction);\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nexport const createKeyIfNotExists = async (wallet, payerAccount, programId, seed, size, transaction) => {\n  const greetedPubkey = await PublicKey.createWithSeed(\n    wallet.publicKey,\n    seed,\n    programId,\n  );\n\n  console.log(`createWithSeed :: `, greetedPubkey)\n\n  // Check if the greeting account has already been created\n  const greetedAccount = await connection.getAccountInfo(greetedPubkey);\n  console.log(`createWithSeed check if Accinfo NULL ::: `, greetedAccount);\n  \n  if (greetedAccount === null) {\n\n    console.log('Creating account',greetedPubkey.toBase58(),'to say hello to',);\n    const lamports = await connection.getMinimumBalanceForRentExemption(size);\n    console.log(`lamports :::: `, lamports)\n\n    transaction.add(\n      SystemProgram.createAccountWithSeed({\n        fromPubkey: wallet.publicKey,\n        basePubkey: wallet.publicKey,\n        seed: seed,\n        newAccountPubkey: greetedPubkey,\n        lamports,\n        space: size,\n        programId,\n      }))\n\n    \n  }\n  return greetedPubkey;\n}\n\nexport async function createProgramAccountIfNotExist(\n  connection,\n  account,\n  owner,\n  programId,\n  lamports,\n  size,\n  transaction,\n  signer\n) {\n  let publicKey\n\n  if (account) {\n    publicKey = new PublicKey(account)\n  } else {\n    const newAccount = new Account()\n    publicKey = newAccount.publicKey\n\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: owner,\n        newAccountPubkey: publicKey,\n        lamports: lamports ?? (await connection.getMinimumBalanceForRentExemption(size)),\n        space: size,\n        programId\n      })\n    )\n\n    signer.push(newAccount)\n  }\n\n  return publicKey\n}\n\n\nexport async function createTokenAccountIfNotExist(\n  connection,\n  account,\n  owner,\n  mintAddress,\n  lamports,\n  transaction,\n  signer\n) {\n  let publicKey\n\n  if (account) {\n    publicKey = new PublicKey(account)\n  } else {\n    publicKey = await createProgramAccountIfNotExist(\n      connection,\n      account,\n      owner,\n      TOKEN_PROGRAM_ID,\n      lamports,\n      390,\n      transaction,\n      signer\n    )\n\n    transaction.add(\n      initializeAccount({\n        account: publicKey,\n        mint: new PublicKey(mintAddress),\n        owner\n      })\n    )\n  }\n\n  return publicKey\n}\n\n// associated address \n\n\nexport async function findProgramAddress(seeds, programId) {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId)\n  return { publicKey, nonce }\n}\n\n\nexport async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {\n  const { publicKey } = await findProgramAddress(\n    [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],\n    ASSOCIATED_TOKEN_PROGRAM_ID\n  )\n  return publicKey\n}\n\n\n\n\nexport async function createAssociatedTokenAccountIfNotExist(\n  wallet,\n  tokenMintAddress,\n  owner,\n  transaction\n) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(owner, tokenMintAddress)\n  \n  const tokenAccount = await connection.getAccountInfo(associatedTokenAddress);\n  \n  if (tokenAccount == null)\n  {\n    const keys = [\n      {\n        pubkey: wallet.publicKey,\n        isSigner: true,\n        isWritable: true\n      },\n      {\n        pubkey: associatedTokenAddress,\n        isSigner: false,\n        isWritable: true\n      },\n      {\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: tokenMintAddress,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: SYSTEM_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: RENT_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }\n    ]\n    transaction.add(\n      new TransactionInstruction({\n        keys,\n        programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n        data: Buffer.from([])\n      }))\n    //await signAndSendTransaction(wallet, transaction)\n  }\n  return associatedTokenAddress\n}\n\nexport const commitment = 'confirmed'\n\n\nexport async function signTransaction(\n  connection,\n  wallet,\n  transaction,\n  signers = []\n) {\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash\n  transaction.setSigners(wallet.publicKey, ...signers.map((s) => s.publicKey))\n  if (signers.length > 0) {\n    transaction.partialSign(...signers)\n  }\n  return await wallet.signTransaction(transaction)\n}\n\nexport async function sendNewTransaction(\n  connection,\n  wallet,\n  transaction,\n  signers = [],\n) {\n  const signedTransaction = await signTransaction(connection, wallet, transaction, signers)\n  return await sendSignedTransaction(connection, signedTransaction)\n}\n\nexport async function sendSignedTransaction(connection, signedTransaction) {\n  const rawTransaction = signedTransaction.serialize()\n\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true,\n    preflightCommitment: commitment\n  })\n\n  return txid\n}"]},"metadata":{},"sourceType":"module"}