{"ast":null,"code":"import { initializeAccount } from \"@project-serum/serum/lib/token-instructions\";\nimport { PublicKey, sendAndConfirmTransaction, SystemProgram, Transaction, sendTransaction, Account, TransactionInstruction } from \"@solana/web3.js\";\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, connection, RENT_PROGRAM_ID, SYSTEM_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"./constants\";\nconst GREETING_SIZE = 171;\nexport async function setWalletTransaction(instruction, publicKey) {\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.feePayer = publicKey;\n  let hash = await connection.getRecentBlockhash();\n  console.log(\"blockhash\", hash);\n  transaction.recentBlockhash = hash.blockhash;\n  return transaction;\n}\nexport async function signAndSendTransaction(wallet, transaction) {\n  console.log(`wallet :::`, wallet);\n  let signedTrans = await wallet.signTransaction(transaction);\n  console.log(\"sign transaction\");\n  let signature = await connection.sendRawTransaction(signedTrans.serialize(), {\n    skipPreflight: true\n  });\n  console.log(\"send raw transaction\");\n  return signature;\n}\nexport const createKeyIfNotExists = async (wallet, payerAccount, programId, seed, size, transaction) => {\n  const greetedPubkey = await PublicKey.createWithSeed(wallet.publicKey, seed, programId);\n  console.log(`greetedPubkey :: `, greetedPubkey); // Check if the greeting account has already been created\n\n  const greetedAccount = await connection.getAccountInfo(greetedPubkey);\n  console.log(`greetedAccount ::: `, greetedAccount);\n\n  if (greetedAccount === null) {\n    console.log('Creating account', greetedPubkey.toBase58(), 'to say hello to');\n    const lamports = await connection.getMinimumBalanceForRentExemption(size); // const transaction = new Transaction().add(\n    // );\n\n    console.log(`lamports :::: `, lamports);\n    transaction.add(SystemProgram.createAccountWithSeed({\n      fromPubkey: wallet.publicKey,\n      basePubkey: wallet.publicKey,\n      seed: seed,\n      newAccountPubkey: greetedPubkey,\n      lamports,\n      space: size,\n      programId\n    })); // await sendAndConfirmTransaction(connection, transaction, [payerAccount]);\n    //await signAndSendTransaction(wallet, transaction)\n  }\n\n  return greetedPubkey;\n};\nexport async function createProgramAccountIfNotExist(connection, account, owner, programId, lamports, size, transaction, signer) {\n  let publicKey;\n\n  if (account) {\n    publicKey = new PublicKey(account);\n  } else {\n    const newAccount = new Account();\n    publicKey = newAccount.publicKey;\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: owner,\n      newAccountPubkey: publicKey,\n      lamports: lamports !== null && lamports !== void 0 ? lamports : await connection.getMinimumBalanceForRentExemption(size),\n      space: size,\n      programId\n    }));\n    signer.push(newAccount);\n  }\n\n  return publicKey;\n}\nexport async function createTokenAccountIfNotExist(connection, account, owner, mintAddress, lamports, transaction, signer) {\n  let publicKey;\n\n  if (account) {\n    publicKey = new PublicKey(account);\n  } else {\n    publicKey = await createProgramAccountIfNotExist(connection, account, owner, TOKEN_PROGRAM_ID, lamports, 390, transaction, signer);\n    transaction.add(initializeAccount({\n      account: publicKey,\n      mint: new PublicKey(mintAddress),\n      owner\n    }));\n  }\n\n  return publicKey;\n} // associated address \n\nexport async function findProgramAddress(seeds, programId) {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return {\n    publicKey,\n    nonce\n  };\n}\nexport async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {\n  const {\n    publicKey\n  } = await findProgramAddress([walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID);\n  return publicKey;\n}\nexport async function createAssociatedTokenAccountIfNotExist(wallet, tokenMintAddress, owner, transaction) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(owner, tokenMintAddress);\n  const tokenAccount = await connection.getAccountInfo(associatedTokenAddress);\n\n  if (tokenAccount == null) {\n    const keys = [{\n      pubkey: wallet.publicKey,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: owner,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: tokenMintAddress,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSTEM_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: RENT_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false\n    }];\n    transaction.add(new TransactionInstruction({\n      keys,\n      programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n      data: Buffer.from([])\n    })); //await signAndSendTransaction(wallet, transaction)\n  }\n\n  return associatedTokenAddress;\n}\nexport const commitment = 'confirmed';\nexport async function signTransaction(connection, wallet, transaction) {\n  let signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n  transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  return await wallet.signTransaction(transaction);\n}\nexport async function sendNewTransaction(connection, wallet, transaction) {\n  let signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  const signedTransaction = await signTransaction(connection, wallet, transaction, signers);\n  return await sendSignedTransaction(connection, signedTransaction);\n}\nexport async function sendSignedTransaction(connection, signedTransaction) {\n  const rawTransaction = signedTransaction.serialize();\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true,\n    preflightCommitment: commitment\n  });\n  return txid;\n}","map":{"version":3,"sources":["/Users/zohebshahzan/code/Solana-2/frontend/src/utils/web3.js"],"names":["initializeAccount","PublicKey","sendAndConfirmTransaction","SystemProgram","Transaction","sendTransaction","Account","TransactionInstruction","ASSOCIATED_TOKEN_PROGRAM_ID","connection","RENT_PROGRAM_ID","SYSTEM_PROGRAM_ID","TOKEN_PROGRAM_ID","GREETING_SIZE","setWalletTransaction","instruction","publicKey","transaction","add","feePayer","hash","getRecentBlockhash","console","log","recentBlockhash","blockhash","signAndSendTransaction","wallet","signedTrans","signTransaction","signature","sendRawTransaction","serialize","skipPreflight","createKeyIfNotExists","payerAccount","programId","seed","size","greetedPubkey","createWithSeed","greetedAccount","getAccountInfo","toBase58","lamports","getMinimumBalanceForRentExemption","createAccountWithSeed","fromPubkey","basePubkey","newAccountPubkey","space","createProgramAccountIfNotExist","account","owner","signer","newAccount","createAccount","push","createTokenAccountIfNotExist","mintAddress","mint","findProgramAddress","seeds","nonce","findAssociatedTokenAddress","walletAddress","tokenMintAddress","toBuffer","createAssociatedTokenAccountIfNotExist","associatedTokenAddress","tokenAccount","keys","pubkey","isSigner","isWritable","data","Buffer","from","commitment","signers","setSigners","map","s","length","partialSign","sendNewTransaction","signedTransaction","sendSignedTransaction","rawTransaction","txid","preflightCommitment"],"mappings":"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","sourcesContent":["import { initializeAccount } from \"@project-serum/serum/lib/token-instructions\";\nimport { PublicKey, sendAndConfirmTransaction, SystemProgram, Transaction, sendTransaction, Account, TransactionInstruction } from \"@solana/web3.js\";\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, connection, RENT_PROGRAM_ID, SYSTEM_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"./constants\";\n\nconst GREETING_SIZE = 171;\n\nexport async function setWalletTransaction(\n  instruction,\n  publicKey\n) {\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.feePayer = publicKey;\n  let hash = await connection.getRecentBlockhash();\n  console.log(\"blockhash\", hash);\n  transaction.recentBlockhash = hash.blockhash;\n  return transaction;\n}\n\nexport async function signAndSendTransaction(\n  wallet,\n  transaction\n) {\n  console.log(`wallet :::`, wallet)\n  let signedTrans = await wallet.signTransaction(transaction);\n  console.log(\"sign transaction\");\n  let signature = await connection.sendRawTransaction(signedTrans.serialize(), {\n    skipPreflight : true,\n  });\n  console.log(\"send raw transaction\");\n  return signature;\n}\n\nexport const createKeyIfNotExists = async (wallet, payerAccount, programId, seed, size, transaction) => {\n  const greetedPubkey = await PublicKey.createWithSeed(\n    wallet.publicKey,\n    seed,\n    programId,\n  );\n\n  console.log(`greetedPubkey :: `, greetedPubkey)\n\n  // Check if the greeting account has already been created\n  const greetedAccount = await connection.getAccountInfo(greetedPubkey);\n\n  console.log(`greetedAccount ::: `, greetedAccount)\n  if (greetedAccount === null) {\n    console.log(\n      'Creating account',\n      greetedPubkey.toBase58(),\n      'to say hello to',\n    );\n    const lamports = await connection.getMinimumBalanceForRentExemption(\n      size,\n    );\n\n    // const transaction = new Transaction().add(\n\n    // );\n    console.log(`lamports :::: `, lamports)\n    transaction.add(\n      SystemProgram.createAccountWithSeed({\n        fromPubkey: wallet.publicKey,\n        basePubkey: wallet.publicKey,\n        seed: seed,\n        newAccountPubkey: greetedPubkey,\n        lamports,\n        space: size,\n        programId,\n      }))\n\n    // await sendAndConfirmTransaction(connection, transaction, [payerAccount]);\n\n    //await signAndSendTransaction(wallet, transaction)\n  }\n  return greetedPubkey;\n}\n\nexport async function createProgramAccountIfNotExist(\n  connection,\n  account,\n  owner,\n  programId,\n  lamports,\n  size,\n  transaction,\n  signer\n) {\n  let publicKey\n\n  if (account) {\n    publicKey = new PublicKey(account)\n  } else {\n    const newAccount = new Account()\n    publicKey = newAccount.publicKey\n\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: owner,\n        newAccountPubkey: publicKey,\n        lamports: lamports ?? (await connection.getMinimumBalanceForRentExemption(size)),\n        space: size,\n        programId\n      })\n    )\n\n    signer.push(newAccount)\n  }\n\n  return publicKey\n}\n\n\nexport async function createTokenAccountIfNotExist(\n  connection,\n  account,\n  owner,\n  mintAddress,\n  lamports,\n  transaction,\n  signer\n) {\n  let publicKey\n\n  if (account) {\n    publicKey = new PublicKey(account)\n  } else {\n    publicKey = await createProgramAccountIfNotExist(\n      connection,\n      account,\n      owner,\n      TOKEN_PROGRAM_ID,\n      lamports,\n      390,\n      transaction,\n      signer\n    )\n\n    transaction.add(\n      initializeAccount({\n        account: publicKey,\n        mint: new PublicKey(mintAddress),\n        owner\n      })\n    )\n  }\n\n  return publicKey\n}\n\n// associated address \n\n\nexport async function findProgramAddress(seeds, programId) {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId)\n  return { publicKey, nonce }\n}\n\n\nexport async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {\n  const { publicKey } = await findProgramAddress(\n    [walletAddress.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()],\n    ASSOCIATED_TOKEN_PROGRAM_ID\n  )\n  return publicKey\n}\n\n\n\nexport async function createAssociatedTokenAccountIfNotExist(\n  wallet,\n  tokenMintAddress,\n  owner,\n  transaction\n) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(owner, tokenMintAddress)\n  \n  const tokenAccount = await connection.getAccountInfo(associatedTokenAddress);\n  \n  if (tokenAccount == null)\n  {\n    const keys = [\n      {\n        pubkey: wallet.publicKey,\n        isSigner: true,\n        isWritable: true\n      },\n      {\n        pubkey: associatedTokenAddress,\n        isSigner: false,\n        isWritable: true\n      },\n      {\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: tokenMintAddress,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: SYSTEM_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      },\n      {\n        pubkey: RENT_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }\n    ]\n    transaction.add(\n      new TransactionInstruction({\n        keys,\n        programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n        data: Buffer.from([])\n      }))\n    //await signAndSendTransaction(wallet, transaction)\n  }\n  return associatedTokenAddress\n}\n\nexport const commitment = 'confirmed'\n\n\nexport async function signTransaction(\n  connection,\n  wallet,\n  transaction,\n  signers = []\n) {\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash\n  transaction.setSigners(wallet.publicKey, ...signers.map((s) => s.publicKey))\n  if (signers.length > 0) {\n    transaction.partialSign(...signers)\n  }\n  return await wallet.signTransaction(transaction)\n}\n\nexport async function sendNewTransaction(\n  connection,\n  wallet,\n  transaction,\n  signers = [],\n) {\n  const signedTransaction = await signTransaction(connection, wallet, transaction, signers)\n  return await sendSignedTransaction(connection, signedTransaction)\n}\n\nexport async function sendSignedTransaction(connection, signedTransaction) {\n  const rawTransaction = signedTransaction.serialize()\n\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true,\n    preflightCommitment: commitment\n  })\n\n  return txid\n}"]},"metadata":{},"sourceType":"module"}