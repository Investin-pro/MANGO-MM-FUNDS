{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NEG_ONE_I80F48 = exports.ZERO_I80F48 = exports.ONE_I80F48 = exports.I80F48 = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst big_js_1 = __importDefault(require(\"big.js\"));\n\nconst toformat_1 = __importDefault(require(\"toformat\"));\n\ntoformat_1.default(big_js_1.default); // TODO - this whole class is inefficient; consider optimizing\n\nclass I80F48 {\n  constructor(data) {\n    if (data.lt(I80F48.MIN_BN) || data.gt(I80F48.MAX_BN)) {\n      throw new Error('Number out of range');\n    }\n\n    this.data = data;\n  }\n\n  static fromNumber(x) {\n    let int_part = Math.trunc(x);\n    let v = new bn_js_1.default(int_part).iushln(48);\n    v.iadd(new bn_js_1.default((x - int_part) * I80F48.MULTIPLIER_NUMBER));\n    return new I80F48(v);\n  }\n\n  static fromNumberOrUndef(x) {\n    return x === undefined ? undefined : I80F48.fromNumber(x);\n  }\n\n  static fromOptionalString(x) {\n    return x ? I80F48.fromString(x) : undefined;\n  }\n\n  static fromString(x) {\n    const initialValue = new big_js_1.default(x).times(I80F48.MULTIPLIER_BIG);\n    const fixedPointValue = new bn_js_1.default(initialValue.round().toFixed());\n    return new I80F48(fixedPointValue);\n  }\n\n  static fromI64(x) {\n    return new I80F48(x.ushln(48));\n  }\n\n  static fromU64(x) {\n    return new I80F48(x.ushln(48));\n  }\n\n  toTwos() {\n    return this.data.toTwos(I80F48.MAX_SIZE);\n  }\n\n  toString() {\n    return this.toBig().toFixed();\n  }\n  /**\n   * The number will be rounded first for UI sensibilities, then toFixed\n   */\n\n\n  toFixed(decimals) {\n    return this.toBig().round(14).toFixed(decimals);\n  }\n\n  toLocaleString(locales, options) {\n    return this.toNumber().toLocaleString(locales, options);\n  }\n\n  toFormat(decimals) {\n    // @ts-ignore\n    return this.toBig().toFormat(decimals);\n  }\n\n  toBig() {\n    return new big_js_1.default(this.data.toString()).div(I80F48.MULTIPLIER_BIG);\n  }\n\n  static fromBig(x) {\n    return new I80F48(new bn_js_1.default(x.mul(I80F48.MULTIPLIER_BIG).round().toFixed()));\n  }\n\n  toNumber() {\n    return this.toBig().toNumber();\n  }\n\n  static fromArray(src) {\n    if (src.length !== 16) {\n      throw new Error('Uint8Array must be of length 16');\n    }\n\n    return new I80F48(new bn_js_1.default(src, 'le').fromTwos(I80F48.MAX_SIZE));\n  }\n\n  toArray() {\n    return new Uint8Array(this.data.toTwos(I80F48.MAX_SIZE).toArray('le', 16));\n  }\n\n  toArrayLike(ArrayType, endian, length) {\n    return this.data.toTwos(I80F48.MAX_SIZE).toArrayLike(ArrayType, endian, length);\n  }\n\n  getData() {\n    return this.data;\n  }\n\n  getBinaryLayout() {\n    return this.data.toTwos(I80F48.MAX_SIZE).toString(2, I80F48.MAX_SIZE).replace(/-/g, '');\n  }\n\n  add(x) {\n    return new I80F48(this.data.add(x.getData()));\n  }\n\n  sub(x) {\n    return new I80F48(this.data.sub(x.getData()));\n  }\n\n  iadd(x) {\n    this.data.iadd(x.getData());\n    return this;\n  }\n\n  isub(x) {\n    this.data.isub(x.getData());\n    return this;\n  }\n\n  floor() {\n    // Low IQ method\n    return I80F48.fromBig(this.toBig().round(undefined, 0)); // return new I80F48(this.data.shrn(I80F48.FRACTIONS).shln(I80F48.FRACTIONS));\n  }\n\n  ceil() {\n    // Low IQ method, 3 -> round up\n    return I80F48.fromBig(this.toBig().round(undefined, 3)); // const frac = this.data.maskn(I80F48.FRACTIONS);\n    // if (frac.eq(ZERO_BN)) {\n    //   return this;\n    // } else {\n    //   return this.floor().add(ONE_I80F48);\n    // }\n  }\n\n  frac() {\n    // TODO verify this works for negative numbers\n    return new I80F48(this.data.maskn(I80F48.FRACTIONS));\n  }\n  /**\n   * Multiply the two and shift\n   */\n\n\n  mul(x) {\n    return new I80F48(this.data.mul(x.data).iushrn(I80F48.FRACTIONS));\n  }\n\n  imul(x) {\n    this.data.imul(x.getData()).iushrn(I80F48.FRACTIONS);\n    return this;\n  }\n\n  div(x) {\n    return new I80F48(this.data.ushln(I80F48.FRACTIONS).div(x.data));\n  }\n\n  idiv(x) {\n    this.data = this.data.iushln(I80F48.FRACTIONS).div(x.data);\n    return this;\n  }\n\n  gt(x) {\n    return this.data.gt(x.getData());\n  }\n\n  lt(x) {\n    return this.data.lt(x.getData());\n  }\n\n  gte(x) {\n    return this.data.gte(x.getData());\n  }\n\n  lte(x) {\n    return this.data.lte(x.getData());\n  }\n\n  eq(x) {\n    // TODO make sure this works when they're diff signs or 0\n    return this.data.eq(x.getData());\n  }\n\n  cmp(x) {\n    // TODO make sure this works when they're diff signs or 0\n    return this.data.cmp(x.getData());\n  }\n\n  neg() {\n    return this.mul(exports.NEG_ONE_I80F48);\n  }\n\n  isPos() {\n    return this.gt(exports.ZERO_I80F48);\n  }\n\n  isNeg() {\n    return this.data.isNeg();\n  }\n\n  isZero() {\n    return this.eq(exports.ZERO_I80F48);\n  }\n\n  min(x) {\n    return this.lte(x) ? this : x;\n  }\n\n  max(x) {\n    return this.gte(x) ? this : x;\n  }\n\n  abs() {\n    if (this.isNeg()) {\n      return this.neg();\n    } else {\n      return this;\n    }\n  }\n\n}\n\nexports.I80F48 = I80F48;\n/**\nThis is represented by a 128 bit signed integer underneath\nThe first 80 bits are treated as an integer and last 48 bits are treated as fractional part after binary point\nIt's possible to think of an I80F48 as an i128 divided by 2 ^ 40\n\nRead up on how fixed point math works: https://inst.eecs.berkeley.edu/~cs61c/sp06/handout/fixedpt.html\nRead up on how 2s complement works: https://en.wikipedia.org/wiki/Two%27s_complement\n */\n\nI80F48.MAX_SIZE = 128;\nI80F48.FRACTIONS = 48;\nI80F48.MULTIPLIER_BIG = new big_js_1.default(2).pow(I80F48.FRACTIONS);\nI80F48.MULTIPLIER_BN = new bn_js_1.default(2).pow(new bn_js_1.default(I80F48.FRACTIONS));\nI80F48.MULTIPLIER_NUMBER = Math.pow(2, I80F48.FRACTIONS);\nI80F48.MAX_BN = new bn_js_1.default(2).pow(new bn_js_1.default(I80F48.MAX_SIZE)).div(new bn_js_1.default(2)).sub(new bn_js_1.default(1));\nI80F48.MIN_BN = new bn_js_1.default(2).pow(new bn_js_1.default(I80F48.MAX_SIZE)).div(new bn_js_1.default(2)).neg();\n/** @internal */\n\nexports.ONE_I80F48 = I80F48.fromString('1');\n/** @internal */\n\nexports.ZERO_I80F48 = I80F48.fromString('0');\n/** @internal */\n\nexports.NEG_ONE_I80F48 = I80F48.fromString('-1');","map":{"version":3,"sources":["../../../src/utils/fixednum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NEG_ONE_I80F48 = exports.ZERO_I80F48 = exports.ONE_I80F48 = exports.I80F48 = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst toformat_1 = __importDefault(require(\"toformat\"));\ntoformat_1.default(big_js_1.default);\n// TODO - this whole class is inefficient; consider optimizing\nclass I80F48 {\n    constructor(data) {\n        if (data.lt(I80F48.MIN_BN) || data.gt(I80F48.MAX_BN)) {\n            throw new Error('Number out of range');\n        }\n        this.data = data;\n    }\n    static fromNumber(x) {\n        let int_part = Math.trunc(x);\n        let v = new bn_js_1.default(int_part).iushln(48);\n        v.iadd(new bn_js_1.default((x - int_part) * I80F48.MULTIPLIER_NUMBER));\n        return new I80F48(v);\n    }\n    static fromNumberOrUndef(x) {\n        return x === undefined ? undefined : I80F48.fromNumber(x);\n    }\n    static fromOptionalString(x) {\n        return x ? I80F48.fromString(x) : undefined;\n    }\n    static fromString(x) {\n        const initialValue = new big_js_1.default(x).times(I80F48.MULTIPLIER_BIG);\n        const fixedPointValue = new bn_js_1.default(initialValue.round().toFixed());\n        return new I80F48(fixedPointValue);\n    }\n    static fromI64(x) {\n        return new I80F48(x.ushln(48));\n    }\n    static fromU64(x) {\n        return new I80F48(x.ushln(48));\n    }\n    toTwos() {\n        return this.data.toTwos(I80F48.MAX_SIZE);\n    }\n    toString() {\n        return this.toBig().toFixed();\n    }\n    /**\n     * The number will be rounded first for UI sensibilities, then toFixed\n     */\n    toFixed(decimals) {\n        return this.toBig().round(14).toFixed(decimals);\n    }\n    toLocaleString(locales, options) {\n        return this.toNumber().toLocaleString(locales, options);\n    }\n    toFormat(decimals) {\n        // @ts-ignore\n        return this.toBig().toFormat(decimals);\n    }\n    toBig() {\n        return new big_js_1.default(this.data.toString()).div(I80F48.MULTIPLIER_BIG);\n    }\n    static fromBig(x) {\n        return new I80F48(new bn_js_1.default(x.mul(I80F48.MULTIPLIER_BIG).round().toFixed()));\n    }\n    toNumber() {\n        return this.toBig().toNumber();\n    }\n    static fromArray(src) {\n        if (src.length !== 16) {\n            throw new Error('Uint8Array must be of length 16');\n        }\n        return new I80F48(new bn_js_1.default(src, 'le').fromTwos(I80F48.MAX_SIZE));\n    }\n    toArray() {\n        return new Uint8Array(this.data.toTwos(I80F48.MAX_SIZE).toArray('le', 16));\n    }\n    toArrayLike(ArrayType, endian, length) {\n        return this.data\n            .toTwos(I80F48.MAX_SIZE)\n            .toArrayLike(ArrayType, endian, length);\n    }\n    getData() {\n        return this.data;\n    }\n    getBinaryLayout() {\n        return this.data\n            .toTwos(I80F48.MAX_SIZE)\n            .toString(2, I80F48.MAX_SIZE)\n            .replace(/-/g, '');\n    }\n    add(x) {\n        return new I80F48(this.data.add(x.getData()));\n    }\n    sub(x) {\n        return new I80F48(this.data.sub(x.getData()));\n    }\n    iadd(x) {\n        this.data.iadd(x.getData());\n        return this;\n    }\n    isub(x) {\n        this.data.isub(x.getData());\n        return this;\n    }\n    floor() {\n        // Low IQ method\n        return I80F48.fromBig(this.toBig().round(undefined, 0));\n        // return new I80F48(this.data.shrn(I80F48.FRACTIONS).shln(I80F48.FRACTIONS));\n    }\n    ceil() {\n        // Low IQ method, 3 -> round up\n        return I80F48.fromBig(this.toBig().round(undefined, 3));\n        // const frac = this.data.maskn(I80F48.FRACTIONS);\n        // if (frac.eq(ZERO_BN)) {\n        //   return this;\n        // } else {\n        //   return this.floor().add(ONE_I80F48);\n        // }\n    }\n    frac() {\n        // TODO verify this works for negative numbers\n        return new I80F48(this.data.maskn(I80F48.FRACTIONS));\n    }\n    /**\n     * Multiply the two and shift\n     */\n    mul(x) {\n        return new I80F48(this.data.mul(x.data).iushrn(I80F48.FRACTIONS));\n    }\n    imul(x) {\n        this.data.imul(x.getData()).iushrn(I80F48.FRACTIONS);\n        return this;\n    }\n    div(x) {\n        return new I80F48(this.data.ushln(I80F48.FRACTIONS).div(x.data));\n    }\n    idiv(x) {\n        this.data = this.data.iushln(I80F48.FRACTIONS).div(x.data);\n        return this;\n    }\n    gt(x) {\n        return this.data.gt(x.getData());\n    }\n    lt(x) {\n        return this.data.lt(x.getData());\n    }\n    gte(x) {\n        return this.data.gte(x.getData());\n    }\n    lte(x) {\n        return this.data.lte(x.getData());\n    }\n    eq(x) {\n        // TODO make sure this works when they're diff signs or 0\n        return this.data.eq(x.getData());\n    }\n    cmp(x) {\n        // TODO make sure this works when they're diff signs or 0\n        return this.data.cmp(x.getData());\n    }\n    neg() {\n        return this.mul(exports.NEG_ONE_I80F48);\n    }\n    isPos() {\n        return this.gt(exports.ZERO_I80F48);\n    }\n    isNeg() {\n        return this.data.isNeg();\n    }\n    isZero() {\n        return this.eq(exports.ZERO_I80F48);\n    }\n    min(x) {\n        return this.lte(x) ? this : x;\n    }\n    max(x) {\n        return this.gte(x) ? this : x;\n    }\n    abs() {\n        if (this.isNeg()) {\n            return this.neg();\n        }\n        else {\n            return this;\n        }\n    }\n}\nexports.I80F48 = I80F48;\n/**\nThis is represented by a 128 bit signed integer underneath\nThe first 80 bits are treated as an integer and last 48 bits are treated as fractional part after binary point\nIt's possible to think of an I80F48 as an i128 divided by 2 ^ 40\n\nRead up on how fixed point math works: https://inst.eecs.berkeley.edu/~cs61c/sp06/handout/fixedpt.html\nRead up on how 2s complement works: https://en.wikipedia.org/wiki/Two%27s_complement\n */\nI80F48.MAX_SIZE = 128;\nI80F48.FRACTIONS = 48;\nI80F48.MULTIPLIER_BIG = new big_js_1.default(2).pow(I80F48.FRACTIONS);\nI80F48.MULTIPLIER_BN = new bn_js_1.default(2).pow(new bn_js_1.default(I80F48.FRACTIONS));\nI80F48.MULTIPLIER_NUMBER = Math.pow(2, I80F48.FRACTIONS);\nI80F48.MAX_BN = new bn_js_1.default(2)\n    .pow(new bn_js_1.default(I80F48.MAX_SIZE))\n    .div(new bn_js_1.default(2))\n    .sub(new bn_js_1.default(1));\nI80F48.MIN_BN = new bn_js_1.default(2)\n    .pow(new bn_js_1.default(I80F48.MAX_SIZE))\n    .div(new bn_js_1.default(2))\n    .neg();\n/** @internal */\nexports.ONE_I80F48 = I80F48.fromString('1');\n/** @internal */\nexports.ZERO_I80F48 = I80F48.fromString('0');\n/** @internal */\nexports.NEG_ONE_I80F48 = I80F48.fromString('-1');\n//# sourceMappingURL=fixednum.js.map"]},"metadata":{},"sourceType":"script"}